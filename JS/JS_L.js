// /*
// // _______________________________________№1 Подключаем JS файл___________________________________________

// // тег <script src="..."></script> подключает файл js к файлу html
// //     его можно располагать и в head и в body, если расположить в хед то
// // <!DOCTYPE html>
// // <html lang="ru">
// // <head>
// //     <meta charset="UTF-8">
// //     <link rel="stylesheet" href="./CSS_L.css">
// //     <title>Lushenko</title>
// //         <script>
// //         alert('hello');
// //         </script>
// // </head>
// // <body>
// //     <h1>Lushenko_course.</h1>
// //     <p>let's get started</p>
// // </body>
// // </html>


// // код выше значит что к моменту выполнения JS будет выполнена только часть кода ниже

// // <!DOCTYPE html>
// // <html lang="ru">
// // <head>
// //     <meta charset="UTF-8">
// //     <link rel="stylesheet" href="./CSS_L.css">
// //     <title>Lushenko</title>
// //         <script>
// //         alert('hello');
// //         </script>

// // Ни нажатие кнопок и вывод информации на страницу - не возможно.

// //             Поправочка (при изменении браузера изменяется внешний вид всплывающего окна)
// //                        ( alert это вспомогательная системная функция ее не применяют для веб разработки)
// //                        (нужна для отладки)

// // Если подключить sript внутри body, то

// // <!DOCTYPE html>
// // <html lang="ru">
// // <head>
// //     <meta charset="UTF-8">
// //     <link rel="stylesheet" href="./CSS_L.css">
// //     <title>Lushenko</title>
// // </head>
// // <body>
// //     <h1>Lushenko_course.</h1>
// //     <p>let's get started</p>
// //     <script>
// //         alert('hello');
// //     </script>
// // </body>
// // </html>

// // в данном случае к моменту выполнения alert будет доступен вот этот участок кода

// // <!DOCTYPE html>
// // <html lang="ru">
// // <head>
// //     <meta charset="UTF-8">
// //     <link rel="stylesheet" href="./CSS_L.css">
// //     <title>Lushenko</title>
// // </head>
// // <body>
// //     <h1>Lushenko_course.</h1>
// //     <p>let's get started</p>
// //     <script>
// //         alert('hello');
// //     </script>

// // тегами h1 и p тоже можно манипулировать
// // но такое подключение не практикуется
// // для правильного подключения создаётся новый js файл

// // Рекомендуется подключать js файл в самом низу документа перед закрывающимся тегом body
// // в теге script в качестве атрибута указывается src и место расположения файла

// // <!DOCTYPE html>
// // <html lang="ru">
// // <head>
// //     <meta charset="UTF-8">
// //     <link rel="stylesheet" href="./CSS_L.css">
// //     <title>Lushenko</title>
// // </head>
// // <body>
// //     <h1>Lushenko_course.</h1>
// //     <p>let's get started</p>
// //     <script src="JS_L.js"></script>
// // </body>
// // </html>

// // alert('hello'); -- в консоли видим всплывающее окно hello
// // Если alert не заработал, ищем ошибку в написании тега <script> либо атрибута src
// // либо самого называния js файла в html документе

// // Всё что будет в html документе выше тега <script> будет доступно для манипуляции

// // На практике будет много js файлов

// // если мы добавим несколько script тегов то к каждому js файлу нужно указывать источник src

// // выглядит вот так

// // <!DOCTYPE html>
// // <html lang="ru">
// // <head>
// //     <meta charset="UTF-8">
// //     <link rel="stylesheet" href="./CSS_L.css">
// //     <title>Lushenko</title>
// // </head>
// // <body>
// //     <h1>Lushenko_course.</h1>
// //     <p>let's get started</p>
// //     <script src="JS_L.js"></script>
// //     <script src="JS_L2.js></script>
// // </body>
// // </html>   -- в консоли в начале отработает JS_L а потом JS_L2
// // То есть js файл отрабатывает первым, если файл подключен первым, как js_l то
// // он отработает в консоль первым
// // Если файл подключен вторым он отрабатывает вторым

// // Для проекта чаще всего практикуется создание отдельной папки для js файлов
// // в этом случае нужно указать данный факт в пути src тега script

// // Относительно html файл находится внутри папки js то есть
// // в пути тега script src нужно указать

// // <script src="js/JS_L.js"></script>

// // Если не указать путь через папку в консоли увидим ошибку

// // Так же Важный атрибут для script в html это defer иногда он пишется

// // <script defer></script>

// // Иногда в полном виде

// // <script defer="defer"></script>

// // defer - откладывает выполнение script до тех пор пока вся страница не будет загружена полностью

// // то есть применение данного атрибута позволяет обезопасить себя от
// // того что какая-то часть страницы не загрузится
// // не успеет подгрузиться а мы попытаемся в ней работать js

// // Используя defer тег script можно писать в любов месте html файла
// // Иногда его применяют подключаяя sript внутри head

// // Но чаще всего его не используют и применяют написание Javascript перед закрывающимся тегом body


// // Атрибут async - асинхронный. поддерживается всеми браузерами кроме IE9
// // Скрипт выполняется полностью асинхронно
// // То есть при обнаружении <script async src=""> браузер не останавлиает обработку страницы
// // А работает дальше. Когда скрипт будет загружен он выполнится

// // то есть JS находит первый скрипт и начинает его выполнять
// //     <script src="JS_L.js"></script>
// // после его выполнения переходит на следующий скрипт
// // Как только браузер видит async
// // Он начинает выполнять следующий скрипт сразу же
// //     <script src="JS_L2.js></script>
// // Не дожидаясь окончания выполнения первого скрипта

// // То есть будут выполняться два скрипта одновременно
// // Это увеличивает скорость запуска
// // Это позволяет делать множественные различные действия параллельно
// // Это важно для игр и интерактивных объектов

// // Но с другой стороны, если второй скрипт (который ниже в коде)
// //     <script src="JS_L2.js></script>
// // Требует результатов работы первого скрипта
// //     <script src="JS_L.js"></script>
// // Может случиться ошибка

// // Далее переходим в JS_L.js
// // */

// // /*
// // _______________________________________№2 Правила именования___________________________________________

// // Идентификатор - это специальное слово которое позволяет нам обратиться к области памяти
// //                 либо выполнить какие-то действия. Обратиться либо к переменной
// //                 либо к функции
// // В JS считается что именем переменной или именем фукнции необходимо правильно писать и исользовать
// // такие имена.

// // Под переменной мы скрываем какую-то число строку или значение true/false
// // Такие обращения к таким областям памяти к значениям называются переменными.

// // в JS для того чтобы обозначить переменную используют несколько способов

// // Можно писать
// // Первая буква должна быть либо $ либо _ либо латинская буква всё остальное -- Ошибка --
// // 1 Латинские буквы
// // 2 с маленькой буквы
// // 3 Если переменая должна состоять из двух значений(слов) тогда нужно писать в стиле camelCase
// // где каждое последующее слово начинается с заглавной буквы getElementById
// // 4 Цифры - можно использовать (но не в начале переменной)
// // customer1 - можно использовать customer_1 - можно использовать  1customer - нельзя использовать.
// // 5 _ $ можно использовать
// // 6 Помнить про чувствительность к регистру camelCase не то же самое что CamelCase


// // Нельзя использовать
// // 1 Первый символ не должен быть цифрой 1customer -- Ошибка -- как и название классов в CSS
// // 2 ключевые слова: new name etc
// // 3 русские буквы между английскими
// // если заменим о русскую на o латинскую программа выдаст ошибку которую будет сложно выявить
// // 4 пробелы
// // 5 дефисы (в целом можно но на практике не стоит)

// // Комментарий может быть

// // однострочным //  закоментировать строку Ctrl + /
// // многострочным /* ... */ // в некоторых случаях * ставят на каждой строчке, зачем?
// // // Данные строки не будут восприниматься js

// // /*
// // В конце каждой строки необходимо ставить ; наличие пробелов перед ; роли не играет.
// // Если необходимо создать переменную содержащую данные пользователя, то
// // a = 'ivanov'; - плохой пример, название переменной не отражает сути переменной
// // Транслитерации
// // Polzovatel = 'ivanov'; - плохой пример, название переменной может смутить иностранных программистов

// // Имена должны быть:
// // 1 Максимально короткими
// // 2 Максимально понятными

// // Например для покупателя хорошим примером будет:
// // customer
// // Если нужно будет указать более конкретно, например имя покупателя, то
// // customerName = 'ivan';
// // Либо
// // customer_Name = 'ivan';

// // Через дефис не писать!

// // Можно писать вот так:

// // $customer_name

// // Либо

// // _customerName

// // Для того чтобы вычислить что-то локально и пойти дальше подойдут

// // temp temp1 etc

// // В таком случае можно оставить комментарий temp - временная переменная
// // Комментарии принято оставлять на английском языке

// // Ширина прямоугольника

// // rectWidth rectangularWidth rect_width rect_w

// // Узнавать в каком стиле принято писать в кампании и использовать этот стиль

// // ________________________________________№3 Типы переменных_________________________________________________

// // Если я хочу вывести в консоль результат каких-либо операций, то */
// // console.log(4/6); //  в консоли увидим 0.(6)
// // /* Однако работать с переменными удобнее, так как изменив значение переменной не нужно будет менять
// // каждое число отдельно, что ускоряет работу.
// // */
// // // var x;
// // // x = 5 + 7;       не рекомендуется к использованию
// // // console.log(x);  в консоли увидим 12

// // // ------------------------------Объявление переменной и присваивание значения (var)
// // /* Переменную перед её использованием нужно объявить! (инициализировать)
// // Для этого в JS ввели такое понятие как "инициализация переменной"

// // Инициализация переменной - это команда которая объявляет переменную (а создай здесь вот эту переменную)
// // Пример:
// // var = x; - значит начиная с 281-й строки я хочу использовать переменную x и дальше я могу с ней работать

// // var x;             объявляю переменную х
// // x = 5 + 7;         внутрь х кладу какое-либо значение
// // console.log(x);    Когда обращаюсь к х я обращаюсь к этому значению - x = 5 + 7; в консоли увидим 12
// // */
// // // Добавим еще одну переменную y
// // // если теперь вместо 7 поставить y то вместо 7 подставится 3, а в консоль выведется результат 5 + 3
// // // var x;
// // // var y;
// // // y = 3;
// // // x = 5 + y;
// // // console.log(x);  в консоли видим 8

// // // в качестве значения переменной может быть не только число но еще и строка
// // x = 'Hello'; // - т.о. перезаписал значение переменной (обновил) что можно только с let и var
// // // то есть до 297 строки х был равен 8, но на 297 строке я выкинул это значение 8
// // // и записал в х значение Hello
// // // то есть переменная - как ящик, в неё можно что-то положить, а что-то выкинуть и положить что-то ещё
// // // иногда мы можем достать переменную произвести манипуляцию и положить обратно
// // console.log(x); // в консоли видим(вкв) Hello
// // // так же внутри переменной может быть true или false
// // // обновим значение переменной ещё раз
// // x = 6; // все предыдущие манипуляции с x выполняются но на 306 строке они полностью игнорируются
// // // из x выкидывается всё и кладётся новое значение 6
// // console.log(x); // вкв 6
// // // обновим значение переменной ещё раз
// // x = x + 4;
// // // выражение выше значит: всегда сначала вычисляется та часть которая находится справа от =
// // // до строки 310 x был равен 6 поэтому будет производиться вычисление
// // // 6 + 4 = 10 и эта 10 кладётся внутрь x
// // console.log(x); // вкв 10
// // // запись x = x + 4; эквивалентна записи x += 4;
// // x += 4;
// // console.log(x); // вкв - 14 потому что на строке 310 x был равен 10, 10 + 4 = 14

// // // в ES5 можно было выполнять такой манёвр даже после всего выше
// // var x; // объявляю новую переменную x взамен той х которая была
// // // это значило что с 10 строки x полностью становилась новой переменной
// // // при этом все предыдущие вычисления так же производятся
// // console.log(x);
// // // но так как этой переменной не присвоено никакое значение то вкв - undefined
// // // если я положу что-то в х то он будет равен этому значению, пример
// // x = 7;
// // console.log(x); // вкв 7
// // /* Запись var x;
// //        x = 7;  эквивалентна записи (Э) до var x = 7;
// // В старом стандарте ES5 мы могли создавать заново одну и ту же переменную сколько угодно раз
// // то есть запись
// // var x = 7;
// // var x = 8; с точки зрения ES5 - корректна вкв 8

// // -------------------------------Всплытие переменной (hoisting)

// // Более того имело место "всплытие переменной" hoisting
// // то есть можно было объявить переменную внизу а начать пользовать ей вверху
// // в результате чего переменная воспринимала операции выше и производила все указанные с ней манипуляции
// // Грубо говоря, программа находила строку var x; и переносился её вверх, то есть первоначальная запись

// // x = 6;
// // x = x + 4;
// // x += 4;
// // var x;
// // console.log(x);

// // JS-ом читалась как

// // var x;
// // x = 6;
// // x = x + 4;
// // x += 4;
// // console.log(x);

// // И в итоге обе записи в консоли имели бы одинаковое значение

// // Поэтому подход к переменной в ES6 был реорганизован

// // ------------------------------ Типы переменных let и const (отличия)

// // 1 в ES6 - отказались от ключевого слова var для того чтобы обозначить новые переменные
// // 2 в ES6 - переменную объявляют (инициализируют) сокращением let
// // let имеет похожие свойства с var за некоторыми исключениями */
// // // let y;
// // // y = 12;
// // // console.log(y);  вкв 12
// // /*
// // Если мы продублируем это действие, то
// // let y;
// // y = 12;
// // console.log(y);
// // let y;
// // y = 13;
// // console.log(y); вкв - ошибка y - has already been declared

// // то есть с let - объявить переменную дважды уже не получится это вызывает ошибку

// // Отличие let от var и const

// // let от var отличается тем что при let переменную нельзя объявлять дважды
// // во вторых такое явление как "всплытие переменной" hoisting с let - вызывает ошибку
// // вкв is not defined
// // поэтому нельзя использовать переменную d ES6 не объявляя её
// // все остальные операции манипуляции можно производить как и с предыдущим var
// // (насколько знаю есть еще одно отличие в разнице действия области видимости переменной с var и let
// // у переменных объявленных с помощью var область видимости ограничена функцией
// // а у переменных объявленных с помощью let - блоком)
// // let = y;
// // y = 13; э let y = 13;

// // Таким образом переменные объявляемые с помощью let должны быть объявлены в начале программы
// // в начале функции в начале цикла или if

// // второе серьёзное отличие let от var - область видимости */
// // // var y = 5;
// // // console.log(y);  вкв 5
// // //  добавим условный оператор
// // // if (1) {  если единица это правда всегда то будет выполняться console.log(y);
// // //     console.log(y); /вкв - 5
// // // }

// // /*То есть в ES5 переменная var y была видна в глобальной области видимости (вне блоков)
// // и была доступна везде либо если мы ее объявили так же внутри функции var y = 5; она была видна везде
// // внутри функции(не блока)
// // Другой пример */
// // var y = 5;
// //  // добавим условный оператор
// // if (1) {  // если единица это правда всегда то будет выполняться console.log(y);
// //     var y = 7;
// //     console.log(y); // вкв - 7
// // }
// // console.log(y); // вкв - 7

// // /* То есть если переменная объявлена с помощью var то она будет видна как в блоке так и вне его пределов
// // и выполнятся будет по стандартному свойству наследования, какое значение ниже в коде, то и является
// // последним если из --

// // var y = 5;
// // if (1) {
// //     var y = 7;   -- убрать ключевое слово var, и останется только y = 7; резльтат будет такой же
// //     console.log(y); вкв - 7
// // }
// // console.log(y); вкв - 7

// // ---------------------------------- Замыкание 77

// // Если тоже самое написать с let */
// // let z = 5;
// // if (1) {
// //     let z = 7; // но если здесь убрать let смотри ниже 77 (замыкание)
// //     console.log(z); // вкв 7
// // }
// // console.log(z); // вкв 5

// // /* то есть let имеет область видимости ограниченную блоком и такая переменная не существует
// // вне блока внутри которого она объявлена

// // 77 (Замыкание) - в этом случае оба console.log(z); выдадут 7

// // Если внутри блока js не находит объявление переменной z и
// // после этого выходит за пределы блока и ищет объявление переменной z с помощью ключевого слова вне блока,
// // если находит let z = 5; то js перезаписывает значение которое было в коде ниже,
// // то есть z = 7; в let z = 7; и т.о. в обоих console.log(z); мы видим 7 если переменная
// // не была объявлена внутри блока с помощью ключевого слова let, - это и есть замыкание

// // ---------------------------------- Далее опять раздел отличия let var const

// // а если переменная была объявлена внутри блока с помощью ключевого слова let,
// // то оба console.log действуют в пределах своих областей видимости
// // первый в пределах своего блока
// // второй в пределах глобальной области видимости

// // если вместо z = 7; внутри блока указать var z = 7; вкв has already been declared
// // потому что область видимости var выйдет за пределы этого блока и встретится там с
// // let z = 5;
// // Поэтому если убрать какое-либо ключевое слово, то ошибки не будет и будет 2 значения 7
// // Если подставить var то будет ошибка в связи со столкновением областей переменных
// // А если и там и там подставить let то первый лог загрузит 7 а второй 5
// // таким образом каждая область видимости будет действовать в своих пределах

// // Область видимости let - блок любой степени вложенности
// // Область видимости var - функция(не блок)

// // Если объявить переменную let вне блоков она будет считаться глобальной переменной и будет видна
// // вне любых блоков, если объявить переменную let внутри блока она будет видна только внутри этого блока
// // и всем, вложнным внутрь этого блока, блокам.

// // Итак главное отличие let от var в том что области видимости let z = 7; заключены внутри блока
// // в котором данный let z = 7; - объявлен, если let z = 7; не объявлен с помощью let.
// // а просто указано z = 7; то внутри блока js не находит объявление переменной z и
// // после этого выходит за пределы блока и ищет объявление переменной z с помощью ключевого слова вне блока
// // если находит let z = 5; то js перезаписывает значение которое было в коде ниже, то есть z = 7;
// // в let z = 7; и таком образом в обоих console.log(z); мы видим 7 если переменная не была объявлена
// // внутри блока с помощью ключевого слова let, а если переменная была объявлена внутри блока с помощью
// // ключевого слова let, то оба console.log действуют в пределах своих областей видимости
// // первый в пределах своего блока
// // второй в пределах глобальной области видимости

// // Так же внутри ES6 стали использовать новый тип переменной - константу const

// // Константа const - это тип переменной при котором переменная не изменяет своего значения. */

// // const a = 9;
// // // a = 88; после const a = 9; - запрещено (в отличие от let)
// // //     при константе переменная не изменяет своего значения
// // //     такая попытка в консоли выведет Assignment to constant variable at такой то строке
// // // a = a + 5; или a += 5; после const a = 9;
// // //     вызовет ту же ошибку в консоли Assignment to constant variable at такой то строке
// // // const a = 10; после const a = 9;
// // //     так же вызовет ошибку indentifier 'a' has already been declared
// // console.log(a); // вкв 9
// // // но мы можем использовать значение переменной объявленной с помощью const с другими переменными
// // // пример
// // let n = 3 + a;
// // console.log(n); // вкв - 12

// // // Часто константы объявляют большой буквой const A = 7;
// // const A = 10;
// // /*Константа const не меняет своего значения, но const может изменять свойства
// // Если у вас есть массив или объект вы можете менять его свойства,
// // хотя массив и объект может оставаться константой */

// // // var - не используем, но понимаем как работает.

// // //____________________________________№4 Undefined & Undeclared_________________________________________
// // /*
// // Не объявленная & не идентифицированная переменная*/
// // let u = 5;
// // let p = 7;
// // console.log(u*p); // вкв 35
// // // Если мы введём переменную t которой у нас нет, то
// // // console.log(u*p*t); // вкв t is not defined э undeclared
// // // t не определено поскольку система не могла найти переменную с таким идентификатором
// // // комментируем консоль лог выше и объявляем переменную t
// // let t; // но не присваиваем ей значение
// // // в этом случае
// // console.log(u*p*t); // вкв NaN (Not a Number)
// // /*То есть попытка обратиться к переменной которая была объявлена, но ей не присвоено значение,
// // привела к тому что в консоли появилось значение Not a Number
// // u есть p есть t не определено, умножение на неопределённость дало NaN

// // Если напищем в консоль лог просто вывести t*/
// // console.log(t); // вкв undefined посколько в переменную t не положено значение
// // /*Если let t; законментировать и после этого вызвать console.log(t);
// // консоль покажет t is not defined э undeclared
// // То есть ошибки происходят в принципе по логике одинаковые, но вызывают разные варианты ошибок
// // Выводы
// // Если видим is not defined значит - переменная не была объявлена
// // Но если мы её (переменную) объявили (let = t;)
// // Но не присвоили ей значение то она по умолчанию равна undefined

// // Undefined - переменная в которую ничего не положили (пустая коробка)
// // is not defined - переменная не объявлена

// // Если перед t убрать ключевое слово let, то в консоли увидим is not defined
// // то есть мы получаем ту же самую ошибку когда переменная не была объявлена

// // ----------------------Use strict
// // Строка "use strict" ставится в начале скрипта, она необходимо для того чтобы сказать браузеру
// // что мы жестко придерживаемся стандарта ECMA SCRIPT 6 и мы будем работать конкретно в нём
// // потому что современные стандарты позволяют идентифицировать такие вещи как необъявленные переменные
// // с меньшими потерями. всё что делали в предыдущем разделе итак было по use strict, но если использовать
// // use strict с var, то всё будет точно так же :)
// // Если мы перед объявлением всех переменных добавим use strict то*/
// // "use strict"
// // var r = 2;
// // var f = 1;
// // var q;
// // console.log(q); // undefined просто q - is not defined,
// // // is not defined э undeclared

// // //___________________________________№5 Hoisting (всплытие, поднятие переменной)__________________________________
// // /*Если мы выведем не существующую переменную в лог, то получим undefined,
// // Если мы выведем в лог переменную которая будет только объявлена, то получим is not defined

// // А если мы сначала вызовем ранее не объявленную переменную в лог, а потом её объявим
// // то в консоли увидим undefined, пример: */
// // //            ---|
// // console.log(L);//|
// // var L; // ---|       лог undefined такой же если бы var L; было бы выше console.log(L);

// // /*Данное явление и называется Hoisting или всплытие, поднятие переменной

// // Когда JS разбирает код и в каком-то блоке находит команды для работы с переменными типа
// // console.log(L); JS продолжает смотреть есть ли переменные в данном блоке (в том числе и ниже лога)
// // если переменные есть, то фактически происходит следующее
// // JS находит лог затем начинает искать объявление переменной и когда находит это объявление ниже в коде
// // начинает его поднимать выше лога в результате:

// // console.log(L);            var L;
// //         var L;      э      console.log(L);

// // Hoisting - процесс в работе JS при котором, переносится
// // именно объявленная переменная вверх логического блока

// // Минус Hoisting
// // Если используем значение которое мы вообще не использовали ранее
// // в этом случае переменная вместо того чтобы выдать ошибку is not declared (undeclared)
// // выдаст ошибку undefined и программист будет думать что напутал с вычислениями ранее,
// // но используется переменную которой ещё нет в принципе потому что где-то ниже
// // переменная где-то была объявлена и использована.

// // поэтому сначала переменная объявляется и только потом с ней производятся какие-либо действия

// // Если мы присвоим L значение 5
// // */
// // console.log(L);
// // var L = 5; // лог undefined процесс всплытия hoisting поднятия переменной
// // // относится только лишь к объявлению переменной
// // //  и в этом случае наверх JS поднял только var L; а дальнейшую часть не прочёл
// // // поскольку она нарушает логику программы

// // // Если
// // //                                          ES5
// // console.log(b);
// // var b = 7;
// // console.log(b);
// // b = 5;
// // console.log(b); // лог undefined 7 5

// // // в первом логе переменная хотя и была не объявлена из-за всплытия объявилась
// // // но ей значение не присвоилось и она равна undefined в логе
// // // во втором логе мы присвоили значение переменной 7 и b стала равна 7
// // // и в третьем логе присвоили значение переменной 5 и она стала равна 5

// // // то есть всплытие работает только лишь на объявление переменных (var b)
// // // всплытие работает внутри блока, если вы внутри функции объявляете переменные
// // // они всплывут к началу функции, но присвоится значение им уже позже когда
// // // вы явно его присвоите b = 5;
// // // код выше относится к ES5

// // //                                          ES6

// // // let m = 99;
// // // console.log(m); // лог покажет 99
// // // теперь если мы укажем let m = 99; ниже console.log(m); то
// // // let m = 99; в логе будет is not defined
// // // то есть всплытие в ES6 сразу вызывает ошибку
// // // то есть в ES6 всплытие переменной не происходит это приводит к ошибке
// // /* в ES6 попытка применить всплытие в ECMASCRIPT 6 приводит к ошибке
// // в ES6 объявление переменных и соответственно заполнение происходит в том месте
// // где вы его сделали всплытие не происходит, то есть этот факт
// // исключает ошибку
// // когда после того как переменную мы используем а она undefined мы не можем сказать в ES5
// // мы ее где-то не правильно вычислили не присвоили значение или мы её не объявили
// // в эта ошибка была убрана поэтому
// // Где объявили после этого и используйте */

// // //___________________________№6 Типы данных в JS Variables and Types_____________________________________________
// // /* в ES6 Типов данных ещё нет но в Angular 2 они есть
// //    в любом случае при выполнении операций JS присваивает переменной определённый тип
// //    и в зависимости от типа результат операции может значительно отличаться

// // -----------------------------Основные типы данных в JS
// // 1 Число, числовой тип
// // */
// // let aa = 8;
// // console.log(aa);
// // // Для того чтобы узнать тип данных существует специальная функция typeof
// // console.log(typeof aa); // лог number
// // let bb = 8.3;
// // console.log(typeof bb); // лог number
// // // Если заменить 8.3 на 8,3 то
// // // let bbb = 8,3;
// // // console.log(typeof bbb); // лог unexpected number
// // // потому что дроби в js пишутся через точку
// // // итак не важно дробь это или число тип данных всё равно number
// // // 8 - целое число
// // // 8.3 - число с плаващющей запятой (а почему с запятой если в js дроби с точкой)

// // // Следующий тип данных это строка
// // let cc = 'Helloy'; // так как это строка её нужно взять в кавычки
// // console.log(typeof cc); // лог string

// // let d;
// // let e;
// // console.log(typeof d*e); // Лог NaN not a number
// // // NaN выводится когда одному из элементов выражения не присвоено значение
// // // NaN не является типом данных, это просто результат выполнения арифметической операции
// // // к элементам которые не являются числами

// // // Если
// // console.log(typeof d); // лог undefined
// // // можно спорить является ли d типом данных или нет, но можно сказать что это специальное значение
// // // Специальный результат JS в том случае когда переменную мы объявили но не присвоили ей значение

// // // Ещё один тип данных - null
// // // Если я попытаюсь сослаться на пустой объект я должен взять указатель на этот объект
// // // Если указателя нет - мы получим null

// // let ff = true; // boolean значение принимает всего два вида true / false
// // console.log(typeof ff); // лог boolean
// // // если убрать в команде console.log(typeof ff); typeof то
// // console.log(ff); // лог true
// // // если мы обновим переменную на false то
// // ff = false;
// // console.log(ff); // лог false, при этом тип данных не изменится и останется boolean
// // // изменится только значение с true на false

// // // Есть такое явление как массивы
// // let g = [2, 3, 4];
// // // Если мы попытаемся вывести тип данных массива, то
// // console.log(typeof g); // лог object
// // // то есть все массивы в js это - объект,
// // // соответственно над ним можно выполнять операции как над объектом

// // //________________________________№7 Базовые операции JS____________________________________________

// // //                        Базовые операции над типами данных в JS

// // // Допустим у нас есть несколько переменных
// // let aaaa = 5;
// // let bbbb = 2;
// // // выведем в консоль результаты операций

// // // Сложение aaaa + bbbb
// // console.log(aaaa + bbbb); // лог 7
// // // в JS знак + используется как для сложения двух чисел так и для сложения двух строк (конкатенации)

// // // Вычитание aaaa - bbbb
// // console.log(aaaa - bbbb); // лог 3

// // // Умножение aaaa * bbbb
// // console.log(aaaa * bbbb); // лог 10

// // // Деление aaaa / bbbb
// // console.log(aaaa / bbbb); // Лог 2.5

// // // Остаток от деления remainder
// // console.log(aaaa % bbbb); // Лог 1
// // // То есть сколько раз можно использовать двойку внутри пятёрки
// // // 2 * 2 = 4; 5 - 4 = 1; 1 - remainder

// // /* Операнд – то, к чему применяется оператор.
// // Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2.
// // Иногда их называют «аргументами» вместо «операндов».

// // Знаки между 5 и 2 называются операторами ( + - * / )*/

// // // Если
// // console.log(aaaa > bbbb); // то Лог True
// // // данный оператора называется оператором сравнения
// // // он возвращает true если операция верна (а куда возвращает?)
// // // операторы сравнения могут быть > <
// // console.log(aaaa < bbbb); // Лог false
// // // может быть >=
// // console.log(aaaa >= bbbb); // Лог true
// // // <=
// // console.log(aaaa <= bbbb); // Лог false

// // // в некоторых случаях нам нужно узнать Не равно, пишется !=
// // console.log(aaaa != bbbb); // Лог true

// // // проверка на равенство, а равно ли ==
// // console.log(aaaa == bbbb); // Лог false

// // // Итого проверка на равенство == проверка на неравенство !=
// // // Больше равно >= Меньше равно <=
// // // Один знак равно = означает Присваивание

// // // Со строками
// // let ccc = 'Helloy';
// // // что будет если умножить Helloy на aaaa
// // console.log(ccc*aaaa); // Лог NaN not a number
// // // То есть попытка умножить строку на число приведет к значению Not a number
// // // Потому что число и строка не могут быть умножены друг на друга

// // // Если поделим
// // console.log(ccc/aaaa); // Лог NaN

// // // Если вычтем
// // console.log(ccc-aaaa); // Лог NaN

// // // Так происходит потому что над строками не предполагается математических операций
// // // умножение деление вычитание, но над строками разрешена операция сложения
// // // Данная операция сложения применительно к строкам называется конкатенация

// // // Если сложим
// // console.log(ccc+aaaa); // Лог Helloy5
// // // Если поменяем местами слагаемые
// // console.log(aaaa+ccc); // Лог 5Helloy

// // // Если есть строка которая визуально выглядит как число
// // let dd = '8';
// // // Если выполним операцию сложение, то
// // console.log(dd+aaaa); // Лог 58 но в результате мы получаем не число 58 итоговый тип 58 - string
// // // при добавлении в команду атрибута typeof 5 - number 8 - 8
// // /* off course
// // console.log(typeof dd + aaaa); сработает как
// // console.log((typeof dd) + aaaa);
// // Если я хочу узнать тип итоговой операции после dd + aaaa то
// // console.log(typeof (dd + aaaa);*/
// // console.log(typeof (dd + aaaa)); // Лог string

// // /* чтобы такого не происходило нужно при сложении научиться перегонять
// // вот такого вида строки '8' в числа
// // затем чтобы когда мы вычитываем число из элемента input в html(поле ввода)
// // То Js получит доступ к этому элементу в виде строки
// // то есть если в поле ввода в html ввести 7, то 7 придёт ввиде строки
// // и это проблема так как мы не можем строки складывать чтобы в итоге получить число

// // ---------------------------Преобразование строк в числа Prompt(Незамедлительный)

// // Учимся получать числа в простом виде на практике не используем, но понимаем

// // Метод Prompt - выводит окно с кнопками ок и cancel, если нажать cancel всё закрывается и
// // ничего не происходит, если я нажимаю ок, то возвращается то что я ввёл внутри данного окна*/
// // //  let ee = prompt ('Enter a number', '');
// // //  console.log(ee); // лог всплывающее поле ввода с кнопками ок и отмена,
// // // где заголовок поля Enter a number, а пустое значение '' - поле ввода
// // // вводим 9 нажимаем ок, тогда в логе вижу 9
// // // то есть мы с помощью prompt организовали ввод чисел
// // // Если получить тип переменной ee, то
// // //  console.log(typeof ee); // лог string
// // // то есть введя в поле ввода число на выходе я получаю тип данных строка
// // // и теперь если понадобится вывести результат
// // // console.log(ee + 24); // лог если в этот момент во всплывающее поле ввода ввести 5, то
// // // в логе мы получим 524 а не 29 и соотв. тип данных у 524 будет string
// // // JS возвращает из всех подобных окон как input prompt etc - тип данных строка
// // // а для строк знак + обозначает конкатенацию которая и происходит

// // // поэтому всегда когда мы получаем что-либо из элемента ввода мы обязаны
// // // преобразовать эти данные в соответствующий тип например число
// // // некоторые операции производят это автоматически, если поставить / или умножить
// // // а со строками таких операций в принципе нет то
// // // console.log(ee * 24); // лог 72, (в поле вводил 3)
// // // то есть значение 3 из поля ввода правильно было умножено на 24,
// // // так же будет и с делением если вписать в поле ввода 48 в логе будет 2
// // // так же будет и с вычитанием если вписать в поле воода 25 в логе будет 1

// // // но если попытаться сделать то же самое со сложением то будет включаться механизм конкатенации

// // // -------------- Как преобразовать тип данных строка в число при конкатенации или сложении
// // /* Вариант 1 вводим +ee и проверяем*/
// // // console.log(ee + 24);
// // // +ee; // лог 324 при вводе 3, то есть всё равно остался тип данных - строка
// // // потому что результат был слеплен, попробуем написать +ee в операции
// // // console.log(+ee + 24); //лог 27 при вводе 3, РАБОТАЕТ!
// // // ПРИМЕЧАНИЕ этот метод работает и с 3.5 в отличие от parseInt
// // // но этот метод на работает если ввести в поле 3.5a в этом случае лог - NaN
// // // а в parseFloat - 27.5
// // // Итак 1 вариант преобразовать строку из поля ввода в число это написать в операции +varibale
// // // то есть поставить + перед той переменной которая выводит значение которое вводится в поле ввода
// // // это не всегда удобно поэтому существуют другие способы:

// // // Способ №2 Чётко преобразовать строку к числу, для этого сущ-ет след-щая операция
// // // parseInt(ee)
// // // console.log(parseInt(ee) + 24); // лог 25 при вводе 1 РАБОТАЕТ!
// // // parseInt это специальная конструкция, специальная функция которая получает
// // // переменную ввиде строки и пытается её преобразовать в число
// // // в отличие от первого способа(прибавления +) parseInt будет работать даже на сложных числах т.е.
// // // 4а будет преобразовано к 4, 45ds будет преобразовано к 45
// // // но а2 уже не будет преобразовано и выведет соответственно Not a Number
// // // проверим введя в поле 3a лог 27 3-ку смогло считать

// // // проблема в том что parseInt не сможет считать 3.5, проверим
// // // в логе видим 27 то есть JS дочитал до 3 а .5 отбросил
// // // потому что . тоже считается строкой и значение отбрасывается

// // // Способ №3 Если необходимо преобразовать десятичное число то существует оператор parseFLoat
// // // который позволяет считывать дроби
// // // console.log(parseFloat(ee) + 24); // лог 27.6 РАБОТАЕТ и при десятичном числе и одновременно
// // // при 3.6a лог так же будет 27.6

// // // как же понять что ввёл пользователь какой именно тип данных
// // // для этого в JS существует конструкция isNaN
// // // console.log( isNaN(3)); // лог true
// // // NaN это Not a number не число
// // // is значит если hello не число то вывести в консоль true
// // // то есть если мы введём в команду число то в логе увидим false независимо от того что введем в поле
// // // то есть isNaN это функция которая проверяет что введенное значение не является числом
// // // тогда она даёт true

// // //_________________________________№8 Условные операторы____________________________________________

// // /*Операторы ветвления в JS
// // Операторы ветвления нужны если необходимо выполнить какое- либо действие по определенному условию
// // Существуют два основных направления операторов ветвления

// // Первый оператор - if */
// // // let zz = 1; // если zz будет равно 9 я хочу выводить допустим всплывающее окнок alert
// // // // с каким-либо текстом, если нет - не выводить
// // // // оператор if имеет вид
// // // /* if (условие верно) то тогда выполнять действие заключённое в фигурных скобках {
// // //     таких действий может быть несколько, если действие одно можно обойтись без фигурных {}
// // // }

// // // Пример ниже:
// // // --------I if Работает простро реагированием на какое-то значение либо не реагируем вообще
// // // Если а, если я хочу проверить на равенство я должен поставить == (а равно ли?)
// // // if (a == 9) {}; - если переменная а равна 9, то {действие}*/
// // // if (zz == 9) {
// // //     alert('Yes'); // лог вижу всплывающее окно yes //// когда только одно действие можно писть не через {}
// // // }
// // // если поменяем zz = 1 то alert не выскочит, то есть if работает как переключатель
// // // а именно если условие верно мы выполняем то что в скобочках
// // // оператор if позволяет просто проверить условие и либо выполнить действие либо
// // // не делать ничего
// // // будут встречаться два варианта событий,
// // // Если условие верно и если условие не верно, то есть как реагировать на поступившие условия
// // // Для этого существует следующий синтаксис
// // // if (условие верно) то тогда выполнять действие заключённое в фигурных скобках {
// // //    таких действий может быть несколько, если действие одно можно обойтись без фигурных {}
// // // }

// // /*------II if else обязательно реагирует либо одним либо другим
// // Но если наша задача представляет из себя развилку (вилку) где в любом случае должно
// // что- то сработать пишется оператор else и далее просто пишется действие {действия}
// // которые будут выполнены если условия не верны*/
// // // let xx = 5;
// // // // если xx = 5 то alert ('xx = 5');
// // // if (xx == 5) {
// // //     alert ('xx = 5');  // когда только одно действие можно писть не через {}
// // // }
// // // // в противном случае else выведи окно алерт b не равно 5
// // // else {
// // //     alert ('xx != 5'); // когда только одно действие можно писть не через {}
// // // }
// // /* Программа работает сл образом
// // Присваиваем переменной xx значение 5
// // Если условие xx = 5 верно, то будет выполняться действие alert ('xx = 5');
// // то есть будет выполняться только часть программы if а else выполняться не будет
// // Если условие xx = 5 не верно, то будет выполняться действие alert ('xx != 5');
// // то есть будет выполняться только часть программы else а if выполняться не будет

// // Таким образом если задача поддаётся решению (в виде развилки) либо то либо то жёстко задано
// // Когда мы пишем оператор if else в любом случае какой-то из них будет выполнено третьего не дано

// // -------III Сравнение двух чисел

// // Два числа могут быть
// // 1-е > 2- го
// // 2-e > 1-го
// // 1-e === 2-му     */
// // // let vv = 4;
// // // let nn = 4;
// // /* в завивимости от того какое число больше либо меньше либо равно я должен отреагировать
// // для этого существует расширенный список if else
// // Так как одно действие пишем в одну строчку без {} но если несколько команд то {} обязательны */
// // // if (vv>nn) alert('vv больше'); else alert('nn больше');
// // /* если после этого написать else (в противном случае, то есть в любом если условие не выполнилось)
// // в данном примере условие не совсем верно сформулировано, если написать значение переменной vv = 4
// // то выполнится часть программы после else потому что else выполняется в любом случае
// // из этого нужно выходить более расширенным синтаксисом if else если задача предусматривает вилку не
// // двух путей а 3-х 4-х 8-ми мы можем воспользоваться синтаксисом else if который позволяет
// // описать значительно больше условий в одном блоке

// // if (vv>nn) то else if(nn>vv) alert('nn больше'); и третий вариант  else alert('числа равны') */
// // // if (vv>nn) alert('vv больше'); else if (nn>vv) alert('nn больше'); else alert('числа равны');
// // /* РАБОТАЕТ!!!
// // else if может быть несколько
// // if (vv>nn) alert('vv больше');
// // else if (nn>vv) alert('nn больше');
// // else if (nn>vv) alert('nn больше');
// // else if (nn>vv) alert('nn больше');
// // else if (nn>vv) alert('nn больше');
// // else alert('числа равны');

// // Если мы дошли до этого условия соответственно осуществляем выход из оператора else if
// // Когда мы пишем этот оператор в любов случае что-то из этого блока
// // if else if else - обязательно сработает

// // ЕСЛИ ЕСТЬ ELSE ЗНАЧИТ ЧТО-ТО ОБЯЗАТЕЛЬНО СРАБОТАЕТ
// // Даже если все предыдущие условия не верны выполнится последний else
// // Но можно обходиться и без последнего else в этом случае если ни одно из условий не будет
// // выполнено в конце просто ничего не сработает, и это не критично поскольку ничего делаться не будет

// // -------- IV Тернарный оператор

// // Тернарный оператор это упрощённая конструкция if else
// // Тернарный оператор позволяет нам записать код ниже в другом виде

// // let xx = 5;

// // if (xx == 5) {
// //         alert ('xx = 5');
// // }
// // else {
// //         alert ('xx != 5');
// // }

// // Пусть у нас будет такая конструкция мне нужно проверить какое-либо условие
// // Если оно верно выполнить его, если оно не верно выполнить что-то другое*/
// // // let xx = 15;
// // // // условие ? то yes     : else no    ;
// // // xx == 15 ? alert('yes') : alert('no');
// // // условие? команда при положительном результате выполнения условия : к п отриц вып условия ;
// // /*Только в том случае если внутри if всего лишь одна команда или одно действие (либо то либо это)
// // и есть конструкция if else то мы можем воспользоваться тернарным оператором

// // условие в тернарном операторе берется в скобки затем знак вопроса
// // всё что до вопроса считается условием, часть до двоеточего выполнится если условие верно
// // после двоеточего если условие ошибочно

// // Ограничение использования тернарного оператора, тернарный оператор ограничен в одном случае, в том
// // если у вас несколько команд то внутрь тернарного оператора их не поместить это будет не работающая
// // конструкция */

// // // Задача 1

// // // Пользователь вводит два числа, найти и вывести максимальное из двух чисел.

// // // let rr = 4;
// // // let tt = 4;

// // // if (rr>tt) {
// // //     console.log(rr);
// // // }
// // // else if (tt>rr) {
// // //     console.log(tt);
// // // }
// // // else {
// // //     console.log('числа равны');
// // // }

// // // // Задача 2

// // // // В первом подъезде квартиры с 1 по 20
// // // // во втором                 с 21 по 48
// // // // в третьем                с  49 по 90
// // // // пользователь вводит номер квартиры.
// // // // программа должна указать в каком подъезде находится данная квартира
// // // // программа должна учитывать вариант ввода чисел за пределами диапазона 1 - 90

// // // let apartNumber = prompt ('Enter an apartNumber', '');

// // // if (apartNumber < 21) {
// // //     console.log('1 подъезд');
// // // }
// // // else if (apartNumber>21 && apartNumber<48) {
// // //     console.log('2 подъезд');
// // // }
// // // else if (apartNumber>49 && apartNumber<90) {
// // //     console.log('3 подъезд');
// // // }
// // // else {
// // //     console.log('Не существующий номер квартиры');
// // // }

// // // РАБОТАЕТ!!!!!!!!!!!!!!!!!!!!!

// // // Задача 3

// // /* Пользователь вводил логин и пароль.
// // Если логин и пароль совпадают с указанными ниже,
// // то выводится "Добро пожаловать". Если не совпадают, то "Ошибка входа"

// // Данные для задачи:

// // логин    ivan     alex    petr
// // пароль   334455   777     b5678 */

// // let ivan = '334455';
// // let alex = '777';
// // let petr = 'b5678';

// // if (ivan == '334455') {
// //     console.log('Добро Пожаловать');
// // }
// // else {
// //     console.log('Ошибка входа');
// // }

// // if (alex == '777') {
// //     console.log('Добро Пожаловать');
// // }
// // else {
// //     console.log('Ошибка входа');
// // }

// // if (petr == 'b5678') {
// //     console.log('Добро Пожаловать');
// // }
// // else {
// //     console.log('Ошибка входа');
// // }

// // // РАБОТАЕТ!!!!!!!!!!!!!!!!!!!!!

// // // Задача 4

// // /* Пользователь вводит год рождения. Программа показывает количество лет и если лет больше
// // или равно 16, то пишет - "добро пожаловать", если нет "вход воспрещён"*/

// // // let yearOfBirth = prompt ('Enter an yearOfBirth', '');
// // // console.log(2022-yearOfBirth);
// // // let sixteen = 2022-yearOfBirth;
// // // if (sixteen>=16) {
// // //     console.log('Добро пожаловать');
// // // }
// // // else {
// // //     console.log('Вход воспрещён');
// // // }

// // // РАБОТАЕТ!!!!!!!!!!!!!!!!!!!!!

// // //__________________________№9 Дебагер Javascript_______________________________________________________

// // let ha;
// // let hb = 9;
// // let hc;
// // hc = ha+hb;
// // if (hc = hb) {
// //     alert ('равно');
// // }
// // alert(hc);


// // /* В консоли вкладка Sources
// // там можем открыть текущий js файл и работать с ним

// // Программа представлена в виде строк, строки пронумерованы

// // Напротив строки которую я хочу посмотреть я могу поставить точку остановки Break point
// // он ставится кликом на строке, так же и убирается

// // Как только я поставил Break Point браузер будет при выполнении останавливаться
// // и ждать моих дальнейших указаний на счёт программы, то есть после запуска программы
// // при наличии break point программы выполнится только до Break point и остановится

// // Об этом сообщает Paused in debugger посередине экрана

// // При наведении на переменную если она довольно сложная мы можем получить
// // если нам это необходимо, подсказку о том, что эта переменная содержит*/


// // let v = 9;
// // let III = 10;
// // let rec = 10;

// // // отработал, метод фиксирования печатанием считаю не эффективным, нужно делать через повторение


// //_____________________________________________Цикл For while_________________________________________________________

// // let out = document.getElementById('out');
// // let temp = '';

// // цикл с заданным количеством повторений, самый быстрый цикл JS - for

// // for (start;/* условие; затем условие работы, работаем пока условие верно*/ if-true; /* шаг изменения*/ step ){
// //     /*Здесь пишем что мы будем повторять */

// // }
// // /*до тех пор пока i<15 цикл будет работать, дальше указываем как будет изменяться i, i будет изменяться с шагом 1*/
// // for (let i = 0; i<20; i = i + 1 ) {
// //     if (i == 5) continue; // continue прерывает не весь цикл а его текущий круг
// //     console.log(i);
// // }

// /*до тех пор пока i<15 цикл будет работать, дальше указываем как будет изменяться i, i будет изменяться с шагом 1*/
// // for (let i = 0; i<20; i = i + 1 ) {
// //     console.log(i);
// //     if (i == 5) break; // break - прерывает цикл, то есть как только она выполняется цикл останавливается и мы из него выходим
// // }

// // мы можем убрать start и поставить его перед циклом
// // let i = 0
// // for (; i<20; i = i + 1) {
// //     console.log(i);
// // } // в логе от 1 до 19-и

// // можем вынести и step результат будет тем же

// // let i = 0
// // for (; i<20;) {
// //     console.log(i);
// //     i = i + 1;
// // }

// // while (// условие) { // если условие верно нас пускают в цикл

// // }
// // let i = 0;
// // while (i < 8) {
// //     i++;
// //     console.log(i);
// // }

// //__________________________________________# 11 Массивы Javasrcipt_________________________________________________
// //
// // let a = [];
// // let b = [12, 13, 66, 999];
// // console.log(b.length)
// //
// // let c = [3, 'Hello', true];
// // console.log(c)
// // c[2] = 999;
// // c[5] = 777;
// // delete c[5];
// // console.log(c)
// //
// // let out = document.getElementById('out');
// // let str = '';
// // for (let i = 0; i<c.length; i++) {
// //     if(c[i] !== undefined)
// //     str += i + ' - ' + c[i] + '<br>';
// // }
// // out.innerHTML = str;

// //____________________________________________# 12 Методы массивов_____________________________________________________
// //.push() добавляет элементы в конец массива
// // let a = [2,7];
// // a.push('hello')
// // a.push(65)
// // console.log(a)
// //
// // //.pop() позволяет удалить последний элемент массива
// // let b = a.pop();
// // a.shift();
// // a.unshift('world');
// // console.log(a);
// //
// // let f ="Hi, my, name, Ivan";
// // let d = f.split(',');//trim - позволяет избавиться от пробелов
// // let j = d.slice(1,3);
// // console.log(d);
// // console.log(d.join(''));
// // console.log(j);

// // let a = [92,7, 8, 33, 'hello'];
// // let [b, c] = a;
// // console.log(b,c)

// // let p = document.getElementsByTagName('p');
// // console.log(p);
// // for (let i = 0; i<p.length; i++) {
// //     p[i].style.color= 'red';
// // }
// //
// // let p1 = document.getElementsByClassName('ttt')
// // console.log(p1);
// //
// // let p2 = document.querySelectorAll('.ttt');
// // for (j=0; j<p2.length; j++){
// //     p2[j].onclick = function() {
// //         alert('work')
// //     }
// // }
// // console.log(p2);

// // let a = 30
// // let b = 30
// //  a > b ? console.log('a - больше'): b > a ? console.log('b - больше'): console.log('числа равны');

// // for (let i = 0; i < 20; i++ ) {
// //     if (i == 5) continue; // прерывает не весь цикл а только его итерацию
// //
// //     console.log(i)
// // }
// //
// // for (i=0; i<20; i++) {
// //     console.log(i)
// //     if (i == 5) break; // прерывает весь цикл
// // }
// // i = 0
// // while (i<8) { //условие если верно пускает в цикл) {}
// //     i++
// //     continue
// //     console.log(i)
// //
// // }

// // for (let i = 1; i <= 9; i++) {
// //     let b = i*7;
// //     console.log('7 * ' + i + ' = ' + b);
// // } // таблица умножения 7

// // let a = [];
// // let b = [13, 14, 56, 73];
// // console.log(b.length);
// // let c = [3, 'hello', true];
// // console.log(c);
// // c[1] = 896
// // console.log(c)
// // c[5] = 928
// // console.log(c);
// // delete c[5];
// // console.log(c);
// //
// // let t = document.getElementById('out')
// // let str = ''
// // for (let i = 0; i < c.length; i++) {
// //     if (c[i] !== undefined) {
// //         str = str + i + ' - ' + c[i] + '<br>'
// //     }
// // }
// // out.innerHTML = str;
// //
// // let y = [13, 35];
// // y.push('hello')
// // y.push(124);
// // console.log(y)
// // let r = y.pop()
// // console.log(r)
// //
// // y.shift()
// // console.log(y)
// // y.unshift('world')
// //
// // let as = 'My, name, is, ivan';
// // let sa = as.split(',');
// // console.log(sa); // => ['My', ' name', ' is', ' ivan']
// //
// // console.log(sa.join())
// //
// // let sj = sa.slice(1,3);
// // console.log(sj)
// //
// // let rty = [0, 1, 2, 3, 4, 5, 6, 7, 8]
// // let ax = rty.slice(4,8);
// // let [az, bz, zc] = ax
// // console.log(az, bz, zc);
// // let p = document.getElementsByTagName('p')
// // console.log(p);
// // for(i = 0; i<p.length; i++){
// //     p[i].style.color = 'red';
// // }
// //
// // let o = document.getElementsByClassName(('ttt'))
// //
// // for (let joj = 0; joj<o.length; joj++) {
// //     o[joj].onclick = function() {
// //         alert('хватит нажимать')
// //     }
// // }
// //
// //
// // let r = [-4, -3, -2, -1, 0, 1, 2, 3, 4]
// // let zero = 0;
// // for (let k = 0; k < r.length; k++) {
// //     zero = zero + r[k]
// // }
// // console.log(zero / r.length);
// // console.log(Math.max.apply(null, r))
// //______________________________________________________________Зашло_________________________________________________
// // let temp2 = [
// //         [3, 6, 3],
// //         [4, -5, 6],
// //         [7, 8, -9]
// // ];
// // console.log("-----")
// // for (let u = 0; u < temp2.length; u++) {
// //     Sred = 0;
// //     for (let jo = 0; jo < temp2[u].length; jo++) {
// //         Sred = Sred + temp2[u][jo];
// //     }
// //     console.log(Sred / temp2[u].length);
// //     console.log('t min'+Math.min.apply(null, temp2[u]))
// //     console.log('t max'+Math.max.apply(null, temp2[u]))
// // }
// //_____________________________________________Map________________________________________________________________
// // let ter = [10, 20, 30];
// // ter[5] = 40;
// // delete ter[5];
// // let newter = [];
// // for (let i = 0; i<ter.length; i++) {
// //     newter[i] = ter[i]*2;
// // }
// // console.log(ter);
// // console.log(newter);
// // console.log('_______________')
// // let c = ter.map(function(x, y,z){
// //     return x*2
// // })
// // console.log(c)
// // let a = [12, -5, 30, 56, -34, 78, -9]
// // let b = []
// //
// // for (i=0; i<a.length; i++) {
// //     if (a[i]>0) b.push(a[i])
// // }
// // console.log(a)
// // console.log(b)
// // let a = [12, -5, 30, 56, -34, 78, -9]

// // let b = a.filter(function (x,y){
// //     return x%2===1;
// // })
// // console.log(b);


// //     for (let i = 1; i <= 10; i++) {
// //          let b = i*5;
// //          console.log(i + ' * 5' + ' = ' + b);
// //   }

// //   1 * 5 = 5
// //  2 * 5 = 10
// //  3 * 5 = 15
// //  4 * 5 = 20
// //  5 * 5 = 25
// //  6 * 5 = 30
// //  7 * 5 = 35
// //  8 * 5 = 40
// //  9 * 5 = 45
// //  10 * 5 = 50

// // function multiTable(number) {
// //     return `1 * ${number} = ${1*number}
// //     2 * ${number} = ${2*number}
// //     3 * ${number} = ${3*number}
// //     4 * ${number} = ${4*number}
// //     5 * ${number} = ${5*number}
// //     6 * ${number} = ${6*number}
// //     7 * ${number} = ${7*number}
// //     8 * ${number} = ${8*number}
// //     9 * ${number} = ${9*number}
// //     10 * ${number} = ${10*number}`
// //     }
// // переворот слов
// // function reverseWords(str){
// //     return str.split(' ').reverse().join(' ');
// //   }

// // let a = 'hi my name ilia'
// // console.log(a)           // => hi my name ilia
// // let b = a.split(' ')
// // console.log(b)           // => 6 ['hi', 'my', 'name', 'ilia']
// // let c = b.join(' ')
// // console.log(c)           // => hi my name ilia

// // let v = [5, 4, 3, 2]
// // let f = v.slice(1,3)
// // console.log(f)           // => 4,3

// // let a =  [0, 1, 2, 3, 4, 5, 6, 7]
// // let [ b, c, e, t, y, u, i ]= a
// // console.log(b, c, e, t, y, u, i ) // => 0 1 2 3 4 5 6

// // let p = document.getElementsByTagName('p')
// // console.log(p)
// // for (let i = 0; i<p.length ; i++) {
// //     p[i].style.color='red'
// // }

// // let b = document.getElementsByClassName('ttt')
// // console.log(b)

// // for (let j = 0; j<b.length; j++) {
// //     p[j].onclick= () => {
// //         alert('work')
// //     }
// // }

// // let q =[-4, -3, -2, -1, 0, 1, 2, 3, 4]
// // let CA = 0;
// // for (let k = 0; k<q.length; k++) {
// //     CA += q[k]
// // }
// // console.log('++++++')
// // console.log(CA/q.length) // => 0
// // console.log(Math.max.apply(null, q)) // => 4
// // console.log(Math.min.apply(null, q)) // => -4

// // let w = [
// //     [1, 2, 3],
// //     [4, 5, 6],
// //     [7, 8, 9],
// // ]

// // for (e = 0; e<w.length; e++) {
// //     CA = 0
// //     for (let r = 0; r<w[e].length; r++) {
// //         CA += w[e][r]
// //     }

// //     console.log('-----------')
// //     console.log('t middle = '+CA/ w[e].length)
// //     console.log('t max = '+Math.max.apply(null, w[e]))
// //     console.log('t min = '+Math.min.apply(null, w[e]))
// // }

// /* => -----------
// JS_L.js:1447 t middle = 2
// JS_L.js:1448 t max = 3
// JS_L.js:1449 t min = 1
// JS_L.js:1446 -----------
// JS_L.js:1447 t middle = 5
// JS_L.js:1448 t max = 6
// JS_L.js:1449 t min = 4
// JS_L.js:1446 -----------
// JS_L.js:1447 t middle = 8
// JS_L.js:1448 t max = 9
// JS_L.js:1449 t min = 7
//  */
// // let i = 0
// // for ( ; ; ) {
// //     i<15
// //     i++
// //     if (i === 5) break;
// //     console.log(i);

// // }

// // let i = 0;
// // while (i<8){
// //     continue
// //     console.log(i);
// //     i++;
// // }


// // // => вывести числа от 4 до 400 на экран
// // for (let i = 4; i<= 400; i++) {
// //     console.log(i)
// // }

// // // => вывести числа от 4 до 13 с шагом 3 на экран
// // for (let i = 4; i <=13; i += 3) {
// //     console.log(i);
// // }

// // => вывести числа 654 653 652 - до нуля
// // for (let i = 654; i>=0; i-- ) {
// //     console.log(i);
// // }

// // //=> вывести все годы с 1983 до 2017
// // for (let i = 1983; i<=2017; i++) {
// //     console.log(`${i} год`)
// // }

// // // => вывести все числа от -4 -2 до 100
// // for (let i = -4; i<=100; i+= 2) {
// //     console.log(i);
// // }

// // => таблица умножения на 7 от 1 до 9

// // for (let i = 1; i<=9; i++) console.log(`${i} * 7 = ${i*7}`)

// // ->
// // 1 * 7 = 7
// // 2 * 7 = 14
// // 3 * 7 = 21
// // 4 * 7 = 28
// // 5 * 7 = 35
// // 6 * 7 = 42
// // 7 * 7 = 49
// // 8 * 7 = 56
// // 9 * 7 = 63

// // let a = [];
// // a = [10, 11, 12, 13, 14, 15];
// // a[7] = 17;
// // console.log(a);
// /* ->
// (8) [10, 11, 12, 13, 14, 15, empty, 17]
// 0: 10
// 1: 11
// 2: 12
// 3: 13
// 4: 14
// 5: 15
// 7: 17
// length: 8
// [[Prototype]]: Array(0)
//  */
// // let c = [3, 'ilia', true];
// // c[5]=17;
// // console.log(c)
// // delete c[5];
// // console.log(c);
// // let c = [3, 'ilia', true]
// // c[5] = 17;
// // delete c[5];
// // let out = document.getElementById('out');
// // let str = '';
// // for (let i = 0; i < c.length; i++) {
// //     if(c[i] !== undefined) str += i + ' - ' + c[i] + '<br>'; // -> мы просто отображаем все элементы массива с пробелами с обоих сторон
// // }
// // out.innerHTML = str;
// // // -> на странице - 3 ilia true undefined undefined undefined

// // let a = [2, 7];
// // a.push('hello');
// // a.push(65);
// // console.log(a);
// // a.pop();
// // a.pop();
// // a.pop();
// // a.pop();
// // a.pop();
// // console.log(a);

// // let a = [2, 7, 4];
// // a.shift();
// // a.unshift(2);
// // console.log(a);
// // // -> [2, 7, 4];

// // let a = 'Однажды в студёную зимнюю пору я из лесу вышел';
// // let b = a.split(',');
// // console.log(b)

// // const array1 = ['a', 'b', 'c'];

// // array1.forEach(element => console.log(element));
// // a b c

// // const elements = ['Fire', 'Air', 'Water'];

// // console.log(elements.join());
// // // expected output: "Fire,Air,Water"

// // console.log(elements.join(''));
// // // expected output: "FireAirWater"

// // console.log(elements.join('-'));
// // // expected output: "Fire-Air-Water"

// // console.log(elements.join(' '))

// // let p = document.getElementsByTagName('p');
// // console.log(p);
// // for (let i = 0; i<p.length; i++) {
// //     p[i].onclick = () => alert('work');
// // }

// // let temp = [-4,-3,-2,-1,0,1,2,3,4]
// // let middle = 0;
// // for(let i = 0; i<temp.length; i++) {
// //     middle += temp[i]
// // }
// // console.log(middle/temp.length);
// // // -> 0
// // console.log(Math.max.apply(null, temp))
// // console.log(Math.min.apply(null, temp))

// // let temp = [
// //     [-4, 0, 3, 13],
// //     [-5, -1, 8, 12],
// //     [0, 3, 6, 11],
// //     [0, 3, 6, 11],
// // ]

// // for (let i = 0; i<temp.length; i++) {
// //     let middle = 0;
// //     for (let k = 0; k<temp[i].length; k++) {
// //         middle += temp[i][k]
// //     }
// //     console.log('t middle = ' + middle/temp[i].length);
// //     console.log('t min = ' + Math.min.apply(null, temp[i]))
// //     console.log('t max = ' + Math.max.apply(null, temp[i]))
// // }

// // let str = '12345';
// // let reversed = Array.prototype.map.call(str,(x)=>x).reverse().join('');
// // console.log(reversed);


// // function sum(x, y, z) {
// //     return x + y + z;
// //   }

// //   const numbers = [1, 2, 3];

// //   console.log(sum(...numbers));
// // let a = [3,4,5]
// // let c = a.map((x)=>x*2)
// // console.log(c);
// // let a = [3, -12, 0, 4, 5, -8];
// // // let b = [];
// // // for (let i = 0; i<a.length; i++) {
// // //     if (a[i]>=0) b.push(a[i])
// // // }
// // // console.log(a);
// // // console.log(b);
// // // let c = a.filter((x)=>x>0)
// // // console.log(c);
// // // console.log(a);

// // // let c = a.filter((x, i)=>i%2===0)
// // // console.log(c);

// // let c = a.filter((x)=> x%2===0)
// // console.log(c)
// // let a = 0;
// // b()
// // function b () {
// //     console.log(a)
// //     let c = 9;
// // }
// // console.log(c)
// // function summ (a=0, b=5) {
// //      console.log(a+b)
// // }

// // summ()
// // function er () {
// //     return summ()
// // }
// // er()

// // function show (t) {
// //     if (t>0) return '>0'
// //     else if (t<0) return '<0'
// //     else return '=0'
// // }

// // function sum (a,b) {
// //     let t = 0
// //     console.log(a+b)
// //     console.log(show(t))
// // }

// // console.log('----')
// // console.log(show(1))
// // console.log(sum(2,2))

// // let a = {};
// // a.hi = 'test';
// // console.log(a);
// // console.log(a.hi);
// // console.log(a['hi']);

// // let b = {
// //     hi: 'ilia',
// //     yet: 'of course'
// // }

// // let y = 'hi' in b;
// // console.log(y); // -> true поиск ключа в массиве через переменную.
// // console.log(b);
// // delete b.yet;
// // console.log(b);
// // b.nowway = 'oh yeap'
// // console.log(b.yet);
// // console.log(b); // -> {hi: 'ilia', nowway: 'oh yeap'}

// // let a = {
// //     one: 'Hello',
// //     name: 23
// // }

// // let b = a;
// // b.five = 5;
// // console.log(a); // -> {one: 'Hello', name: 23, five: 5}
// // console.log(b); // -> {one: 'Hello', name: 23, five: 5}

// // let a = {
// //     one: 'Hello',
// //     two: 'world'
// // }

// // let b={};

// // for (let key in a) {
// //     b[key] = a[key];
// // }
// // console.log(a);
// // console.log(b);
// // b.three = 'ok'
// // a.three = 'allright'
// // console.log(a); // -> {one: 'Hello', two: 'world', three: 'ok'}
// // console.log(b); // -> {one: 'Hello', two: 'world', three: 'allright'}

// // function f1() {
// //     let div = document.querySelector('#yeap');
// //     div.innerHTML += ' Hello'
// // }

// // f1();

// // function f2() {
// //     let div = document.querySelector('#yes');
// //     div.innerHTML += ' Hello'
// // }

// // f2();


// // function f3() {
// //     c.innerHTML += ' Hello'
// // }

// // let c = document.querySelector('#seven');
// // f3();
// // c = document.querySelector('#eight');
// // f3();

// // // ------------------------------

// // function f4(z){
// //     let d = document.querySelector('#'+z)
// //     d.innerHTML+=' it\'s work '
// // }
// // f4('seven')
// // f4('eight')

// // let one = document.querySelector('#one');

// // console.log(one);

// // function myClick(event) {
// //     console.log('click');
// //     console.log(event.target);
// // }

// // one.onclick = myClick;

// // const c = {
// //     t: 0
// // }
// // c.a = 8;
// // console.log(c.a);
// // console.log(c);
// // c.t = 2;
// // console.log(c);
// // /*Log 6 8
// // JS_L.js:1787 {t: 0, a: 8}
// // JS_L.js:1789 {t: 2, a: 8}*/

// // const b = ['ilia', 'ivan']
// // b.push = 'oleg';
// // console.log(b); // -> ['ilia', 'ivan', push: 'oleg']

// // console.log('hello');
// // console.log('world');
// // console.log('Hello' + 'world');
// // console.log('Hello' + ' ' + 'world');
// // console.info('hello')
// // console.table('hello')

// // document.getElementById('one').innerHTML = 'Alone'
// // document.getElementById('one').innerHTML = 1
// // document.getElementById('one').innerHTML = '<b>1</b>' // js интерпретирует и сделает 1 жирным

// // document.getElementsByClassName('header').innerHTML = 'some' // странно

// // document.querySelector('.header').innerHTML = 'Plactice'
// // document.querySelector('.header').innerHTML = 'Practice'

// // let a = document.querySelector('.header');
// // a.innerHTML = 'Plactice'
// // console.log('09');
// // console.log('Добро ' + 'пожаловать ' + 'на курс');
// // a.innerHTML = 'Pratcice'


// //___________________________________JavaScript 2.0_________________________

// //___________Task 1

// console.log('ilia');

// //___________Task 2

// console.log('09');

// //___________Task 3

// console.log(`Добро пожаловать на курс`);

// //_______________________Основа ввода данных работа с input____________________
// let inputIn = document.querySelector('.input_in');
// let buttGo = document.querySelector('.butGo');
// let divOnPage = document.querySelector('.onPage');

// buttGo.onclick = function () {
//     console.log('button work'); // -> button work
//     // console.log(inputIn.value); // value то что введено в input
//     let braiton = +inputIn.value
//     console.log(b + 7); // -> 37 если ввели в input 3
//     divOnPage.innerHTML = braiton
//     inputIn.value = '';
// } // -> т.о. мы можем читать значение из input
// // математические манипуляции между числом и строкой возможны только при сложении
// // деление на 0 - Infinity
// // сложение и конкатенация пишутся одинаково, поэтому при вводе в input 3
// // и прибавлении 7 в логе получится не 10 а 37
// // из input JS получает любые введенные данные в виде строки
// /* console.log(b + 7) -> '3' + 7 = '37' произошла конкатенация
// +inputIn.value - преобразует тип данных в number
// console.log(b + 7) -> 3 + 7 = 10

// Если в html у input поставить в type не text а number то в input можно
// будет вводить только числа, но из input все равно будет приходить тип данных строка
// и это не спасет ситуацию, зато +inputIn.value - да
// + перед элементом, переводит элемент в тип данных - число

// чтобы очистить поле input надо input.value = '' присвоить пустую строку*/


// //_____Ветвление_____________Условные операторы If else switch case__________

// /* 
// Всё что внутри {} выполнится если условие выдаст true 
// {} - блок действий
// Если Действие одно {} не нужны

// Одиночный if либо работает если условие выдаёт true, либо ничего не происходит
// */
// // let a = 6;
// // if (a > 9) {
// //     // true
// //     console.log('Yes'); // -> Yes
// // }
// /*
// Если требуется выполнить жёстко либо то, либо это, и никаких других вариантов, то
// добавляется else (без условий)
// в любом случае одно из двух действий сработает

// Если мы пишем if (){} а затем else{} то в любом случае должно сработать одно из двух

// != - не равно
// */
// // else {
// //     console.log('else');
// // }

// /*
// Пользователю необходимо ввести возраст и если он больше 16 - welcome
// если меньше - доступ запрещен

// Если нужно добавить еще условие добавляем else if () {}
// их может быть сколько угодно

// ageUser >= 16 && ageUser < 100 - диапазон

// && - И - срабатывает и выдает true только если оба условия верны
// || - ИЛИ - срабатывает и выдает true если одно из условий верно
// */

// //_____________Task 1

// let a = 7;
// let b = 9;
// console.log(a * b);

// //_____________Task 2

// let c = 7;
// let d = 9;
// console.log(c / d);

// //_____________Task 3

// let e = 3;
// let f = 5;
// console.log(e + f);

// //____________________________Тест возраста if else_______________________________

// const ageUserTry = document.querySelector('.age');
// let buttonUserTry = document.querySelector('.ageTry');
// let divUOP = document.querySelector('.ageOnPage');

// buttonUserTry.onclick = () => {

//     let ageUser = +ageUserTry.value;

//     if (ageUser >= 16 && ageUser < 100) {
//         divUOP.innerHTML = 'Welcome';
//     }
//     else if (ageUser >= 100) {
//         divUOP.innerHTML = 'Do you really need to go in?'
//     }
//     else {
//         divUOP.innerHTML = 'Access Denied';
//     }

//     switch (ageUser) {
//         case 15:
//             console.log('Eщё годик потерпи!');
//             break;
//         case 16:
//             console.log('Топи!');
//             break;
//         default:
//             console.log('ok');
//     }

// }
// // если выполняется первый if дальше выполнение - не идёт

// // ________________Task 1

// let button1 = document.querySelector('.firstBut');
// let input1 = document.querySelector('.firstInp');
// let output1 = document.querySelector('.firstDiv')

// button1.onclick = () => {
//     let num1 = +input1.value;

//     if (num1 == 4) {
//         console.log(true);
//         output1.innerHTML = 'true'
//     }
//     else {
//         console.log(false);
//         output1.innerHTML = 'false'
//     }
// }

// // _______________Task 2

// let button2 = document.querySelector('.secondBut');
// let input2 = document.querySelector('.secondInp');
// let input22 = document.querySelector('.secondInp2');
// let output2 = document.querySelector('.secondDiv')

// button2.onclick = () => {

//     let a21 = +input2.value
//     let a22 = +input22.value

//     if (a21 > a22) {
//         output2.innerHTML = a21
//     }
//     else if (a22 > a21) {
//         output2.innerHTML = a22
//     }
//     else {
//         output2.innerHTML = `${a21} = ${a22}`
//     }

// }

// //________________Task 3

// let button3 = document.querySelector('.thirdBut');
// let inp3 = document.querySelector('.thirdInp');
// let inp33 = document.querySelector('.thirdInp2');
// let output3 = document.querySelector('.thirdDiv');

// button3.onclick = () => {

//     let a31 = +inp3.value
//     let a32 = +inp33.value

//     if (a31 > a32) {
//         output3.innerHTML = a31
//     }
//     else if (a32 > a31) {
//         output3.innerHTML = a32
//     }
//     else {
//         output3.innerHTML = `${a31} = ${a32}`
//     }

// }

// //____________________Работаем с формами___________________________


// // Type input 'password'

// document.querySelector('.buttPasswordClass').onclick = () => {
//     console.log(document.querySelector('#inpPasswordId').value);
// }

// // Type input 'color'
// // присваиваем значение для переменных сокращая код

// let buttonColor = document.querySelector('.buttColorClass');
// let inputColor = document.querySelector('#inpColorId');

// buttonColor.onclick = () => {
//     console.log(inputColor.value);
//     // Задаём стили для кнопки и присваеваем фону кнопки выбранный в палитре цвет
//     buttonColor.style.backgroundColor = inputColor.value
// }

// // Type input 'date'

// document.querySelector('.buttDateClass').onclick = () => {
//     console.log(document.querySelector('#inpDateId').value); // -> 2022-10-28
// }

// // Type input 'range'
// // хотим двигать ползунок и смотреть как меняются события для этого есть событие oninput
// // oninput срабатывает каждый раз когда меняется состояние элемента

// document.querySelector('#inpRangeId').oninput = () => {
//     // console.log(document.querySelector('#inpRangeId').value); // для вывода в консоль
//     document.querySelector('#divOutValueInput').innerHTML = document.querySelector('#inpRangeId').value;
// }

// document.querySelector('.buttRangeClass').onclick = () => {
//     console.log(document.querySelector('#inpRangeId').value)
// }

// // Type input checkbox

// let checkboxValue = document.querySelector('#checkbox_1');
// document.querySelector('.buttCheckClass').onclick = () => {
//     if (checkboxValue.checked) {
//         document.querySelector('#divOutCheck').innerHTML = true
//     }
//     else {
//         document.querySelector('#divOutCheck').innerHTML = false
//     }
// }

// // _____ Textarea

// document.querySelector('#buttTextAreaId_1').onclick = () => {
//     document.querySelector('#divOutTextarea_1').innerHTML = document.querySelector('#textareaId_1').value;
//     document.querySelector('#textareaId_1').value = '';
// }

// // _____ Form

// document.querySelector('#buttTextAreaId_2').onclick = (event) => {
//     event.preventDefault();

//     let arrayForm = [
//     [document.querySelector('#textareaId_2').value],
//     [document.querySelector('#inpForm_2').value]
//     ]

//     document.querySelector('#divOutTextarea_2').innerHTML = arrayForm;

//     let form = document.querySelector('form')
//     console.log(form);
//     console.log(form[0].value);
//     console.log(form[1].value);
//     document.querySelector('#textareaId_2').value = '';
//     document.querySelector('#inpForm_2').value = '';
// }

// // итого form можно пользоваться как массивом.

// // Task 1 

//     document.querySelector('#buttTask_1').onclick = () => {
//         document.querySelector('#divOutTask_1').innerHTML = 1;
//     }

// // Task 2

//     document.querySelector('#inpTask_2').onclick = () => {
//         document.querySelector('#divOutTask_2').innerHTML = 2;
//     }

// // Task 3

//     document.querySelector('#pTask_3').onclick = () => {
//         document.querySelector('#divOutTask_3').innerHTML = 3;
//     }

// // Task with round braces 
// // Если количество ( совпадает с ) выдать true если нет false 

// let taskBraces = '()(()()())';

// let countBraces = 0;

// for (let i = 0; i<taskBraces.length; i++) {

//     if (taskBraces[i] === '(') {
//         countBraces++;
//     }
//     if (taskBraces[i] === ')') {
//         countBraces--;
//     }
//     if (countBraces < 0) {
//         break;
//     }

// }

// console.log('--------');
// if (countBraces !== 0) {
//     console.log(false);
// }
// else {
//     console.log(true)
// }

// // ________________________Циклы в JS_______________________________________

// // for

// /* for (условия на основании которых цикл либо выполняется либо не выполняется) {
//     блок команд которые будут повторяться,
//     все что я здесь напишу будет многократно повторяться при работе цикла если 
//     условия в скобках ранее - верны    
//  }

// for (1-е start; 2-е работаем пока верно, по сути финиш, верхняя граница; 3-е как изменяется счётчик) {
//     блок команд которые будут повторяться,
//     все что я здесь напишу будет многократно повторяться при работе цикла если 
//     условия в скобках ранее - верны   
// }

// если условие изначально не верно цикл не выполнится ни разу
// */

// // простой цикл

// // for (let i = 0; i<5; i++) {
// //     console.log(i);
// // }

// /* 
//    бесконечный цикл

//    цикл работает пока верно условие, а в данное случае условие будет верно всегда

// for (let i = 0; i>0; i++) {
//     console.log(i)
// }


// из цикла можно выйти заранее if i == 4 break;
// break - прерывание цикла
// */
// console.log('-------')

// for (let i = 0; i<5; i++) {
//     if (i == 4) {
//         break;
//     }
//     console.log(i);
// }

// let divCircles = document.querySelectorAll('.circles'); // получает 1 элемент подходящий под параметры и прекращает свою работу
// // querySelectorAll - создаст коллекцию (массив) nodelist из элементов подходящих под условия
// // divCircles.style.background = 'red'

// for (let i = 0; i<divCircles.length; i++) {
//     console.log(divCircles[i]);
//     divCircles[i].style.background = 'red'
//     divCircles[i].onclick = strangeFunc
// }

// function strangeFunc() {
//     console.log('work');
// }

// let getEls = document.getElementsByClassName('circles'); // создает коллекцию элементов

// console.log(getEls);

// for (let i = 0; i<getEls.length; i++) {
//     getEls[i].style.border = '2px solid lightgray'
// }

// // Radio buttons

// document.querySelector('#buttRadioId_1').onclick = () => {

//     let radioAttempt = document.querySelectorAll('input[type="radio"]')

//     console.log(radioAttempt);

//     for (let i = 0; i<radioAttempt.length; i++) {
//         if (radioAttempt[i].checked) {
//             console.log(radioAttempt[i].value);
//         }
//     }
// }

// // let i = 0 - видна в пределах области видимости своего блока

// // continue - прерываение одной итерации цикла

// let someVar = ''

// for(let i = 0; i<10; i++) {
//     if (i === 6) continue;
//     someVar = someVar + i + ' '
// }
// document.querySelector('#continueId').innerHTML = someVar

// // Task 1

// document.querySelector('#buttCirclesId_1').onclick = () => {

//     let varTask1 = ''

//     for (let i = 0; i<17; i++) {
//         varTask1 = varTask1 + i + '_'
//     }
//     document.querySelector('#divCirclesId_1').innerHTML = varTask1
// }

// // Task 2

// document.querySelector('#buttCirclesId_2').onclick = () => {

//     let varTask2 = ''

//     for (let i = 12; i<39; i = i + 2) {
//         varTask2 = varTask2 + i + '_'
//     }
//     document.querySelector('#divCirclesId_2').innerHTML = varTask2
// }

// // Task 3

// document.querySelector('#buttCirclesId_3').onclick = () => {

//     let varTask3 = ''

//     for (let i = 25; i>6; i--) {
//         varTask3 = varTask3 + i + '_'
//     }
//     document.querySelector('#divCirclesId_3').innerHTML = varTask3
// }

// // _________________________________Вложенные циклы___________________________________________

// let doec = document.querySelector('#divOutEnteredCircles')

// for (let i = 0; i < 6; i++) {
//     // i = 0
//     for(let k = 0; k < 10; k++) {
//     // k = 0    
//     doec.innerHTML += k
//     }
//     doec.innerHTML += ' ' // здесь можно указать тег <br> вместо пробела, тогда вывод будет в столбик
// }

// for (let i = 0; i < 10; i++) {
//     doec.innerHTML += '7*' + i + '=' + (i*7) + '<br>'
// }

// // Интерполяция

// for (let i = 0; i < 10; i++) {
//     doec.innerHTML += `7*${i}=${i*7}<br>` // таблица умножения на 7
// }

// // Полная таблица умножения

// let MultiTable = document.querySelector('#divOuMultiplyTable')

// for (let i = 0; i < 10; i++) {

//     for(let k = 0; k < 10; k++) {
//         MultiTable.innerHTML += `${i}*${k}=${k*i}<br>`
//     }

//     MultiTable.innerHTML += `<hr>`
// }

// // Task 1 

// let doft_1 = document.querySelector('#divOutForTask_1')

// for (let i = 0; i < 3; i++) {

//     for(let k = 0; k < 3; k++) {
//         doft_1.innerHTML += '*'
//     }
//     doft_1.innerHTML += '_'
// }

// // Task 2

// let doft_2 = document.querySelector('#divOutForTask_2')

// for (let i = 0; i < 3; i++) {

//     doft_2.innerHTML += `${i}<br>`

//     for(let k = 0; k < 3; k++) {
//         doft_2.innerHTML += '*_'
//     }
//     doft_2.innerHTML += '<br>'
// }

// // Task 3

// let doft_3 = document.querySelector('#divOutForTask_3')

// for (let i = 0; i < 3; i++) {

//     for(let k = 0; k < 3; k++) {
//         doft_3.innerHTML += '*_'
//     }
//     doft_3.innerHTML += '<br>'
// }

// // Task 4

// let doft_4 = document.querySelector('#divOutForTask_4')

// for (let i = 0; i < 3; i++) {

//     for(let k = 0; k < 3; k++) {
//         doft_4.innerHTML += '10'
//     }
//     doft_4.innerHTML += '<br>'
// }

// //__________________________________________Функции_________________________________________

// function first() {
//     console.log('firstFunctionWork');
// }

// /* После первого прочтения файла JS видит функцию и ее имя, но внутрь функции не заходит
// и соответственно при первом чтении внутренние ошибки внутри функции не видит,
// чтобы функция сработала нужно вызвать функцию, только тогда JS обратится к внутреннему содержимому функции

// чтобы вызвать функцию нужно написать one(); */ 

// first(); // -> firstFunctionWork

// // так же можно повесить вызов содержимого функции на кнопку

// let buttForFirstFunction = document.querySelector('#buttForFirstFunction'); // получил кнопку

// // присваиваю кнопке функцию по клику

// buttForFirstFunction.onclick = first; // - здесь пишем вызов функции без скобок

// /* если я напишу выше first() то данная функция просто отработает и результат ее работы запишется 
// в свойство слева от знака присвоения
// {тело функции} 
// {console.log('firstFunctionWork');} - функция просто выполняет набор действий в других языках такие функции называются процедуры
// в данном случае функция просто вводит firstFunctionWork в консоль, внутри могут быть и циклы и функии if else и т.д.

// Но функция может не только выполнять какие-либо действия (процедуры) но и возвращать значение

// Если функци просто выполняет какой-то набор действий, то результатом ее выполнения привызове

// console.log(first()); -> станет undefined то есть данная функция ничего не возврщает назад программе, 
// каких-либо данных которые мы могли бы использовать дальше

// return - делает так чтобы функция возвращала свое последнее значение полученное в результате операций
// в коде функции выше return

// return - метка функции прекратить свою работу и если функция выполняется в каком-то выражении,
// то вместо имени функции подставить то, что стоит в одной строке с return

// по сути функция это такая же переменная значение которой присваивается не через знак = а после слова return*/

// function second() {
//     console.log('secondFunction');
//     return 'secondFunctionReturn'
// }

// second(); // -> secondFunction 2 раза потому что в функции  console.log('secondFunction');
// second(); // -> secondFunction 3 раза потому что в функции  console.log('secondFunction'); и до этого вызывали 1 раз

// console.log('really ' + second()); // -> really secondFunctionReturn

// function second2() {
//     console.log('secondFunction2');
//     return 2
// }

// console.log(2 * second2); // NaN
// console.log(2 * second2()); // 4 - если результат операций поставить в return то так могу использовать функцию внутри математических действий
// // 

// let cc; 

// function multi() {
//     let a = 9;
//     let b = 8;
//     console.log(a*b);
//     cc = (a*b)+1 
// }

// multi(); // -> 72 как теперь можно использовать 72 дальше? - никак пока нет return 
// // либо можно добавить переменную с за пределами функции описать ее действие внутри функции и использовать дальше

// console.log(cc); // 73 таким образом можем вытянуть из области видимости функции нужно нам значение
// // но это же действие и выполняет слово return

// // что происходит если я вместо сс запишу return

// let aa = 10;
// let bb = 9;

// function multiply() {
//     console.log(aa*bb);
//     return aa*bb
// }

// // теперь я могу пользоваться именем фукнции для использования результата ее деятельности записанного после return
// // теперь я могу объявить любую переменную и присвоить ей результат выполнения функции


// let v = multiply();
// console.log(v/2); // -> 45 то есть я использую в дальнейшем функцию и её значение просто как переменную

// /* В ES6 переменные имеют блочную область видимости
// Если в области видимости конкретной функции используется переменная которая в пределах этой области видимости {}
// Не обоъявлена, то JS выходит за пределы области видимости {} и ищет используемую переменную 
// в глобальной области видимости, если находит - использует ее в пределах области видимости функции


// multiply()
// () - это специальное место для параметров, аргументов функции
// с параметрами, аргументами функция будет иметь такой синтаксис*/
// console.log('------');

// function multiply_2(x, y) {
//     // манипуляция параметрами осуществляется внутри функции
//     return x*y
// }

// /* multiply_2() -> undefined потому что при указании параметров, аргументов при написании функции 
// я должен поставить значения на место параметров и аргументов при вызове функции иначе undefined,
// так как в функции у нас только return то при вызове функции добавим console.log иначе undefined.

// Потому что по умолчанию в ES6 можно использовать параметры по умолчанию
// то есть:
// function multiply_2(x = 20, y = 5) {...} если при вызове функции задаются значения для x и y
// multiply_2(21,6) то данные из вызова заменят значения из параметров по умолчанию и станет:
// function multiply_2(x = 21, y = 6) {...}
// но если будет указан только один параметр или ни одного то, тогда внутрь функции будут приняты 
// недостающие значения аргументов из параметров по умолчанию в порядке очереди
//  */

// console.log(multiply_2(2,3)) // -> 6 функция выполнила своё действие
// console.log(multiply_2(20,5)); // -> 100
// // таким образом значения указанные при вызове функции попадают на вход на место аргументов функции (параметров)
// // function multiply_2(x = 20, y = 5) {return 20*5}
// // будет работать в том числе если в качестве параметра подставить переменную aa из глобальной области видимости
// console.log(multiply_2(aa,7)); // -> 70

// //__Функций это способ решения основной проблемы программирования - дублирования кода
// // написал код 1 раз использовал infinity раз

// // все что написано в коде после return выполняться не будет 

// //___ Анонимные функции
// /*
// function (){
//     console.log('ilia');
// }

// Анонимная функция это способ организации кода в некий блок

// Такие функции принято использовать там где функции вызываются всего лишь 1 раз
// Именованые функции можно использовать любое количество раз используя имя

// Синтаксис анонимных функций в ES6 был дополнен стрелочными функциями

// Стрелочная функция это один из способов написания анонимных функций

// let arrowFunction = () => {

// }

// это аналог анонимной функции
// () => {}    
// function (){} - the same

// Напишем несколько функций и переведем их в анонимные
// */
// document.querySelector('#anonimusFunction_1').onclick = function (){
//     console.log('+++++++')
// }

// /*
// document.querySelector('#anonimusFunction_1').onclick = () => {
//     console.log('+++++++');
// }

// Если я сделаю вторую такую операцию одному и тому же элементу присвою дважды свойство onclick 
// будет работать только последнее предыдущее будет проигнорировано */

// document.querySelector('#anonimusFunction_2').onclick = () => {
//     console.log('---');
// }

// // Сокращения стрелочной функции

// (a,b) => {

// }

// // Если у нас только один параметр в функции

// a => {
//     return 'ilia'
// }

// a =>'ilia' // a возвращает строку ilia

// /* Итог:
//     Функция это способ организации кода 
//     Функция может просто делать какие-то действия
//     Либо возвращать своё значение
//     Когда говорят функция возвращает своё значение 
//     Понимается что её можно присвоить переменной 
//     И внутрь переменной после выполнения функций попадёт результат ее выполнения

//     Возвращение значения функции означает что ее можно поставить в какое-то
//     математическое выражение либо в конкатенацию и получить осмысленный результат

//     Функции бывают двух видов - именованые - их можно использовать многократно
//     И анонимные - без имени - используются один раз для удобного написания кода

//     В функцию можно передавать параметры, они передаются через запятую и указываются при создании функции
//     Параметром в ES6 можно присвоить значения по умолчанию через запятую, затем их можно подставить и использовать

//     Стрелочные функции по разному работают с this
//     Работа в обычных анонимных функциях и в стрелочных функциях - разная*/

// // _____ Task 1

// let a1 = 11;

// document.querySelector('#buttonForFunctionTask_1').onclick = () => {
//     document.querySelector('#divOutForFunctionTask_1').innerHTML = a1;
// }

// // _____ Task 2

// let a2 = 12

// function alarm2() {
//     return document.querySelector('#divOutForFunctionTask_2').innerHTML = a2;
// }

// alarm2()

// // ____ Task 3

// function alarm3(x, y) {
//     return x*y
// }

// document.querySelector('#buttonForFunctionTask_3').onclick = () => {
// document.querySelector('#divOutForFunctionTask_3').innerHTML = alarm3(2,3)
// }

// // _____________________Text content || innerHTML___________________________

// let primer = document.querySelector('.primer');
// console.log(primer);
// console.log(primer.innerHTML); // -> текст вывелся в лог со всеми html тегами в нем
// console.log(primer.textContent); // -> текст вывелся в лог сработал br и span не сработал <b> <i>
// // работа textContent схожа с innerText

// // добавляем второй текст сразу на страницу без лога
// // document.querySelector('#divOutLorem_1').innerHTML = primer.innerHTML 
// console.log(primer.innerText); // -> текст вывелся в лог без некоторых html тегов отработал br span
// // проигнорированы <b> <i>

// document.querySelector('#divOutLorem_1').innerText = primer.innerText // -> текст вывелся на страницу без влияния на него тегов html

// // textContent пробуем вывести внутрь блока

// document.querySelector('#divOutLorem_1').innerHTML = primer.textContent // теги проигнорированы

// document.querySelector('#divOutLorem_1').textContent = primer.textContent // теги проигнорированы

// // textContent выше скорость обработки чем у innerHTML


// // Вывод если нам нужны HTML теги используем innerHTML если нам нужен просто вывод используем textContent


// //____________________________________Циклы Do and Do While___________________________________________________

// for (let i = 0; i < 6; i++) {
//     console.log(i); // -> от 0 до 5
// }

// /* while - это ключевое слово которое запускает тело цикла, тело цикла работает до тех пор пока в скобочках будет true

// пока k будет меньше 5 то что в скобочках будет выполняться*/

// let k = 0;
// // while (k < 5) {
// //     k++ // -> k: от 1 до 5
// //     console.log('k:' + k);
// // }
// // -> k: от 1 до 5

// // while (k<5) {
// //     console.log('k:' + k);
// //     k++ // -> k: от 0 до 4
// // }
// // -> k: от 0 до 4

// while (k<5) {
//     k++
//     console.log('k:' + k);
//     if (k == 3) continue; // - continue никак не повлияло на вывод
//     // k++ если поставить k здесь - будет бесконечный цикл
// }

// // с помощью цикла while найдем сумму чисел от 0 до 10

// let sum = 0;
// let p = 0;
// // while (p<=10) {
// //     p++
// //     sum = sum + p

// //     console.log(sum); // 0 = 0 + 1; 1 наверх в условие, возвращается через 1++; 1 = 1 + 2; 3 = 3 + 3; 6 = 6 + 4; 10 = 10 + 5; 15 = 15 + 6; 21 = 21 + 7; 28 = 28 + 8; 36 = 36 + 9; 45 = 45 + 10; 55 
// // }
// // console.log('sum = '+ sum);

// while (p <= 10) {
//     sum = sum + p
//     p++
//     console.log(sum); // 0 = 0 + 0; sum = 0 p = 1; 0 = 0 + 1; sum = 1 p = 2; 1 = 1 + 2; sum = 3 p = 3; 3 = 3 + 3: sum = 6 p = 4; 6 = 6 + 4; sum = 10 p = 5; 10 = 10 + 5; sum = 15 p = 6; 15 = 15 + 6; 21 7; 21 = 21 + 7; 28 8; 28 = 28 + 8; 36 9 = 36 + 9 = 45; 45 10; 45 = 45 + 10 = 55 
// }
// console.log('sum =' + sum);

// // произведение чисел решается так же

// // рисуем квадрат *
// let square = document.querySelector('#divOutLorem_1')
// let squareStar = ''

// p = 0;
// let flag = 3;

// while (p < 4) {
//     let p1 = 0
//     while (p1 < 4) {
//         if (p1 < flag) {
//             squareStar = squareStar + '&nbsp' // - неразрывный пробел для понимания можно заменить 0 - ком
//         }
//         else {
//             squareStar = squareStar + '*' // '' = '' + '*'; '*' = '*' + '*'; '**' = '**' + '*'; '***' = '***' + '*'; '****' 
//         }

//     p1++
//     }
//     flag--
//     squareStar = squareStar + '<br>'
//     p++
// }
// square.innerHTML = squareStar // -> ****

// /* while (p(4) < 4) {
//     let p1 = 0
//     while (p1(4) < 4) {
//         if (p1(4) < flag(0)) {
//             squareStar'' = squareStar'' + '&nbsp' 
//         }
//         else {
//             squareStar'' = squareStar'' + '*'       squareStar''''*<br> squareStar'''**<br> squareStar''***<br> squareStar****<br>

//     p1++(4)
//     }
//     flag--(-1)
//     squareStar = squareStar + '<br>'
//     p++(4)
// }
// square.innerHTML = squareStar */

// // самостоятельная усложнённая версия while

// let whileTrain = document.querySelector('#WhileTrain');
// let whileVoidString = '';
// let i = 0;
// let iflag = 4;

// while (i < 5) {
//     let ii = 0;
//     while (ii < 5) {
//         if (ii < iflag) {
//             whileVoidString += '&nbsp'
//         }
//         else {
//             whileVoidString += '&'
//         }
//     ii++    
//     }
//     iflag--
//     whileVoidString += '<br>'
//     i++
// }
// whileTrain.innerHTML = whileVoidString

// /* Как работает цикл

// let whileTrain = document.querySelector('#WhileTrain');
// let whileVoidString = '';
// let i = 0;
// let iflag = 4;

// while (i(5) < 5) {
//     let ii = 0;
//     while (ii(5) < 5) {
//         if (ii(4) < iflag(0)) {
//             whileVoidString += '&nbsp'
//         }
//         else {
//             whileVoidString += '&'
//         }
//     ii++(5)    
//     }
//     iflag--(-1)
//     whileVoidString += '<br>'
//     i++(5)
// }

// whileVoidString = '''''&<br>
// whileVoidString = ''''&&<br>
// whileVoidString = '''&&&<br>
// whileVoidString = ''&&&&<br>
// whileVoidString = &&&&&<br>

// whileTrain.innerHTML = whileVoidString
// */

// // ______________________________Работа с DOM, создание элементов, работа с CSS________________________________

// const p1 = document.querySelector('.p_1');

// // присваиваем элементу стиль, в отличие от CSS здесь вместо дефиса у свойства пишется camelCase
// // и все что мы присваиваем является строками

// p1.style.width = '150px'; // если закоментирую это свойство ширина будет 100% всей страницы - по родитльскому элементу
// p1.style.paddingBottom = '40px'
// p1.style.textAlign = 'center'

// // console.log(p1.style);

// // присваиваем новый класс из CSS методом add с именем класса

// p1.classList.add('p_2') // добавление через JS любых CSS классов 

// /* в Elements после этого добавилось свойство p_2:
// <p class="p_1 p_2" style="width: 150px; padding-bottom: 40px; text-align: center;">Text</p>
// */

// // так мы можем добавлять в том числе и несуществующие классы а потом дописать их в CSS

// p1.classList.add('p_3')

// // удаление CSS класса с помощью JS
// // p1.classList.remove('p_3')

// // теперь мы можем из JS изменять состояния html элементов

// const toggle = document.querySelector('.toggle');

// // this это элемент на котором происходит событие

// toggle.onclick = function() {
//     this.classList.toggle('p_3') // по щелчку к кнопке toogle применяется свойство из CSS
// }

// // для того чтобы хранить данные либо состояния или свойства в html объектах не предусмотренные программистами
// // которые создавали html и CSS был специально разработан такой инструмент как атрибуты

// // Атрибуты

// // мы можем манипулировать атрибутами так как хотим
// // Для того чтобы в html 5 мы создавали корректные атрибуты перед ними должна быть приставка data в виде атрибута
// // <p data='privet'></p>
// // как получить атрибут data
// console.log(p1.getAttribute('data')) // дальше есть 2 возможности первая создавать атрибуты вторая 
// // читать атрибуты (getAttribute('')) и указать имя атрибута

// // мы можем создать и перезаписать любой атрибут
// // сначала пишем имя атрибута, в html 5 рекомендуют писать имя атрибута с приставки data 
// // вторым может идти значение: строка или число

// p1.setAttribute('data-num', 6) 
// /* <p class="p_1 p_2 p_3" data="privet" data-num="6" style="width: 150px; padding-bottom: 40px; text-align: center;">Text</p>*/

// //___Task 1
// /* При нажатии любой из кнопок запускаем функцию
// в начале получим сами кнопки */

// let gas = document.querySelectorAll('.gas') // это массив, а раз это массив то мы должны его перебрать
// // вешаем событие
// for (let i = 0; i < gas.length; i++) {
//     gas[i].onclick = function() {
//         let gallons = document.querySelector('.gallons').value
//         let amount = this.getAttribute('data') // this это кнопка по которой нажали 
//         console.log(gallons*amount)
//     }
// }

// // -> при введении 10 получаем 12 16 19
// // мы научились с помощью атрибутов сохранять данные в html
// /* в интернет магазине как узнать какой товар выбрал пользователь самое простое просто на кнопку повесить id товара
// когда пользователь кликает по кнопке считать этот дата атрибут и мы будем знать по какому товару он кликнул

// Если у нас есть массив кнопок мы сможем легко понять какой товар выбран а если не сможем отправим на серевер и там 
// разберемся*/

// /* Нам не нужен html чтобы создавать элементы
// Создание элемента */
// let firstCreateElementJS = document.createElement('div')

// console.log(firstCreateElementJS);

// /* Когда я получаю элемент со страницы я получаю элемент с помощью querySelector
// я получаю элемент который уже был создан кем-то
// а с помощью createElement я заново создаю элемент

// Добавляем текст в firstCreateElementJS*/
// firstCreateElementJS.innerHTML = 'ilia'

// // добавляем класс
// firstCreateElementJS.classList.add('d_1')

// // Разница с элементом полученным со страницы html в том, что мой элемент,
// // ещё не существует на странице, я могу его туда вставить,
// // для начала нам понадобится id или class элемента, в который мы будем его добавлять
// document.querySelector('#addCreateElementJS').appendChild(firstCreateElementJS); // -> элемент создан

// // можем добавить событие на вновь созданные элемент или удалять элемент из DOM при клике
// firstCreateElementJS.onclick = function() {
//     console.log('ilia first')
// }

// // ____________________________________Методы push pop splice_______________________________________________

// const array_1 = [1,2,3,4,5,6,7,8,9]
// const array_2 = ['a', 'b', 'c', 'd', 'e', 'f']

// // ___ Push - добавляет элементы в конец массива
// // возвращает новое свойство длины объекта length, новый массив не создает, работает со старым.
// console.log(array_1.length); // -> 9 length считается с 1 index считается с 0

// array_1.push(10)

// console.log(array_1) // -> (10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// // добавим несколько чисел

// array_1.push(11, 12, 13, 14, 15)

// console.log(array_1); // -> (15) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

// // повторяем операцию с массивом строк

// array_2.push('j', 'h', 'i')

// console.log(array_2); // -> (9) ['a', 'b', 'c', 'd', 'e', 'f', 'j', 'h', 'i']

// // ___ Pop - удаляет элементы с конца массива, последний элемент массива или undefined, если массив пуст.
// // Метод pop удаляет последний элемент из массива и возвращает удалённое значение.
// // если просто вызвать pop() без значения удалится 1 последний элемент массива
// // если вызвать pop() несколько раз подряд произойдет удаление нескольких элементов массива
// // у метода pop нет параметров это просто метод со ()

// console.log(array_2); // -> (9) ['a', 'b', 'c', 'd', 'e', 'f', 'j', 'h', 'i']

// console.log(array_2.pop()); // -> i

// console.log(array_2); // -> (8) ['a', 'b', 'c', 'd', 'e', 'f', 'j', 'h']

// // ___ Работа с элементами внутри массива
// // ___ Удаление элемента внутри массива

// delete array_2[7];

// console.log(array_2); // -> (8) ['a', 'b', 'c', 'd', 'e', 'f', 'j', empty]

// // 7 индекс - пропадает при этом длина массива - не меняется
// // после delete в массиве остаются пустые empty
// // операции удаления из массива чаще всего являются медленными 
// // поэтому лучше будет создать новый массив с нужными элементами
// // принцип immutable

// // если хочу вырезать элемент из массива без оствашегося empty так чтобы все индексы после этого шли по порядку

// // ___ Splice

// // array.splice() 
// // Метод splice() изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.

// // start - индекс, по которому начинает изменять массив. 
// // если start больше длины массива, реальный индекс будет установлен на длину массива. 
// // если отрицателен, указывает индекс элемента с конца.

// /* deleteCount целое число, показывающее количество старых удаляемых из массива элементов.
// если deleteCount равен 0, элементы не удаляются. 
// В этом случае вы должны указать как минимум один новый элемент. 
// Если deleteCount больше количества элементов, оставшихся в массиве, начиная с индекса start, 
// то будут удалены все элементы до конца массива.

// Возвращаемое значение
// Массив, содержащий удалённые элементы. 
// Если будет удалён только один элемент, вернётся массив из одного элемента.
// Если никакие элементы не будут удалены, вернётся пустой массив.

// Если количество указанных вставляемых элементов будет отличным от количества удаляемых элементов,
// массив изменит длину после вызова.

// Удаляет 0 элементов по индексу 2 и вставляет "drum"
// var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
// var removed = myFish.splice(2, 0, 'drum');

// myFish равен ["angel", "clown", "drum", "mandarin", "sturgeon"]
// removed равен [], ничего не удалено

// Удаляет 1 элемент по индексу 3
// var myFish = ['angel', 'clown', 'drum', 'mandarin', 'sturgeon'];
// var removed = myFish.splice(3, 1);

// removed равен ["mandarin"]
// myFish равен ["angel", "clown", "drum", "sturgeon"]

// Удаляет 1 элемент по индексу 2 и вставляет "trumpet"
// var myFish = ['angel', 'clown', 'drum', 'sturgeon'];
// var removed = myFish.splice(2, 1, 'trumpet');

// myFish равен ["angel", "clown", "trumpet", "sturgeon"]
// removed равен ["drum"]

// Удаляет 2 элемента начиная с индекса 0 и вставляет "parrot", "anemone" и "blue"
// var myFish = ['angel', 'clown', 'trumpet', 'sturgeon'];
// var removed = myFish.splice(0, 2, 'parrot', 'anemone', 'blue');

// myFish равен ["parrot", "anemone", "blue", "trumpet", "sturgeon"]
// removed равен ["angel", "clown"]

// Удаляет 2 элемента начиная с индекса 2
// var myFish = ['parrot', 'anemone', 'blue', 'trumpet', 'sturgeon'];
// var removed = myFish.splice(myFish.length - 3, 2);

// // myFish равен ["parrot", "anemone", "sturgeon"]
// // removed равен ["blue", "trumpet"]

// ?
// Удаляет 1 элемент по индексу -2
// var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
// var removed = myFish.splice(-2, 1);

// // myFish равен ["angel", "clown", "sturgeon"]
// // removed равен s ["mandarin"]

// Удаляет все элементы после индекса 2 (включительно)
// var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
// var removed = myFish.splice(2);

// // myFish равен ["angel", "clown"]
// // removed равен ["mandarin", "sturgeon"]

// с помозью splice удаляем наш empty*/

// array_2.splice(6, 2); // -> (8) ['a', 'b', 'c', 'd', 'e', 'f', 'j', empty]
// console.log(array_2); // -> (6) ['a', 'b', 'c', 'd', 'e', 'f']

// // удаляем из середины

// array_2.splice(1, 2);
// console.log(array_2) /* -> (4) ['a', 'd', 'e', 'f']
// 0: "a"
// 1: "d"
// 2: "e"
// 3: "f"
// length: 4 

// нужные элементы удалены индекс сместились

// В методе splice после 2-х обязательных параметров указываются элементы которые буду добавлены в массив 
// начиная с индекс который указан в качестве параметра start

// Плюс в том что мы получаем новый массив с порядковыми индексами по возрастанию без пропусков

// Минус если вы завязаны на какие - то элементы массива если в какой-то операции получаете a[4]
// то в результате splice индексы будут смещены и под a[4] окажется не то что было нужно.*/

// // __ shift unshift аналоги pop и push

// /* Позволяют удалять и добавлять элементы в начало массива

// shift() удаляет первый элемент из массива и возвращает его значение. Этот метод изменяет длину массива.

// Пример: удаление элемента из массива
// Следующий код показывает массив myFish до и после удаления его первого элемента. Также он показывает удалённый элемент:

// var myFish = ['ангел', 'клоун', 'мандарин', 'хирург'];

// console.log('myFish до: ' + myFish);
// //myFish до: ангел,клоун,мандарин,хирург

// var shifted = myFish.shift();

// console.log('myFish после: ' + myFish);
// //myFish после: клоун,мандарин,хирург

// console.log('Удалён этот элемент: ' + shifted);
// //Удалён этот элемент: ангел
// Вывод этого примера будет следующим:

// myFish до: ангел,клоун,мандарин,хирург
// myFish после: клоун,мандарин,хирург
// Удалён этот элемент: ангел


// unshift() добавляет один или более элементов в начало массива и возвращает новую длину массива.

// Возвращаемое значение
// Новое свойство length объекта, над которым был вызван метод unshift.

// Примеры
// var arr = [1, 2];

// arr.unshift(0);
// результат вызова равен 3, новой длине массива
// arr равен [0, 1, 2]

// arr.unshift(-2, -1);
// = 5
// arr равен [-2, -1, 0, 1, 2]

// arr.unshift([-3]);
// arr равен[[-3], -2, -1, 0, 1, 2]

// Добавление элементов в начало массива тоже переводи к пересчету всех индексов*/

// // __________________________________ Двумерные массивы__________________________________________________

// let array_3 = [1,2,3]; // -> стандартный массив

// // двумерный массив 

// let array_4 = [
//     [1,2,3],
//     [4,5,6],
//     [7,8,9], // эта запятая - не лишняя
// ];

// console.log(array_4[2][1]) // -> 8

// console.log(array_4); /* ->

// (3) [Array(3), Array(3), Array(3)]
// 0: (3) [1, 2, 3]
// 1: (3) [4, 5, 6]
// 2: (3) [7, 8, 9]
// length: 3

// переберем циклом for массив с массивами */

// for (let i = 0; i < array_4.length; i++) {
//     console.log(array_4[i]); // так я обращаюсь с начала к массиву в массиве под индексом сначала 0 потом 1 потом 2 
// } /* -> 
// (3) [1, 2, 3]
// (3) [4, 5, 6]
// (3) [7, 8, 9]
// */

// for (let i = 0; i < array_4.length; i++) {
//     console.log(array_4[i]); 
//     let array_4Index = array_4[i] // array_4Index - теперь простой массив [1,2,3] потом [4,5,6] потом [7,8,9] поэтому дальне работаем с ним как с обычным массивом
//     for (let k = 0; k < array_4Index.length; k++) {
//         console.log(array_4Index[k])
//     }
// }
// /* ->
// 1
// 2
// 3
// (3) [4, 5, 6]
// 4
// 5
// 6
// (3) [7, 8, 9]
// 7
// 8
// 9 
// */
// console.log('------')

// // Вывод двумерного массива через вложенные циклы

// for (let i = 0; i < array_4.length; i++) {
//     console.log(array_4[i])
//     for(let k = 0; k < array_4[i].length; k++) {
//         console.log(array_4[i][k])
//     }
// } 
// /* ->
// (3) [1, 2, 3] console.log(array_4[i])
// 1   console.log(array_4[i][k])
// 2   console.log(array_4[i][k])
// 3   console.log(array_4[i][k])
// (3) [4, 5, 6] console.log(array_4[i])
// 4   console.log(array_4[i][k])
// 5   console.log(array_4[i][k])
// 6   console.log(array_4[i][k])
// (3) [7, 8, 9] console.log(array_4[i])
// 7   console.log(array_4[i][k])
// 8   console.log(array_4[i][k])
// 9   console.log(array_4[i][k])
// */

// /* 

// let array_4 = [
//     [1,2,3],
//     [4,5,6],
//     [7,8,9], 
// ];

// */

// for (let i = 0; i < array_4.length; i++) {
//     for(let k = 0; k < array_4[i].length; k++) {
//         console.log(array_4[i][k])
//     }
// } /* -> 1 2 3 4 5 6 7 8 9 */

// //__ Вывод двумерного массива в обратом порядке
// // let k = array_4.length -1 - потому что идет обращение по индексу, а он меньше length на 1
// console.log('<-<-<-<-');
// for (let i = 0; i < array_4.length; i++) {
//     for(let k = array_4.length -1; k >= 0; k--) {
//         console.log(array_4[i][k])
//     }
// } /* -> то есть я перебираю тот же самый массив просто с конца сначала 3 потом 2 потом 1
// 3
// 2
// 1
// 6
// 5
// 4
// 9
// 8
// 7 

// let array_4 = [
//     [1,2,3],
//     [4,5,6],
//     [7,8,9], 
// ];

// array_4[i][k] - это всего лишь двойной индекс в массиве

// console.log(array_4[2][1]) // -> 8

// */

// let divOutTwenthArray = '';


// for (let i = 0; i < array_4.length; i++) {
//     for(let k = 0; k < array_4[i].length; k++) {
//         console.log(array_4[i][k])
//         divOutTwenthArray += array_4[i][k] + ' '
//     }
//     divOutTwenthArray += '<br>'
// } 

// document.querySelector('.divOutTwenthArray').innerHTML = divOutTwenthArray // -> 123456789

// // хочу после каждого внутреннего массива поставить пробел, за такой перебор отвечает внутренний массив k
// // поэтому перес строки нужно добавить за ним divOutTwenthArray += '<br>' т.о. после каждой итерации 
// // в итоговый вывод будет добавляться пробел
// /* Итог ->

// 123
// 456
// 789

// Если хочу в итоговый вывод добавить пробел, то добавляю его divOutTwenthArray += array_4[i][k] + ' '
// Итог ->

// 1 2 3
// 4 5 6
// 7 8 9

// Выведем только те числа массива которые больше 4
// */
// divOutTwenthArray = ''
// for (let i = 0; i < array_4.length; i++) {
//     for(let k = 0; k < array_4[i].length; k++) {
//         if (array_4[i][k] > 4) {
//         divOutTwenthArray += array_4[i][k] + ' '
//         }
//     }
//     divOutTwenthArray += '<br>'
// } 

// console.log('+++++')
// console.log(divOutTwenthArray) // -> if (array_4[i][k] > 4 {<br>5 6 <br>7 8 9 <br>}

// // Для уменьшения роли циклов создаем специализированную переменную

// // Задача нажимая кнопку передвигать еденицу 

// let array_5 = [1,0,0,0,0] 
// // отрисовываем массив
// document.querySelector('.divOutArray_2').innerHTML = array_5
// // получаем кнопку и вешаем на нее функцию клик

// let y = 0;
// document.querySelector('#oneMoveButton').onclick = () => {
//     if (y + 1 < 5) {
//     array_5[y] = 0;
//     array_5[y+1] = 1;
//     y = y + 1
//     }
//     document.querySelector('.divOutArray_2').innerHTML = array_5
// }

// /* 
// let y = 0;
// document.querySelector('#oneMoveButton').onclick = () => {
//     if (0 + 1 < 5) {   
//     array_5[0] = 1;
//     array_5[0+1] = 1;
//     0 = 0 + 1
//     }
//     document.querySelector('.divOutArray_2').innerHTML = array_5
//     // -> 
// }
// */

// // ___ Строим трапецию из *

// let starTrapezoid = ''

// for (let i = 0; i < 8; i++) {
//     for (let k = 0; k < 8; k++) {
//         starTrapezoid += '* '
//     }
//    starTrapezoid += '<br>'
// }

// document.querySelector('#starTrapezoidDiv').innerHTML = starTrapezoid //-> рисует прямоугольник из звезд 8 на 8
// // 8 - количество итераций для циклов с i и k

// /* Принцип замены * на любые другие символы
// это выполняется за счёт переменной находящейся за пределами циклов

// 1 выводим переменные счётчики за пределы цикла при выводе внутреннего цикла сравниваем переменную счётчик
// с счётчиком цикла и в зависимости от соотношения либо выводим символ '_' либо не выводим его '*' 

// 2 за пределами внутреннего цикла изменяем данную переменную w++ h--*/

// // Строим разные фигуры из модели трапеции

// // let starTrapezoidDiv = ''
// // let w = 4 // - переменная счетчик
// // let h = 7 // - переменная счетчик ************

// // for (let i = 0; i < 4; i++) {
// //     for (let k = 0; k < 12; k++) { 
// //         if (k < w || k > h) {
// //             starTrapezoidDiv += '_ '
// //             // starTrapezoidDiv += '&nbsp;&nbsp;'
// //         }
// //         else {
// //             starTrapezoidDiv += '* '
// //         }
// //     }
// //     w--
// //     h++
// //     starTrapezoidDiv += '<br>'
// // }

// // document.querySelector('#starTrapezoidDiv_2').innerHTML = starTrapezoidDiv

// let starTrapezoidDiv = ''
// let w = 0 // - переменная счетчик
// let h = 0 // - переменная счетчик ************

// for (let i = 0; i < 3; i++) {
//     for (let k = 0; k < 3; k++) { 
//         if (k < w || k > h) {
//             starTrapezoidDiv += '_ '
//             // starTrapezoidDiv += '&nbsp;&nbsp;'
//         }
//         else {
//             starTrapezoidDiv += '* '
//         }
//     }
//     w--
//     h++
//     starTrapezoidDiv += '<br>'
// }

// document.querySelector('#starTrapezoidDiv_2').innerHTML = starTrapezoidDiv

// /* 
// let starTrapezoidDiv = ''
// let w = 0
// let h = 0

// for (let i = 1; i < 2; i++) {
//     for (let k = 0; k < 2; k++) { 
//         if (k(1) < w(-1) || k(1) > h(1)) {
//             starTrapezoidDiv += '_ '
//         }
//         else {
//             starTrapezoidDiv += '* '
//         }
//     }
//     w--(-1)
//     h++(1)
//     starTrapezoidDiv += '<br>'
// }

// document.querySelector('#starTrapezoidDiv_2').innerHTML = starTrapezoidDiv 

// 1 итерация *_
// 2 итерация **

// --------------------------


// let starTrapezoidDiv = ''
// let w = 0
// let h = 0

// for (let i = 0; i(2) < 3; i++) {
//     for (let k = 0; k(0) < 3; k++) { 
//         if (k(0) < w(-2) || k(0) > h(2)) {
//             starTrapezoidDiv += '_ '
//         }
//         else {
//             starTrapezoidDiv += '* '
//         }
//     }
//     w--(-2)
//     h++(2)
//     starTrapezoidDiv += '<br>'
// }

// document.querySelector('#starTrapezoidDiv_2').innerHTML = starTrapezoidDiv 

// 1 итерация *_ _ 
// 2 итерация ** _
// 3 итерация ***
// */

// // __________________________________ Ассоциативные массивы____________________________________________

// const accArray = {
//     'a': 10,
//     'b': 'ilia',
//     'c': 'ulrih',
//     d: 1999, // ключи можно писать и без кавычек, если в названии ключа есть пробелы то указывай его в кавычках
//              // в остальных случаях можно и без них  
// };

// console.log(accArray); // -> {}

// /* Отличия ассоциативного массива от обычного в том что:
// в обычном массиве индексом выступает - число
// а в ассоциативном массиве - может быть как число, так и строка

// Лично мне они жутко напоминают объекты с парами ключ значение,
// автор говорит что ключ - это индекс в ассоциативном массиве - ок

// Ключами могут быть строки, выражения с пробелами и спецсимволами, 
// значениями, как и в обычно массиве, может быть всё что угодно, объект, другой массив, строка, число, функция

// Обращение к элементам массива

// Обращение к ключу массива осуществляется через точку*/
// console.log(accArray.d); // -> 1999

// //либо через [] если название ключа лежит в переменной
// let someVariable = 'c'; // присваиваю переменной ключ из массива accArray

// console.log(accArray[someVariable]); // -> ulrih выводится значение ключа 'c' из массива accArray

// // Присвоение элемента асс массива(объекта) (добавление) (push)
// accArray.e = 'yo'
// console.log(accArray); // -> {a: 10, b: 'ilia', c: 'ulrih', d: 1999, e: 'yo'} - добавляется в конец

// // Изменение значения объекта (ассМассива)

// accArray.a = 11;
// console.log(accArray); // -> {a: 11, b: 'ilia', c: 'ulrih', d: 1999, e: 'yo'}

// // Выведение объекта (ассМассива) на страницу
// // document.querySelector('#accArrayDivId').innerHTML = accArray;  -> [object Object] -> потому что этот тип данных выводится на страницу по другому
// let variableAccArray = '';
// for (let key in accArray) {
//     variableAccArray += key + ': ' + accArray[key] + ' '; // можем выводить и ключ и значение a: 11 b: ilia c: ulrih d: 1999 e: yo
// }
// document.querySelector('.accArrayDivId').innerHTML = variableAccArray; // variableAccArray += key; -> выводит все ключи из ассМассива abcde
// // если указать variableAccArray += accArray[key] -> 11iliaulrih1999yo выводит все значения ключей ассМассива ак Объекта

// // ключ повторяться не может
// // при повторении ключа вы перезатрете предыдущее значение
// // в таком объекте ассМассиве тоже могут храниться значения под индексом 0 1 2 3 и мы тоже можем к ним обращаться как к обычным элементам массива
// // такой ассмассив может быть двухмерным

// // Удаление значения элемента в массиве
// delete accArray.a     // было {a: 11, b: 'ilia', c: 'ulrih', d: 1999, e: 'yo'}
// console.log(accArray)// стало {b: 'ilia', c: 'ulrih', d: 1999, e: 'yo'}

// // ________________________________Получаем прогноз погоды по API_________________________________________________

// /* API - программный интерфейс, который предоставляет сайты, программы, для того, 
// чтобы мы имели возможность к ним обращаться.

// Пример данных приходящих с API

// https://api.openweathermap.org/data/2.5/weather?lat=44.34&lon=10.99&appid={API key}

// https://api.openweathermap.org - адрес сервера который предоставляет API

// data - адрес который отвечает за API

// 2.5 - версия API

// Далее идут параметры к которым мы обращаемся

// weather - url адрес

// ?lat=44.34&lon=10.99&appid={API key} - get запрос они есть на множестве сайтов,
// он идёт после знака вопроса, а дальше идут определенные параметры которые разделены знаком &

// ?
// lat=44.34
// &
// lon=10.99
// &
// appid={API key}

// ? - начало get запроса - пошли get параметры

// 1-й get параметр - lat=44.34

// 2-й get параметр - lon=10.99

// 3-й get параметр - appid={API key}

// get параметры используются для того чтобы генерировать запрос

// адресная строка это обычный get запрос, все что мы делаем через адресную строку 
// либо эмулируем через адресную строку это get запрос 

// нам нужно с помощью js посылать get запросы на другие сайты

// Интерфейс JS для работы с запросами - fetch

// Fetch API предоставляет интерфейс JavaScript для работы с запросами и ответами HTTP

// fetch() заключается в вызове этой функции с одним аргументом — строкой,
// содержащей путь к ресурсу, который вы хотите получить — которая возвращает promise, 
// содержащее ответ (объект Response).

// fetch делает запрос, запрос всегда асинхронен, то есть мы сделали запрос и нам нужно дождаться ответа

// .then - обертка над promise

// когда произойдет fetch запрос JS пошлет запрос на указанный в скобках адрес

// чтобы послать данный запрос добавляем api key в адресную строку - a91fbf77cf7066eeaf1931b137468b10

// .then будет выполнено тогда когда fetch отработает

// function (resp) получит результат ответа fetch и преобразует его в {return resp.json()}) в json формат

// то есть получит строку и преобразует в accмассив (объект)

// следующий then выполнится после этой функции function (data) и он получит уже обработанные данные 

// id=703448 kiev
// */ 

// // fetch('https://api.openweathermap.org/data/2.5/weather?q=London,uk&appid=a91fbf77cf7066eeaf1931b137468b10')
// //     .then(function (resp) {return resp.json()}) // convert data to json
// //     .then(function (data) {
// //         console.log(data);
// //         document.querySelector('.city-name').textContent = data.name
// //         document.querySelector('.temperature').innerHTML = Math.round(data.main.temp - 273) + '&deg;'
// //         document.querySelector('.weather').textContent = data.weather[0].description
// //         // https://media.istockphoto.com/vectors/snow-icon-vector-illustration-flat-design-vector-id1077590334?s=612x612
// //         document.querySelector('.features li').innerHTML = `<img width="50px" height="50px" src="https://media.istockphoto.com/vectors/${data.weather[0]['icon']}snow-icon-vector-illustration-flat-design-vector-id1077590334?s=612x612">`
// //     })
// //     .catch(function () {
// //         // catch any errors
// //     })

// //____________________________________ Set в Javascript _______________________________________

// // Создаём набор set с помощью нового объекта
// let newSet = new Set()
// newSet.add(1)    // -> Set(1) {1}
// newSet.add(2)
// newSet.add('ilia')
// /*При добавлении в set одинаковых данных проходит строгая! === проверка в том числе и по типу данных  и в случае если в set уже есть такие данные 
// то добавление - не происходит */
// console.log(newSet); /* -> 

// Set(3) {1, 2, 'ilia'}[[Entries]]
// 0: 1
// 1: 2
// 2: "ilia"
// size: 3
// [[Prototype]]: Set */

// // console.log(newSet[0]); -> нет результата потому что работаем с Set

// console.log(newSet.size); // -> 3 количество элементов положенных в set

// /*При добавлении в set одинаковых данных проходит строгая! === проверка в том числе и по типу данных и в случае если в set уже есть такие данные 
// то добавление - не происходит 

// Поэтому если мы добавляем массив внутрь set(набора) то мы получаем коллекцию уникальных элементов
// но при этом если мы изменим тип данных с числа на строку, то элемент добавится в набор*/

// // newSet.clear();
// // console.log(newSet) // -> Set(0)

// // delete - позволяет создать элементы для данного набора
// // newSet.delete(2)
// // console.log(newSet) // -> Set(2) {1, 'ilia'} // -> удаляет элемент

// // has - проверяем наличие есть в наборе или нет
// console.log(newSet.has(2)) // -> true
// console.log(newSet.has('2')) // -> false

// // для перебора данного объекта set используется цикл for of
// for (let item of newSet) {
//     console.log(item)
// }
// /* ->
// 1
// 2
// ilia
// */

// // Использование наборов на практике 
// // допустим у нас есть вот такой большой массив с разными данными наша задача найти в нём уникальные элементы
// let array_7 = [1,2,3,4,5,'hello', 123, 43,]
// /* раньше мы заводили новый массив перебирали элементы и добавляли подходящие, теперь*/

// let array_8 = new Set(array_7) 
// console.log(array_8) // -> Set(8) {1, 2, 3, 4, 5, …}
// console.log(array_8.size) // -> 8

// // преобразуем set в массив

// let array_9 = Array.from(array_8)
// console.log(array_9) // -> (8) [1, 2, 3, 4, 5, 'hello', 123, 43]

// // теперь мы можем взаимодействовать с set набором как с массивом
// console.log(array_9[2]) // -> 3

// //_______________________________________Цикл for of и сравнение с for, for in__________________________________

// let array_10 = [4,7,9];

// // for выводит значения

// for (let i = 0; i < array_10.length; i++) {
//     console.log(array_10[i]) // -> 4 7 9
// }

// // for in выводит ключи

// for (let key in array_10) {
//     console.log(key) // - > 0 1 2
// }

// // for of - выводит значения
// /* for (переменная of объект)
// На каждом шаге итерации переменной присваивается значение нового свойства объекта*/

// for (let key of array_10) {
//     console.log(key) // - > 4 7 9
// }

// let divS = document.getElementsByClassName('divid_1')

// console.log(array_10) // -> (3) [4, 7, 9]
// console.log(divS)     // -> HTMLCollection(3) [div.divid_1, div.divid_1, div.divid_1]
// // HTMLCollection можно узнать длину HTMLCollection.length можно обратиться по индексу HTMLCollection[0]

// // переберем коллекцию с помощью цикла for

// for (let i = 0; i < divS.length;  i++) {
//     console.log(divS[i]) // -> <div class="divid_1">1</div><div class="divid_1">2</div><div class="divid_1">3</div>
// }

// // переберем коллекцию с помощью цикла for in

// for (let key in divS) {
//     console.log(key) 
// }
// /* ->

// 0
// 1
// 2
// length
// item
// namedItem 

// то есть for in начал перебирать свойства объекта а не только сами вложенные элементы поэтому for in с коллекциями не работает
// */

// for (let key of divS) {
//     console.log(key) // - > как у for i
// }

// /* 
// <div class="divid_1">1</div>
// <div class="divid_1">2</div>
// <div class="divid_1">3</div>

// получаю Nodelist через querySelector
// */
// let divZ = document.querySelectorAll('.divid_1')

// console.log(divZ) /* 
// NodeList(3) [div.divid_1, div.divid_1, div.divid_1]
// 0: div.divid_1
// 1: div.divid_1
// 2: div.divid_1
// length: 3
// [[Prototype]]: NodeList

// проверяем первый цикл for i для NodeList
// */

// for (let i = 0; i < divZ.length;  i++) {
//     console.log(divZ[i]) // -> 
// }
// /* ->
// <div class="divid_1">1</div>
// <div class="divid_1">2</div>
// <div class="divid_1">3</div>
// */

// // for in для NodeList

// for (let key in divZ) {
//     console.log(divZ[key]) 
// }

// /* Начался перебор свойств объекта

// ƒ entries() { [native code] }
// ƒ keys() { [native code] }
// ƒ values() { [native code] }
// ƒ forEach() { [native code] }
// 3
// ƒ item() { [native code] }

// */

// // for of для Nodelist

// for (let key of divZ) {
//     console.log(key) 
// }

// /* 
// <div class="divid_1">1</div>
// <div class="divid_1">2</div>
// <div class="divid_1">3</div>
// */

// //____________________________________Map Filter_______________________________________________

// /* Метод map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.

// callback
// Функция, вызываемая для каждого элемента массива arr. Каждый раз, когда callback выполняется, 
// возвращаемое значение добавляется в new_array.

// currentValue
// Текущий обрабатываемый элемент массива.

// indexНеобязательный
// Индекс текущего обрабатываемого элемента в массиве.

// arrayНеобязательный
// Массив, по которому осуществляется проход.

// Возвращаемое значение
// Новый массив, где каждый элемент является результатом callback функции.

// Метод map вызывает переданную функцию callback один раз для каждого элемента,
// в порядке их появления и конструирует новый массив из результатов её вызова.
// Функция callback вызывается только для индексов массива, имеющих присвоенные значения, включая undefined

// Метод map не изменяет массив, для которого он был вызван (хотя функция callback может это делать).

// const numbers = [1, 4, 9];
// const roots = numbers.map(Math.sqrt);
// теперь roots равен [1, 2, 3], а numbers всё ещё равен [1, 4, 9]

// const map = Array.prototype.map;
// const charCodes = map.call('Hello World', (x) => x.charCodeAt(0));
// теперь charCodes равен [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]

// const elems = document.querySelectorAll('select option:checked');
// const values = Array.prototype.map.call(elems, ({ value }) => value);*/

// let array_11 = [4, 5, 12, 200, 1, 0, -2];

// // map будет применяться к каждому элементу данного массива 
// // и результат применения будет помещен в массив array_12

// let array_12 = array_11.map(function(currentValue, huindex, ){ 

//     console.log(currentValue)

//     return currentValue*5
// })
// console.log(array_12) /* ->
// 4
// 5
// 12
// 200
// 1
// 0
// -2 -> вывод всех элементов массива array_11
// Array(7)0: undefined1: undefined2: undefined3: undefined4: undefined5: undefined6: undefinedlength: 7[[Prototype]]: Array(0)

// Так как функция ничего не возвращает но была вызвана много много раз, то она возвращает undefined и 
// результат undefined помещается в массив array_12

// если мы добавим return currentValue то функция будет возвращать все элементы и новый массив будет 
// полной копией массива array_11 - > (7) [4, 5, 12, 200, 1, 0, -2]

// то есть то что возвратит функция в методе map попадет в новый массив
// если функция ничего не возвратит, то будет массив из undefined

// вместо currentValue можно возвращать и индекс и пользоваться методом map по индексу -> (7) [0, 1, 2, 3, 4, 5, 6]

// Задача: умножить каждый элемент массива на 5

// для этого у return пишем - return currentValue*5 -> (7) [20, 25, 60, 1000, 5, 0, -10]

// функция применяется столько раз сколько элементов есть в исходном массиве,
// столько же элементов будет в новом массиве

// функция map хороша когда нужно перебрать каждый элемент в массиве совершить над ним какие-либо действия и потом
// возвратить новый массив

// упрощаем конструкцию к виду стрелочной функции

// let array_12 = array_11.map((currentValue, huindex, ) => { 
//     return currentValue*5
// })

// упрощаем еще сильнее 

// let array_12 = array_11.map(currentValue => currentValue*5 
// */

// let array_13 = array_11.map(huyarentValue => huyarentValue*5) // -> (7) [20, 25, 60, 1000, 5, 0, -10]

// // _______ FILTER _______

// /* Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.

// const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

// const result = words.filter(word => word.length > 6);

// console.log(result);
// expected output: Array ["exuberant", "destruction", "present"]

// // Стрелочная функция
// filter((element) => { ... } )
// filter((element, index) => { ... } )
// filter((element, index, array) => { ... } )

// // Колбэк-функция
// filter(callbackFn)
// filter(callbackFn, thisArg)

// // Встроенная колбэк-функция
// filter(function callbackFn(element) { ... })
// filter(function callbackFn(element, index) { ... })
// filter(function callbackFn(element, index, array){ ... })
// filter(function callbackFn(element, index, array) { ... }, thisArg)

// callbackFn
// Функция-предикат, которая будет вызвана для проверки каждого элемента массива. Если функция возвращает true, то элемент остаётся в массиве, если false, то удаляется.

// Принимает три аргумента

// element
// Текущий обрабатываемый элемент в массиве.

// indexНеобязательный
// Индекс текущего обрабатываемого элемента в массиве.

// arrayНеобязательный
// Обрабатываемый массив, на котором был вызван метод filter().

// thisArgНеобязательный
// Значение, используемое в качестве this при вызове колбэк-функции callbackFn.

// Возвращаемое значение
// Вернётся новый массив с элементами, которые прошли проверку. 
// Если ни один элемент не прошёл проверку, то будет возвращён пустой массив.

// Метод filter() вызывает переданную функцию callback один раз для каждого элемента, 
// присутствующего в массиве, и создаёт новый массив со всеми значениями, 
// для которых функция callback вернула значение, которое может быть приведено к true

// Функция callback вызывается с тремя аргументами:

// значение элемента;
// индекс элемента;
// массив, по которому осуществляется проход.

// Метод filter() не изменяет массив, для которого он был вызван.

// callback здесь называют функцию которая передается внутрь как условие

// c filter я могу сам решать что попадет в новый массив
// */
// let array_14 = array_11.filter(function(item, index) {
//     return true
// })

// console.log(array_14) // -> return true - > копия массива array_11 return false -> []

// // отбираем из array_11 только четные элементы

// let array_15 = array_11.filter(function(item, index) {
//     if (item%2===0) {
//         return true
//     }
// })
// console.log(array_15) // -> (5) [4, 12, 200, 0, -2]

// // только элементы >0

// let array_16 = array_11.filter(function(item, index) {
//     if (item>0) {
//         return true
//     }
// })
// console.log(array_16) // -> (5) [4, 5, 12, 200, 1]

// // map и filter работают immutable

// //______________________________ Split Join ForEach ___________________________________

/* Метод split() разбивает объект String на массив строк путём разделения строки указанной подстрокой.

Синтаксис
str.split([separator[, limit]])

Параметры
separator
Необязательный параметр. Указывает символы, используемые в качестве разделителя внутри строки. 
Параметр separator может быть как строкой, так и регулярным выражением. 
Если параметр опущен, возвращённый массив будет содержать один элемент со всей строкой. 
Если параметр равен пустой строке, строка str будет преобразована в массив символов.

limit
Необязательный параметр. Целое число, определяющее ограничение на количество найденных подстрок.
 Метод split() всё равно разделяет строку на каждом сопоставлении с разделителем separator, 
 но обрезает возвращаемый массив так, чтобы он содержал не более limit элементов.
 
 Описание
Метод split() возвращает новый массив.

Если разделитель separator найден, он удаляется из строки, а подстроки возвращаются в массиве. 
Если разделитель опущен, массив будет содержать только один элемент, состоящий из всей строки. 
Если разделитель является пустой строкой, строка str будет преобразована в массив символов.

Если разделитель является регулярным выражением, содержащим подгруппы, 
то каждый раз при сопоставлении с разделителем, результаты (включая те, что не определены) 
захвата подгруппы будут помещаться внутрь выходного массива. 
Однако, не все браузеры поддерживают эту возможность.

var tempestString = 'И как хорош тот новый мир, где есть такие люди!';
var monthString = 'Янв,Фев,Мар,Апр,Май,Июн,Июл,Авг,Сен,Окт,Ноя,Дек';

var space = ' ';
var comma = ',';

splitString(tempestString, space);
splitString(tempestString);
splitString(monthString, comma);
Copy to Clipboard
Пример сгенерирует следующий вывод:

Оригинальная строка: "И как хорош тот новый мир, где есть такие люди!"
Разделитель: " "
Массив содержит 10 элементов: И / как / хорош / тот / новый / мир, / где / есть / такие / люди!

Оригинальная строка: "И как хорош тот новый мир, где есть такие люди!"
Разделитель: "undefined"
Массив содержит 1 элементов: И как хорош тот новый мир, где есть такие люди!

Оригинальная строка: "Янв,Фев,Мар,Апр,Май,Июн,Июл,Авг,Сен,Окт,Ноя,Дек"
Разделитель: ","
Массив содержит 12 элементов: Янв / Фев / Мар / Апр / Май / Июн / Июл / Авг / Сен / Окт / Ноя / Дек

split()
null*/

let string_1 = 'hi, ilia, artem'
console.log(string_1.split()) // -> ['hi, ilia, artem'] 0: "hi, ilia, artem" length: 1
console.log(string_1.split(' ')) // -> (3) ['hi,', 'ilia,', 'artem'] 0: "hi,"1: "ilia,": "artem"length: 3
console.log(string_1.split('')) // -> (15) ['h', 'i', ',', ' ', 'i', 'l', 'i', 'a', ',', ' ', 'a', 'r', 't', 'e', 'm']
console.log(string_1.split(',')) // -> (3) ['hi', ' ilia', ' artem'] 0: "hi"1: "_ilia"2: "_artem"length: 3

// Join обратный split

/* Метод join() объединяет все элементы массива (или массивоподобного объекта) в строку.

const elements = ['Fire', 'Air', 'Water'];

console.log(elements.join());
// expected output: "Fire,Air,Water"

console.log(elements.join(''));
// expected output: "FireAirWater"

console.log(elements.join('-'));
// expected output: "Fire-Air-Water"

Синтаксис
arr.join([separator])

Возвращаемое значение
Строка, содержащая все элементы массива. Если arr.length == 0, то будет возвращена пустая строка.

Описание
Преобразует все элементы массива в строки и объединяет их в одну большую строку. 
Элемент массива с типом undefined или null преобразуется в пустую строку.*/

let array_14 = [1, 2, 3]
console.log(array_14.join()) // -> 1,2,3
console.log(array_14.join('')) // -> 123
console.log(array_14.join(' ')) // -> 1 2 3
console.log(array_14.join(',')) // -> 1,2,3

// ForEach это метод который применяет функцию один раз к указанному элементу

/* Метод forEach() выполняет указанную функцию один раз для каждого элемента в массиве.

Параметры
callback
Функция, которая будет вызвана для каждого элемента массива. Она принимает от одного до трёх аргументов:

currentValue
Текущий обрабатываемый элемент в массиве.

indexНеобязательный
Индекс текущего обрабатываемого элемента в массиве.

arrayНеобязательный
Массив, по которому осуществляется проход.

thisArg
Необязательный параметр. Значение, используемое в качестве this при вызове функции callback.

Возвращаемое значение
undefined.

В отличие от map и filter не возвращает нового массива
*/

array_14.forEach(function (elem, index) {
    console.log(elem * 2) //-> 1 2 3
    console.log(index)
    console.log('---')
})
/* 
1
0
---
2
1
---
3
2
---
*/


// ____________________________________ События мыши ______________________________________

/* event - это объект который содержит всю информацию о событии 
можно написать и просто e

внутри event есть информация о других нажатых клавишых в момент события
*/

document.querySelector('.divclassforMouse_1').onclick = function (event) {
    console.log(event) // -> PointerEvent {isTrusted: true, pointerId: 1, width: 1, height: 1, pressure: 0, …}
    console.log('click_1')
}

document.querySelector('.divclassforMouse_2').onclick = function () {
    console.log('click_2')
}

// double click


document.querySelector('.divclassforMouse_3').ondblclick = () => {
    console.log('click_3')
}

// oncontext menu right button of the mouse at your right hand dude

document.querySelector('.divclassforMouse_4').oncontextmenu = () => {
    console.log('right button')
    return false // - отрубает контексное меню на элементе
}

// onmousemove

document.querySelector('.divclassforMouse_5').onmousemove = () => {
    console.log('onmousemove')
}

// увеличиваем ширину дивки c помощью onmousemove

let mousewide = 50;

document.querySelector('.divclassforMouse_5').onmousemove = () => {
    document.querySelector('.divclassforMouse_5').style.width = mousewide + 'px';
    mousewide++
}

// увеличиваем высоту дивки c помощью onmousemove

let mouseheight = 50;

document.querySelector('.divclassforMouse_6').onmousemove = () => {
    document.querySelector('.divclassforMouse_6').style.height = mouseheight + 'px';
    mouseheight++
}

// onmouseenter красим в красный при наведении (hover эффект)

document.querySelector('.divclassforMouse_6').onmouseenter = () => {
    document.querySelector('.divclassforMouse_6').style.background = 'red';
    console.log(1)
}

// onmouseleave меняет цвет при уводе мыши с элемента

document.querySelector('.divclassforMouse_6').onmouseleave = () => {
    document.querySelector('.divclassforMouse_6').style.background = 'blue';
}

// onmousedown меняет цвет элемента пока я держу клавишу нажатой
// как только я отжал клавишу и увел мышь за пределы элемента - перестает работать

document.querySelector('.divclassforMouse_6').onmousedown = () => {
    document.querySelector('.divclassforMouse_6').style.background = 'orange';
}

// onmouseup меняет цвет элемента при отпуске клавиши

document.querySelector('.divclassforMouse_6').onmouseup = () => {
    document.querySelector('.divclassforMouse_6').style.background = 'pink';
}

// Работаем с тегом progress

let p = 10; // по значению value progress
document.querySelector('.buttonProgressClass').onclick = function () {
    p++
    document.querySelector('.progress').value = p;
}

// __________________________________________События клавиатуры_____________________________________________

/* На input есть несколько основных событий:

onchange - сработает когда input потеряет фокус
oninput - сработает при любом изменении

их аналог для работы в разных браузерах

key - 
keyCode -

*/

document.querySelector('.classInput_1').oninput = (event) => {
    console.log(event)
}

/* -> InputEvent {isTrusted: true, data: '2', isComposing: false, inputType: 'insertText', dataTransfer: null, …}*/

// на oninput вешаем событие onkeypress 

document.querySelector('.classInput_2').onkeypress = (event) => {
    console.log('charCode: ' + event.charCode)
    console.log('code: ' + event.code)
    console.log('key: ' + event.key)
    console.log('keyCode: ' + event.keyCode)
    console.log(event)
}

/* 

-> KeyboardEvent {isTrusted: true, key: '2', code: 'Digit2', location: 0, ctrlKey: false, …} 

4 важных свойства при onkeypress: (можно найти если нажать на галочку рядом с выводом в консоли)

charCode: 113
code: KeyQ
key: q
keyCode: 113


почитать информацию об этих событиях и свойствах

одни и те же буквы с разными регистрами выдают разные данные

charCode: 81
code: KeyQ
key: Q
keyCode: 81

увеличивается на 32 

charCode: 113
code: KeyQ
key: q
keyCode: 113

пробуем кириллицу

charCode: 1081
code: KeyQ
key: й
keyCode: 1081

увеличивается на 32

charCode: 1049
code: KeyQ
key: Й
keyCode: 1049


цифры

charCode: 48
code: Digit0
key: 0
keyCode: 48

charCode: 57
code: Digit9
key: 9
keyCode: 57

Если charCode или keyCode от 48 до 57 то речь идёт о цифре

При нажатии:
вверх вниз вправо влево CTRL ALT SHIFT Capslock - ничего не отображается
на доп клавиатуре при отключенном Numlock так же ничего не работает

onkeypress - работает для букв и некоторых вспомогательных клавиш

onkeypress можно разбить на 2 действия

1-е действие: нажали клавишу
2-е действие: отпустили клавишу

*/

// onkeydown - фиксируется когда клавиша уже нажата, но еще не отпущена

document.querySelector('.classInput_3').onkeydown = (event) => {
    console.log('keydown')
    console.log('charCode: ' + event.charCode)
    console.log('code: ' + event.code)
    console.log('key: ' + event.key)
    console.log('keyCode: ' + event.keyCode)
    console.log(event)
}

/* 

keydown в отличие от keypress - charCode нет значения

charCode: 0
code: KeyQ
key: q
keyCode: 81
KeyboardEvent {isTrusted: true, key: 'q', code: 'KeyQ', location: 0, ctrlKey: false, …}

keydown в отличие от keypress - charCode нет значения
но при этом в keydown работают - вверх вниз вправо влево CTRL ALT SHIFT Capslock,
на доп клавиатуре при отключенном Numlock - работает

keydown
charCode: 0
code: ControlLeft
key: Control
keyCode: 17
KeyboardEvent {isTrusted: true, key: 'Control', code: 'ControlLeft', location: 1, ctrlKey: true, …}

keydown
charCode: 0
code: ArrowUp
key: ArrowUp
keyCode: 38
KeyboardEvent {isTrusted: true, key: 'ArrowUp', code: 'ArrowUp', location: 0, ctrlKey: false, …}

*/

// Добавляем Capslock через keydown (клавиша в момент нажатися)

document.querySelector('.classInput_4').onkeydown = (event) => {
    if (event.key === 'CapsLock') {
        document.querySelector('.classInput_5').checked = true;
    }
    else {
        document.querySelector('.classInput_5').checked = false;
    }
}

// Добавляем Capslock через keyup (клавиша в момент отпускания) реагирует на комбинационные клавишы 

document.querySelector('.classInput_4').onkeyup = (event) => {
    console.log('keyup')
}

// last example

document.querySelector('.classInput_6').onkeypress = (event) => {
    const a = { // -> переназначил клавишы и q на w
        q: 'w',
        w: 'e'
    }
    document.querySelector('.classInput_6').value += a[event.key]
    return false
}

// ________________________События JavaScript на iPhone и Android телефонах ______________________________

// onclick на айфоне сработает от тапа, на андроиде срабатывает от тапа

let forBlocks_1 = 0

document.querySelector('.block_1').onclick = function () {
    forBlocks_1++
    document.querySelector('.out_1').innerHTML = 'click ' + forBlocks_1
}

//doubleclick на айфоне сработает от даблтапа  на андроиде срабатывает от даблтапа

let forBlocks_2 = 0

document.querySelector('.block_2').ondblclick = function () {
    forBlocks_2++
    document.querySelector('.out_2').innerHTML = 'double_click ' + forBlocks_2
}

//mousemove на айфоне реагирует если провести по элементу пальцем на андроиде тоже

let forBlocks_3 = 0

document.querySelector('.block_3').onmousemove = function () {
    forBlocks_3++
    document.querySelector('.out_3').innerHTML = 'mousemove' + forBlocks_3
}

//mouseenter на айфоне не сработало на андроиде после движения тапа внутри блока сработало

let forBlocks_4 = 0

document.querySelector('.block_4').onmouseenter = function () {
    forBlocks_4++
    document.querySelector('.out_4').innerHTML = 'mouseenter' + forBlocks_4
}

//mouseleave на айфоне не работает на андроиде после выхода из блока и тапа по блоку срабатывает

let forBlocks_5 = 0

document.querySelector('.block_5').onmouseleave = function () {
    forBlocks_5++
    document.querySelector('.out_5').innerHTML = 'mouseleave' + forBlocks_5
}

// mouse enter и mouse leave работают по разному
// на телефоне при добавлении события click дублировать его с помощью события touch

//____________________________________ Local Storage _______________________________________________

localStorage.setItem('data', 5); // -> добавление данных в Local Storage

console.log(localStorage.getItem('data')) // -> возврат данных -> 5

// создадим массив и запишем его в local storage

const array_15 = [1, 2, 3]

// задаем имя ключа key и его значение value

localStorage.setItem('array_15', JSON.stringify(array_15)) // -> array_15	[1,2,3] Трансформирую массив в строку

// получаем заданое значение в переменную array_16

let array_16 = localStorage.getItem('array_15')

array_16 = localStorage.getItem('array_15')

array_16 = JSON.parse(array_16) // после извлечения из localStorage я его преобразовываю из строки обратно

console.log(array_16) // -> (3) [1, 2, 3]
console.log(array_16[0]) // -> 1
console.log(array_16[1]) // -> 2              то есть тип получаемых данных - string а не number

// узнаем тип данных полученных значений

console.log(typeof array_16) // -> object

/* когда мы сохраняем массив в local storage он преобразовывается в строку вместе с , 
если мы хотим корректно сохранять массив вы должны получая его обратно применить преобразование в json строку
и обратно

localStorage.setItem('array_15', JSON.stringify(array_15))

array_16 = JSON.parse(array_16)


Та же работа с асс массивом объектом */
const array_17 = {
    ilia: 11,
    k: 2,
    4: 'danila'
}
localStorage.setItem('array_17', JSON.stringify(array_17))
let array_18 = localStorage.getItem('array_17')

array_18 = localStorage.getItem('array_17')

array_18 = JSON.parse(array_18)

console.log(array_18) // -> (3) [1, 2, 3]
console.log(typeof array_18)

/*
{4: 'danila', ilia: 11, k: 2}4: "danila"ilia: 11k: 2[[Prototype]]: Object
*/

// мы можем отслеживать события add even listener

// по идее когда изменяется local storage мы можем констатировать факт изменения данного события
// это отслеживатеся если Localstorage был введен на других страницах в данном контексте

window.addEventListener('storage', (e) => {
    console.log('change') // -> 
    document.querySelector('.out1html').textContent = localStorage.getItem('b1')
});

/* Таким образом я получаю возможность манипулировать через local storage разными страницами
пользователь пользователь на одной странцие добавил в корзину - на другой корхина обновилась
удалил на одной странице корзину, очистил на второй она тоже очистилась

мы можем очищать locwq*/

//________________________Работаем с POST и GET. Postman_________________
// Знакомство с видами запросов

/* Как работает браузер:

Когда я набираю какой-то адрес нажимаю enter браузер формирует запрос куда вкладывает
введенный мной адрес дополняет его служебной информацией и отсылает на сервер
спустя цепочку промежуточных серверов данный запрос будет переправлен на сервер
где хостится сайт с нашим введенным адресом, системы бэк энда сервера, посмотрят наш адрес
и если этот адрес есть, он доступен и бэкенд позволяет отдать по нему информацию
будет выделен какой-то блок информации который и будет отослан на браузер.

Браузер его примет, это будет обычный html файл в котором указаны ссылки на другие файлы
и когда браузер будет разбирать данный файл и найдет ссылки на другие браузеры
как обычный html он их загрузит.

метод Get - если запрашиваешь через адресную строку

Методы для отправки и приема информации

Есть соглашение о том, что когда мы запрашиваем информацию методом Get
мы просто читаем информацию, нам присылают ее готовую, мы ничего не изменяем
на сервере.

Если мы несколько раз сделаем один и тот же Get мы получим всегда один и тот же ответ
то есть по методу get информацию не посылаем

В запросе всегда есть набор частной информации в частности заголовок содержит Content-Type то есть что я запрашиваю.

то есть get или пост это всего лишь Запрос который имеет свое содержимое, тело Запроса и т.д.,
и во вкладке Network видно все документы запроса
при клике на файл в разделе Network/Name появятся вкладки Headers Preview Response Initiatir Timing
Чтобы узнать что нам ответил сервер у нас есть - Response

При клике на вкладку Response мы видим чем нам ответил сервер
если речь идет о html документе в Запросе get или post то мы увидим в Response html код документа

И, так как, в этом файле будут подключения сторонних файлов
то браузер когда принял этот код на стороне сервера у него есть сам html файл

браузер по Запросу в URL адресе сделал запрос на сервер, сервер - отдал этот html файл
этот html файл был принят браузером, разобран и показан на странице браузера

так как в ходе разбора файла браузер натолкнулся на дополнительные ссылки на другие документы
то данные документы были Запрошены через URL страницу (указано в Headers) методом get


таким образом в ходе загрузки одного url адреса браузер совершает несколько подключений
и в результате этих подключений у нас были получены определенные файлы
которые браузер сформировал и вывел
все файлы мы запрашивали через URL страницу простым методом get

Метод GET это способ обращения к серверу которому мы передаем информацию через
адресную строку

В браузере при переходе внутри сайта по ссылкам меняется url адрес то есть мы даем команду браузеру
послать запрос и получить ответ на данный url адрес

Сначала через метод get запрашиваем главную страницу запрос идет через url адрес
методом get мы просто просим показать получить информацию в ходе разборки этой главной страницы документа
загружаются другие вспомогательные файлы

Сам по себе Get запрос может содержать параметры

https://ru.wikipedia.org/wiki/The_Slim_Shady_LP?veaction=edit

https://ru.wikipedia.org/wiki/The_Slim_Shady_LP - адрес

? - разделитель отделяет адрес от параметров

veaction=edit - список параметров, query строка, строка - запроса, иногда называется get строкой

veaction - параметр

= - равен

edit - значению
--------------------------------------------

Метод Get предполагает что мы всегда получаем одну и ту же информацию

Метод Get легко передать так как все параметры запроса дублируются в адресной строке
поэтому ссылку можно скопировать и он перейдет на ту же самую страницу что и вы

обращаясь к одному и тому же файлу изменяя параметры в адресной строке можно получать разный вывод на странице браузера

но работать в адресной строке не удобно get запросы еще можно
post запросы слать сложнее
*/

// как удобно посылать get запросы и post запросы на сервер
// как их тестировать и работать с ними
// на начальном этапе до написания кода

/* Метод get не подходит для передачи данных таких как логин и пароль
потому что отображается в адресной строке

длина адресной строки ограничена и ограничен объём передаваемой информации

Когда мы запрашиваем метод get мы просто запрашиваем информацию
нам не нужно большой объем информации отправлять на сервер
нам нужно передать только управляющие параметры

но в некоторых случаях нам нужно изменять содержимое сервера
Если у нас есть большое количество информации которое явное превышает объем адресной строки
и вбивая эту информацию нажимая сохранить я планирую изменить состояние сервера и его базы данных

Для объемных запросов для тех запросов которые изменяют состояние сервера состояние данных
придумали разные другие запросы

GET POST PUT DELETE

PATCH COPY HEAD OPTIONS LINK UNLINK PURGE LOCK UNLOCK PROPFIND VIEW

Метод POST отличается от метода get тем что он не дублирует информацию в адресной строке
мы можем в HTML документе в теге Form добавить метод POST




Метод GET который дублируется в адресной строке, подходит для фильтров, для закладок и для обмена ссылками,
но он дублирует все параметры в адресной строке он простой его можно послать с помощью обычного браузера
но если посылать логин и пароль он не подходит, так же он не подходит когда много информации

Метод POST который посылает на сервер достаточно много информации но для того чтобы
его послать нужно либо сформировать форму либо воспользоваться специальной программой */

// ________________________ AJAX учимся посылать GET, POST запросы ____________________
//_________________________ Как работать с GET запросами ______________________________
/* AJAX - асинхронный JS и XML это методы которые позволяют в фоновом режиме послать запрос на сервер
с помощью JS получить результат ответ от сервера и работать с ним

XMLHTTPrequest это объект позволяет  нам посылать запросы с помощью JS на сервер

XMLHttpRequest – это встроенный в браузер объект, 
который даёт возможность делать HTTP-запросы к серверу без перезагрузки страницы.

XMLHttpRequest имеет два режима работы: синхронный и асинхронный.

создание нового экземпляра класса XMLHttpRequest()

XMLHttpRequest() - класс

когда мы создаем на основе класса XMLHttpRequest() new синтаксис то let xhr будет называться объектом

let xhr = new XMLHttpRequest(); // у конструктора нет аргументов
*/
// объект который будет экземпляром
let xhttp = new XMLHttpRequest() // - создал запрос
// xhttp - это объект, этот объект может посылать запросы на различные ресурсы
/* 


onreadystatechange - событие. функция которая вызывается всякий раз когда после readystate меняет свое значение

Когда я буду посылать запрос состояние запроса будет меняться и за изменения состояния будет отвечать
onreadystatechange


есть 2 атрибута onredaystatechange и readystate по ним я могу отслеживать что происходит с моими запросами
и получать какую-то обратную связь

по событию onreadystatechange мы будем запускать следущую функцию function () {}

Когда у меня будет изменяться состояние объекта мне надо понимать состояние моего xhttp объекта
мне нужно понимать что с ним происходит был ли удачен запрос на сервер был ли неудачен
отследить состояние запроса я могу по кодам 

Два кода this.readyState он может принимать числовые значения

0 - unsent только создан
1 - opened вызван
2 - headers_received вызван метод получены заголовки и код ответа
3 - loagind загрузка; если значение responseType равно 'text' или пустой строке то responseText содержит частичные данные
4 - done - операция завершена все данные получены

если прошли все стадии запроса и отработал запрос корректно то мы получим 4
то есть операция завершена все данные получены

if (this.readyState == 4) - этой проверки недостаточно нужно посмотреть понятие статуса

статус - статус ответа на запрос. сам запрос может пройти мы можем получить данные но
но сервер нам может ответить разными вариациями, 1 такого ресурса нет, хотя запрос пришел
доступ запрещен и так далее

поэтому практически всегда помимо readystate проверяют еще и статус this.status

что это за херня?
1. я создал новый объект let xhttp
2. я прописал что когда будеть меняться состояние этого объекта xhttp.onreadystatechange
нужно вызывать вот эту функцию function () {
    if (this.readyState == 4 && this.status == 200) {

    }
}
состояние объекта будет меняться 
когда полностью весь запрос будет завершен
readyState станет равен 4 this.readyState == 4
и после этого я проверю действительно ли ответ сервера составляет код 200

в этом случая буду вызывать функцию myFunction() и буду передавать ей ответ
ответ формируется this.responseText
response - это все тело сущности запроса.
responseText - Ответ на запрос в виде строки или null в случае если запрос не успешен
или ответ еще не получен

data - какой-то параметр
*/
let a = 0
xhttp.onreadystatechange = function () {
    if (this.readyState == 4 && this.status == 200) {
        myFunction(this.responseText)
    }
} // -> на изменение состояния поставил функцию myFunction

// отправляю запрос
// для отпраки запроса 
/* 

xhttp.open() этот метод позволяет мне начать отправку запроса первый параметр который
я должен указать это способ отправки метод xhttp.open("GET") второй параметр
я должен указать куда я буду отправлять этот запрос xhttp.open("GET", "http://getpost.itgid.info/index2.php")
третий параметр не является обязательным
третий параметр это либо true либо false этот параметр определяет как выполняется запрос синхронно или асинхронно
open() позволяет запустить сам запрос
этот запрос требует 2 параметра способ запуска и куда посылать запрос

синхронно запускать запрос не рекомендуется

мы открыли запрос и теперь необходимо его послать
*/
// xhttp.open("GET", "https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=1", true)
// xhttp.send() // - Не ввели ключ авторизации. Ключ доступен в чате курса.

// function myFunction(data) {
//     a = data
//     console.log(data)
// }

// console.log(a) // -> 0
/*

CORS -Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP -заголовки,
чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене),
отличном от того, что сайт использует в данный момент.

когда вы пытаетесь послать запрос со своего сайта на чужой сайт и получить информацию

auth=zhrgB3DxC8LoG7Gcilzg&action=1 - прописываем параметры get строкой

JS разбирая файл создаем объект:

let xhttp = new XMLHttpRequest()

конфигурирует состояние объекта:

xhttp.onreadystatechange = function () {
    if (this.readyState == 4 && this.status == 200) {
        myFunction(this.responseText)
    }
}

конфигурирует сам объект:

xhttp.open("GET", "https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=1", true)

посылает его:

xhttp.send()

не дожидаясь окончания продолжает выполнять код

выполняет console.log("step1") - который выполнится значительно раньше чем пришел ответ

а это значит что если я создам переменную куда хочу записать данные пришедшие с сервера
let a = 0;
и начну ей манипулировать

в callback функции я записываю эти данные ввожу в консоль
function myFunction(data) {
     a = (data)
    console.log(data)

}

console.log(a) -> 0

Все коды которые написаны ниже будут считать что a = 0 поскольку к этому моменту когда выполняется
console.log(a)

функция
xhttp.open("GET", "https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=1", true)
xhttp.send()
function myFunction(data) {
     a = (data)
    console.log(data)

} - еще не была запущена
то есть запрос еще работал и попытки манипулировать этой переменной в коде ниже
за пределами функции
function myFunction(data) {
     a = (data)
    console.log(data) // - hello
}
обречены на провал поскольку JS еще не получил ответа на запрос
поэтому все манипуляции с переменной с data нужно производить в пределах этой функии

function myFunction(data) {
     a = (data)
    console.log(data) // - hello
} - выполняется спуся какое-то время задержка зависит от сервера от сложности
вычислений от скорости сети
и если вы планируете манипулировать данными за ее пределами у вас не получится
вы должны вначале дождать ответа a = (data) и только потом выполнить манипуляцию    console.log(data)
function myFunction(data) {
     a = (data)
    console.log(data) // <- поэтому все манипуляции нужно прописывать здесь
}
*/
// ___________Делаем то же самое с POST запросом__________________

/* 

Создаю xhttp реквест:
let xhttp2 = new XMLHttpRequest

Конфигурирую http запрос

xhttp2.onreadystatechange // то есть когда будет менять свое состяние, то выполнять = function() {
    поменял состяние
    if (this.readyState == 4 // пришел ответ после изм состояния && this.status == 200 ответ 200 значит можно написать функцию) {
        myFunction2(this.responseText)
    }
    если нет в зависимости от состояни и от статуса можно запустить проверку на ошибки
    можно запусить обработчик ошибок и так далее
}

итак мне необходимо послать запрос посылание запроса осуществляется абсолютно аналогично

xhttp2.open("POST", "https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=1", true)
xhttp2.send()

мы должны выполнить конфигурацию заголовков запроса
конфигурация заголовков запроса показывает как отправлять данные
какие данные как их обрабатывать и так далее
поэтому я пишу то что не писал для GET запроса

я говорю чтобы данный запрос отсылал данные как это делает обычная форма

xhttp2.setRequestHeader("Content-type", "application/x-www-form-urlencoded")

и соответственно

xhttp2

xhttp2.send('') 

теперь нужно указать какие параметры я буду передавать

auth=zhrgB3DxC8LoG7Gcilzg&action=1

отличие между GET и POST в том что мы устанавливаем заголовки и говорим чтобы
конфигурировался метод так как буд-то мы посылаем данные формы
*/

// let xhttp2 = new XMLHttpRequest()

// xhttp2.onreadystatechange = function () {
//     if (this.readyState == 4 && this.status == 200) {
//         myFunction2(this.responseText)
//     }
// }

// xhttp2.open("POST", "https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=1", true)
// xhttp2.setRequestHeader("Content-type", "application/x-www-form-urlencoded")
// xhttp2.send('auth=zhrgB3DxC8LoG7Gcilzg&action=1')

// function myFunction2(data) {
//     console.log('POST')
//     a = data
//     console.log(data)
// }

// _________________________________  Fetch на практике __________________________

/* 

Fetch API предоставляет интерфейс JavaScript для работы с запросами и ответами HTTP
Он также предоставляет глобальный метод fetch() (en-US), который позволяет легко и логично получать ресурсы по сети асинхронно.
Fetch также обеспечивает единое логическое место для определения других связанных с HTTP понятий, такие как CORS и расширения для HTTP.

fetch спецификация отличается от jQuery.ajax() в основном в двух пунктах:

Promise возвращаемый вызовом fetch() не перейдёт в состояние "отклонено" из-за ответа HTTP, 
который считается ошибкой, даже если ответ HTTP 404 или 500. Вместо этого, 
он будет выполнен нормально (с значением false в статусе ok ) и будет отклонён только при сбое сети или если что-то помешало запросу выполниться.
По умолчанию, fetch не будет отправлять или получать cookie файлы с сервера, в результате чего запросы будут осуществляться без проверки подлинности, 
что приведёт к неаутентифицированным запросам, если сайт полагается на проверку пользовательской сессии 
(для отправки cookie файлов в аргументе init options должно быть задано значение свойства credentials отличное от значения по умолчанию omit).

Базовый запрос на получение данных действительно прост в настройке. Взгляните на следующий код:

fetch('http://example.com/movies.json')
  .then((response) => {
    return response.json();
  })
  .then((data) => {
    console.log(data);
  });
Здесь мы забираем JSON файл по сети и выводим его содержимое в консоль. Самый простой способ использования fetch() заключается в вызове этой функции с одним аргументом — строкой,
содержащей путь к ресурсу, который вы хотите получить — которая возвращает promise, содержащее ответ (объект Response).

Конечно, это просто HTTP-ответ, а не фактический JSON. Чтобы извлечь содержимое тела JSON из ответа,
мы используем json() (en-US) метод (определён миксином Body, который реализован в объектах Request и Response.)

--------------------------------------------------------------

fetch() - первым параметром принимает адрес куда мы стучимся

первый параметр fetch()

https://getpost.itgid.info/index2.php - первый параметр который нужно внести

второй параметр - обработчик результата ответа

fetch - всегда возвращает promise

после того как выполнится fetch

запросы не являются синхронными событиями они асинхронные и требуют времени

нам нужно дождаться когда придет ответ и только потом его обработать

для этого мы использовали callback функцию в fetch будем использовать .then()

и всё что мы укажем в функции .then() она будет выполнена после того как запрос обработается
для красоты then пишут так
fetch('https://getpost.itgid.info/index2.php')
.then() хер знает в чем тут красота

укажем в then() стандартную переменную data и стрелочную функцию

.then(data => {
    console.log(data)
})

в консоли увидим
Response {type: 'cors', url: 'https://getpost.itgid.info/index2.php', redirected: false, status: 200, ok: true, …}
body: (...)
bodyUsed: false
headers: Headers {}
ok: true
redirected: false
status: 200
statusText: ""
type: "cors"
url: "https://getpost.itgid.info/index2.php"
[[Prototype]]: Response 

Для того чтобы получить информацию к текстовым данным которые приходят в Response выше
его тоже нужно обработать как его обработать методов text()
console.log(data.text())

text() - позволяет получить простую текстовую информацию
*/
// console.log('-----------------------Fetch----------------------------')
// fetch('https://getpost.itgid.info/index2.php')
//     .then(data => {
//         console.log(data)
//         // data.text().then(data2 => {
//         //     console.log(data2)
//         // })
//         return data.text()
//     })
//     .then(data => {
//         console.log(data)
//     })
/*

Response {type: 'cors', url: 'https://getpost.itgid.info/index2.php', redirected: false, status: 200, ok: true, …}
body: (...)
bodyUsed: true
headers: Headers {}
ok: true
redirected: false
status: 200
statusText: ""
type: "cors"
url: "https://getpost.itgid.info/index2.php"
[[Prototype]]: Response


POST
Не ввели ключ авторизации. Ключ доступен в чате курса.
Promise {<pending>} промис находится в состоянии ожидания
[[Prototype]]: Promise[[PromiseState]]: "fulfilled"[[PromiseResult]]:
"Не ввели ключ авторизации. Ключ доступен в чате курса."

text() - вернул promise

можем сделать так

data.text().then(data2 => {
    console.log(data2)
})

чтобы избежать вложенности добавим

.then (data => {

})

return data.text()

fetch('https://getpost.itgid.info/index2.php') - после того как fetch отработает
будет запущен первый then
    .then(data => {
        console.log(data.text())
        // data.text().then(data2 => {
        //     console.log(data2)
        // })
        return data.text()
    })
первый then сработает обработает data и если там стоит команда return
то данные из первого then попадут во второй then далее можно передать и в третий
    .then(data => {
        console.log(data)
    })

->

POST
Не ввели ключ авторизации. Ключ доступен в чате курса.
Не ввели ключ авторизации. Ключ доступен в чате курса.
Response {type: 'cors', url: 'https://getpost.itgid.info/index2.php', redirected: false, status: 200, ok: true, …}
Не ввели ключ авторизации. Ключ доступен в чате курса.

Можно упростить ещё

fetch('https://getpost.itgid.info/index2.php')
    .then(data => data.text())
    .then(data => {
        console.log(data)
    })

Параметры передаются через адресную строку

https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=1

Response {type: 'cors', url: 'https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=1', redirected: false, status: 200, ok: true, …}
body: (...)
bodyUsed: true
headers: Headers {}
ok: true
redirected: false
status: 200
statusText: ""
type: "cors"
url: "https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=1"
[[Prototype]]: Response

Когда мы получаем такой response мы можем сделать проверку в несколько уровней

проверить if перед return data.status
*/
// fetch('https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=1')
//     .then(data => {
//         console.log(data)
//         // data.text().then(data2 => {
//         //     console.log(data2)
//         // })
//         return data.text()
//     })
//     .then(data => {
//         console.log(data)
//     })

// //___________Делаем POST запрос методом fetch

// fetch('https://getpost.itgid.info/index2.php', {

//     // позволяет настроить fetch более тонко
//     method: 'POST', // GET, POST, PUT, DELETE, etc. указываем метод
//     moded: 'cors', // no-cors, cors, same-origin указываем защиту особенности ее в данном случае будем согласовывать ее с бэкендом
//     cache: 'no-cache', // default, no-cache, reload, force-cache, only-if-cached кэширование если необходимо
//     credentials: 'same-origin', // include, same-origin, omit полномочия если вам необходимо передавать разные данные cookie и так далее
//     headers: { /* заголовки  есть возвожность отправить json */
//         'Content-Type': 'application/json',
//         // 'Content-Type' : 'application/x-www-form-urlencoded',
//     },
//     redirect: 'follow', // manual, follow, error
//     referrer: 'no-referrer', // no-referrer, client
//     // body: JSON.stringify(data), // вот здесь я должен передать данные на сервер// тип данных в body должен соответствовать значению заголовка "Content-Type"
//     body: auth = 'zhrgB3DxC8LoG7Gcilzg & action=2&name=alex'
// })
//     .then(response => response.text())
//     .then(response => {
//         console.log(response)
//     })

// fetch('https://getpost.itgid.info/index2.php', {

//     // позволяет настроить fetch более тонко
//     method: 'POST', // GET, POST, PUT, DELETE, etc. указываем метод
//     headers: { /* заголовки  есть возвожность отправить json */
//         'Content-Type': 'application/x-www-form-urlencoded',
//         // 'Content-Type' : 'application/x-www-form-urlencoded',
//     },
//     body: 'auth=zhrgB3DxC8LoG7Gcilzg&action=2&name=alex'
// })
//     .then(response => response.text())
//     .then(response => {
//         console.log(response)
//     })

// ______________________ Promise PromiseAll _______________________________

/* fetch это обертка над promise 

мы посылаем запрос https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=1

и когда он выполнится мы посылаем callback функцию первую 

 .then(data => {
        console.log(data)
        // data.text().then(data2 => {
        //     console.log(data2)
        // })
        return data.text()
    })

и callback функцию вторую

 .then(data => {
        console.log(data)
    })

Promise позволяет работать с асинхронными данными

когда мы посылаем 2 или 3 запроса у нас получаются
ответы от серверов в разном порядке
иногда получаем первым третий запрос иногда второй и все смешано


что такое promise

promise - это объект который принимает функцию с двумя параметрами
параметр 1 называют resolve 
параметр 2 называют reject
мы можем называть их как угодно

resolve - это параметр который получается когда promise возвращает результат как вы задумали
reject - когда у него не получается это сделать

у нас есть функция fetch которая посылает запрос он асинхронный мы должны дождать разрешения
события когда сервер нам ответит и когда fetch получит ответ

return data.text() - здесь мы получаем сырые данные которые преобразовываем в текстовую информацию
нам сервер отдает текстовую информацию
мы должны дождать этого события и только потом двигаться дальше

в promise мы должны обозначить явно что будет успешным срабатыванием
вместо return data.text() пишем resolve(data.text())

let aPromise = new Promise((resolve, reject) => {
    fetch('https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=1')
        .then(data => {
            resolve(data.text())
        })
        .then(data => {
            console.log(data)
        })
})

когда срабатывает событие я могу написать

let aPromise = new Promise((resolve, reject) => {
    fetch('https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=1')
        .then(data => {
            resolve(data.text())
        })
    aPromise.then(data => {
        console.log(data)
    })
})

aPromise.then(data => {
    console.log(data)
}) - callback функция которую мы вызываем

*/
// let aPromise = new Promise((resolve, reject) => {
//     fetch('https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=1')
//         .then(data => {
//             resolve(data.text())
//         })

// })

// aPromise.then(data => {
//     console.log(data)
// })

/*

Преимущества Promise перед then

let aPromise = new Promise((resolve, reject) => {
    fetch('https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=1')
        .then(data => {
            resolve(data.text())
        })

}) - здесь мы получили ответ и хотим этот ответ дальше использовать
для этого нужно будет писать код здесь 

aPromise.then(data => {
    console.log(data)
})

у нас будут какие-то действия с кодом
например мы хотим послать еще один запрос

aPromise.then(data => {
    console.log(data)
    fetch()
    .then()
    .then(data какой-то параметр => {
        если мы захотим послать третий параметр то указывать его придется здесь и таким образом мы создадим вложенность
    }) - для преобразования

})

promise позволяют избавиться от вложенности then

Предположим что нам необходимо послать два запроса и потом как-то поработать с синтаксисом
двух запросов то есть

давайте мы пошлем еще один запрос
*/

// console.log('---------------bPromise------------------')
// let bPromise = new Promise((resolve, reject) => {
//     fetch('https://getpost.itgid.info/index2.php?auth=zhrgB3DxC8LoG7Gcilzg&action=2&name=alex')
//         .then(data => {
//             resolve(data.text())
//         })

// })

// aPromise.then(data => {
//     console.log(data)
// })

// bPromise.then(data => {
//     console.log(data)
// })

/* 
эти события наступают независимо друг от друга сервер ответит как повезет

мы не можем предположить какая отработает первой всегда будет вылетать рандомный ответ
сначала от aPromise затем наоборот

ы можно было сделать так чтобы с ними обоими можно было работать

Поэтому у нас есть такая сущность как promiseall

PromiseAll синтаксис который позволяет нам обработать вот эти две переменные вместе

Promise.all  дальше мы указываем те  промисы с которыми будем работать

Promiseall дождется наступления двух промисов и только тогда запустит свою обработку

и я получу доступ к переменной value

(2) ['Не ввели ключ авторизации. Ключ доступен в чате курса.', 'Не ввели ключ авторизации. Ключ доступен в чате курса.']

результаты промисов записались в массив

так как промисол выдает массив то мы можем обратиться к каждому элементу массива

    console.log(value[0])
    console.log(value[1])

и таким образом они всегда будут приходить в том порядке в котором я указал

таким образом мы уменьшаем количество кода

*/
// Promise.all([aPromise,bPromise]).then(value => {
//     console.log(value)
//     console.log(value[0])
//     console.log(value[1])
// }) // -> (2) ['Не ввели ключ авторизации. Ключ доступен в чате курса.', 'Не ввели ключ авторизации. Ключ доступен в чате курса.']

//____________________________________Функции return_______________________________________________________

/*

Функция это возможность объединить кусочки кода

сделаем функцию которая просто выводит число на страницу

пусть у меня будет переменная равная 9

let variable_1 = 9;

я напишу функцию f1 которая будет этот текст выводить

function f1 () {
    document.querySelector('.functionDiv_1').textContent = variable_1
}

как будет работать эта функция при вызове

document.querySelector('.functionButton_1').onclick = f1 функция вызывается без скобочек 
если со скобочками результат будет просто сам отображаться без нажатся потому что
 функция со скобочками уже производит операцию вызова

по клику будет выводиться функция f1 которая отрисует в дивке значение переменной variable_1


function f1 () {
    document.querySelector('.functionDiv_1').textContent = variable_1
} - назвать эту конструкцию функцией тяжело
в других языках программирования называется >---процедурой---< то есть хранимой последовательностью действий
которую я могу повторять много раз в нужных мне местах
является ли эта функция гибкой - нет потому что она привязана к блоку и она привязана к переменной
если переменная где-то изменится, то изменится и сама функция

*/

// let variable_1 = 9;

// function f1 () {
//     document.querySelector('.functionDiv_1').textContent = variable_1
// }

// document.querySelector('.functionButton_1').onclick = f1

/* Задача, я хочу постоянно менять переменную и чтобы функция выводила задача я хочу сейчас несколько раз запустить 
функцию чтобы она вывела разные переменные

Чтобы функция постоянно не выходила за пределы своей области видимости и не искала переменную variable_1
обозначим параметр или аргумент функии чтобы она ждала какое-то значение на входе


let variable_1 = 9;

function f1 (variable_2) {
    document.querySelector('.functionDiv_1').textContent = variable_2
}

document.querySelector('.functionButton_1').onclick = f1 // -> [object PointerEvent]

выводит не то что ожидалось

функция при вызове должна принимать параметр поэтому я могу написать вот так

f1(90) и таким образом при вызове вместо variable_2 подставится 90

и функция внутри себя будет искать переменную variable_2 

если функия внутри себя не найдет let variable_2

то она функия будет искать значение внутри параметра

причем если мы обозначаем какое-то значение в параметре то никак объявлять его как переменную не нужно

в параметры можно передать переменную

let variable_1 = 9;

function f1 (variable_2) {
    document.querySelector('.functionDiv_1').textContent = variable_2
}

document.querySelector('.functionButton_1').onclick = f1 // -> [object PointerEvent]

f1(90) - в этом случае функция сработает при старте 
то есть в дивке уже будет нарисовано 90 а при клике по кнопке мы увидим [object PointerEvent]

возникает вопрос как сделать так чтобы вся эта херня работала по клику

если в функции нужно передать параметр мы используем именованую функцию обертку function()


function f1 (variable_2) {
    document.querySelector('.functionDiv_1').textContent = variable_2
}

document.querySelector('.functionButton_1').onclick = function() {
    f1(12)
} вот так будет работать по клику 

если у вас несколько кнопок вы можете получить несколько действий вызвав функцию несколько раз с разными параметрами
то есть вызывать функцию нужное количество раз меняя параметр и она будет срабатывать в нужной нам последовательностиы

если отрисовывать результат вызова функии в одной и той же дивке то результат вызова будет перезатираться

function f1 (variable_2) {
    document.querySelector('.functionDiv_1').textContent = variable_2
}

document.querySelector('.functionButton_1').onclick = function() {
    f1(12)
}

как сделать функцию еще более гибкой, допустим наша функция как то обрабатывает результат - например умножает на 50 или на 100
напишем вместо document.querySelector('.functionDiv_1').textContent = variable_2 - return 100 * variable_2

function f1 (variable_2) {
    return variable_2 * 100
}

document.querySelector('.functionButton_1').onclick = function() {
    f1(12)
}

в функцию можно передать любые действия в качестве параметра, но теперь

при нажатии на кнопку ничего не произойдет результат вывода ложится на меня

console.log(f1(12)) // -> 1200

второй вывод я хочу вывести на страницу поэтому

document.querySelector('.functionDiv_1').innerHTML = f1(23) // -> 2300

теперь у нас есть полноценная функция так как есть return функция создает произведение чисел и возвращает результат
который мы можем использовать в первый раз при вызове функции я подставил значение при вызове на место аргумента
и это значение прошло через функцию и вернулось в результате ее выполнения, я взял этот результат и вывел его в консоль
а другой значение вывел на страницу не меняя при этом саму функцию а только лишь значение которое я подставил в нее при вызове
таким образом я сократил количество кода >--- в этом и есть суть такой сущности как функция ---<

так же я могу вызов функции с определенным значением обозначить как переменную let variable_3 = f1(100)

и потом манипулировать этой переменной подставив ее в конец выражения

 document.querySelector('.functionDiv_1').innerHTML = variable_3

более того я могу встроить эту функцию в выражение

 document.querySelector('.functionDiv_1').innerHTML = f1(100)/2

вместо f1 будет подставлен результат который прописан в return

и потом выполняться остальные действия то есть я могу использовать в выражениях мою функцию
*/


// function f1 (variable_2) {
//     return variable_2 * 100
// }

// document.querySelector('.functionButton_1').onclick = function() {
//     console.log(f1(12)) // -> 1200
//     let variable_3 = f1(100)
//     document.querySelector('.functionDiv_1').innerHTML = f1(23)/2 // -> 1150
// }

/* Таким образом если вам нужно просто объединить несколько строк кода визуально логически просто какие-то действия
мы можем использовать функцию в самом простом виде function() {} без параметров и строк - то есть использовать
функцию как процедуру то есть объединенная логически действие

Если я хочу сделать функцию более гибкой я должен вызывать ее с разными параметрами я передаю параметр внутрь функции
и использую этот параметр внутри функции, возвращаю результат действия функции через return и в таком случае
при вызове функции я должен указать этот параметр 

но при таком подходе мне необходимо делать функции обертки потому что функция с круглыми скобочками вызовется сразу когда 
до нее дойдет очередь поэтому вся эта херня обернута в = () => {} 

Если я хочу многократно использовать функцию и встраивать ее в выражение и сделать ее более гибкой я использую return
в таком случае задача вывода текста ложатся на меня и я должен оборачивать внутри функции все в консоль лог*/

//_____________________________________ ООП Классы JS ________________________________________


/* 
function myAlert() {
    let variable_4 = 'Error' - это сообщение я могу принимать извне в качестве параметра поэтому указываем значение это параметра уже при вызове функции
    let variable_5 = `<p class='orange'>${variable_4}</p>`

    document.querySelector('.test').innerHTML = variable_5
} ->   это не функция это процедура

myAlert()

передача переменной и ее значения в функцию как параметра этой функции let variable_4 = 'Error' - function myAlert(variable_4) - myAlert('Error')

function myAlert(variable_4) {
    let variable_5 = `<p class='orange'>${variable_4}</p>`

    document.querySelector('.test').innerHTML = variable_5
} ->   это не функция это процедура

myAlert('Error')

так же я могу передавать класс который будет работать в качестве оформления 
если укажу его в качестве второго параметра для функции
и впоследствии я укажу сам параметр при вызове функции, но предварительно нужно его создать в css


function myAlert(variable_4, variable_6) {
    let variable_5 = `<p class='${variable_6}'>${variable_4}</p>`

    document.querySelector('.test').innerHTML = variable_5
} 

myAlert( 'Error', 'red')

так же мы можем передавать .test в качестве параметра variable_7

function myAlert(variable_4, variable_6, variable_7) {
    let variable_5 = `<p class=${variable_6}>${variable_4}</p>`

    document.querySelector(variable_7).innerHTML = variable_5
} 

myAlert( 'Error', 'red', '.test')

если я хочу повторить ту же функцию в другой элемент

myAlert( 'Error', 'red', '.test')
myAlert( 'Error', 'red', '.test2')

теперь функция стала универсальной но
она универсальна только в рамках моего заданного кода
то есть работая с этим кодом если я захочу добавить иконку
мне придется менять эту функцию либо делать ее полную копию и работать с ней

Если я поменяю данную функцию я не могу обеспечить и 100 % говорить о том что
те части кода которые я забыл которые написаны давно и которые используют эту функцию будут работать адекватно

данную функцию могут переназначить перезаписать либо использовать не так как положено
я могу только ее написать и надеяться что ее используют правильно

любое изменение функции приведет к тому что я не могу гарантировать работоспособность предыдущего кода
который использует эту функцию я не могу безболезнено добавлять новые фишки

все эти проблемы обходит ООП

Модификация вашего кода не должна приводить к падению остального куска который был написан ранее

Перепишем этот код на ООП

function myAlert(variable_4, variable_6, variable_7) {
    let variable_5 = `<p class=${variable_6}>${variable_4}</p>`

    document.querySelector(variable_7).innerHTML = variable_5
} 

myAlert( 'Error', 'red', '.test')
myAlert( 'Error', 'red', '.test2')

Для начала создаем класс

Класс в JS - это шаблон с которым я могу работать

Классы
Классы в JavaScript были введены в ECMAScript 2015 и представляют собой синтаксический сахар 
над существующим в JavaScript механизмом прототипного наследования. 
Синтаксис классов не вводит новую объектно-ориентированную модель, 
а предоставляет более простой и понятный способ создания объектов и организации наследования.

Определение классов
На самом деле классы — это "специальные функции", поэтому точно также, 
как вы определяете функции (function expressions и function declarations), 
вы можете определять и классы с помощью: class declarations и class expressions.

Объявление класса
Первый способ определения класса — class declaration (объявление класса). 
Для этого необходимо воспользоваться ключевым словом class и указать имя класса (в примере — «Rectangle»).

class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}
Copy to Clipboard
Подъём (hoisting)
Разница между объявлением функции (function declaration) и объявлением класса (class declaration) в том, что объявление функции совершает подъём (hoisting), в то время как объявление класса — нет. Поэтому вначале необходимо объявить ваш класс и только затем работать с ним, а код же вроде следующего сгенерирует исключение типа ReferenceError:

var p = new Rectangle(); // ReferenceError

class Rectangle {}
Copy to Clipboard
Выражение класса
Второй способ определения класса — class expression (выражение класса). Можно создавать именованные и безымянные выражения. В первом случае имя выражения класса находится в локальной области видимости класса и может быть получено через свойства самого класса, а не его экземпляра.

// безымянный
var Rectangle = class {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};
console.log(Rectangle.name);
// отобразится: "Rectangle"

// именованный
var Rectangle = class Rectangle2 {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};
console.log(Rectangle.name);
// отобразится: "Rectangle2"
Copy to Clipboard
Примечание: Обратите внимание: выражения класса подвержены тем же проблемам с подъёмом (hoisting), что и объявления класса.

Тело класса и задание методов
Тело класса — это часть кода, заключённая в фигурные скобки {}. Здесь вы можете объявлять члены класса, такие как методы и конструктор.

Строгий режим
Тела объявлений классов и выражений классов выполняются в строгом режиме (strict mode).

Constructor
Метод constructor — специальный метод, необходимый для создания и инициализации объектов, созданных, с помощью класса. В классе может быть только один метод с именем constructor. Исключение типа SyntaxError будет выброшено, если класс содержит более одного вхождения метода constructor.

Ключевое слово super можно использовать в методе constructor для вызова конструктора родительского класса.

Как создается класс

Классы пишутся с большой буквы и после них идут {}

class Alert {

}

еще есть функция constructor() {} эта функция будет запущена когда на основе этого класса я создам объект
она запустится сама и она заполнит поля внутри класса

class Alert {
    constructor() {

    }
}


Внутри класса у меня будет не сколько полей

у нас есть несколько полей 

variable_4 - текст сообщения
variable_5 - класс оформления
variable_6 - элемент в который выводят

для того чтобы обратиться внутри конструктора к самому классу используем this
this. а дальше пишем имя свойства которое мы будем заполнять

class Alert {
    constructor(variable_4, variable_6, variable_7) {
        this.message = variable_4
        this.cssClass = variable_6
        this.out = variable_7
    }
}

я создал класс в котором должно быть три свойства

1-е свойство: this.message
2-е свойство: this.cssClass
3-е свойство: this.out

пока наш класс только что-то описывает

на основе этого класса создадим объект

Для создания нового объекта

let m = new Alert()

выведем объект на основе класса в консоль

console.log(m) -> Alert {message: undefined}

потому что при вызове мы не указали параметров для класса,

вызываем с параметрами

let m = new Alert()

let m = new Alert('My message', 'orange', '.test') -> Alert {message: 'My message', cssClass: 'orange', out: '.test'}

я получил объект построенный на классе Alert

пока ничего этот объект делать не может он содержит только описательную информацию

___proto___ значит что данный объект наследуется на основе класса Alert

что должен делать метод
методы внутри конструктора это по сути функции которые туда запихнули
функции могут создавать действовать создавать какие-то вещи  манипулировать данными внутри класса

опишем метод showAlert(){} данный метод

после constructor() {} точку с запятой я не ставлю

showAlert() {
        document.querySelector(variable_7).innerHTML = variable_5
    }

вместо variable_7 я поставлю this.out
вместо variable_5 я поставлю `<p class=${variable_6}>${variable_4}</p>`
где вместо variable_6 this.cssClass вместо variable_4 this.message

class Alert {
    constructor(variable_4, variable_6, variable_7) {
        this.message = variable_4
        this.cssClass = variable_6
        this.out = variable_7
    }
    showAlert() {
        document.querySelector(this.out).innerHTML = `<p class='${this.cssClass}'>${this.message}</p>`
    }
}

// -> Alert {message: 'My message', cssClass: 'orange', out: '.test'}

теперь вызовем наш метод, для вызова метода понадобится имя объекта m, имя метода showAlert и поскольку это метод - ()

m.showAlert()

после этого произошла замена на странице
я могу изменять параметры функции при вызове и они сразу будут изменяться на странице

недостаток в увеличении синтаксиса
преимущество такого подхода в том
что видно где и как изменются данные

Попытаемся унаследоваться от этого класса и подыскать еще одну возможность
Для того чтобы наследоваться мне нужно создать еще один класс

Классы принято выносить в отдельный файл и сохранять с большой буквы

создадим класс Alert2 который будет расширять возможности класса Alert

class Alert2 extends Alert {

}

хочу добавить возможность вывода иконки внутрь моего кода 
но я хочу сделать это так чтобы остался и класс Alert и класс Alert2
и их можно было бы в коде использовать
код который использует Alert - не сломается

новый код который использует класс Alert2 получит возможности старого кода
и получит возможность работать с новыми фишками

во первых мне необходимо запустить класс конструктор    

!!! Конструктор - это функция которая запускается при создании объекта на основе класса

у меня уже есть конструктор и я буду расширять возможности этого класса чтобы это работало мне необходимо
взять параметры variable_4, variable_6, variable_7 и закинуть их внутрь старого конструктора

class Alert2 extends Alert {
    constructor(variable_4, variable_6, variable_7) {

    }
}

если сейчас оставить все как есть то 
создаем с теми же параметрами

let m2 = new Alert2('My message', 'red', '.test')
сохраняю обновляю и получаю ошибку -

Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
    at new Alert2 (JS_L.js:5720:16)
    at JS_L.js:5725:10

мне говорят что я взял класс наследовался от него вот тут

class Alert2 extends Alert {
    constructor(variable_4, variable_6, variable_7) {

    }
}

расширил возможности на основе кода существующего класса
но существующий класс Alert требует передачи ему в конструктор трех параметров 
        this.message = variable_4
        this.cssClass = variable_6
        this.out = variable_7
я их не передал
я передал конструктор данного параметра

то есть мне внутри конструктора нужно вызвать конструктор моего родителя и передать в него эти три параметра
для того чтобы это сделать мне нужно написать  - super(variable_4, variable_6, variable_7)

class Alert2 extends Alert {
    constructor(variable_4, variable_6, variable_7) {
        super(variable_4, variable_6, variable_7)
    }
} -> Alert {message: 'My message', cssClass: 'red', out: '.test'}

вот этим супер - super(variable_4, variable_6, variable_7) 
я вызываю конструктор моего родителя
 constructor(variable_4, variable_6, variable_7) {
        this.message = variable_4
        this.cssClass = variable_6
        this.out = variable_7
    }
и передаю параметры из него в новый конструктор

class Alert2 extends Alert {
    constructor(variable_4, variable_6, variable_7) {
        super(variable_4, variable_6, variable_7)
    }
}

то есть теперь у меня есть класс Alert2 и объект m2
которые ничем не отличаются от класса Alert

то есть новый constructor унаследовался от старого и все одинаково, но

но я добавляю icon иконку

class Alert2 extends Alert {
    constructor(variable_4, variable_6, variable_7, icon) {
        super(variable_4, variable_6, variable_7)
        и у меня будет this.icon = icon
    }
}

и так у меня появилась иконка давайте теперь попробуем ее вывести

У нас есть 2 класса Alert и Alert2 причем Alert2 унаследовался от Alert поскольку произошло наследование то
в Alert2 уже реализованы фичи по поводу сохранения message css и свойство которое показывает в какой переменной данный объект будет выводиться

Alert {message: 'My message', cssClass: 'red', out: '.test'}
cssClass: "red" - свойство класса или свойство объекта
message: "My message" - свойство класса или свойство объекта
out: ".test" - свойство класса или свойство объекта
[[Prototype]]: Object

showAlert() {
        document.querySelector(this.out).innerHTML = `<p class='${this.cssClass}'>${this.message}</p>`
    }

так же у нас есть специальный метод showAlert который позволяет вывести на страницу в указанный элемент с помощью innerHtML

данные свойства

я создал Alert2 и унаследовался от Alert этим я обеспечил :
если в коде где-то используется класс Alert или точнее объекта построенные на основе этого класса то они остаются без
изменений то есть я не ломаю код программы но я получаю все фишки реализованные в Alert
сейчас у нас одна фишка - это вывод сообщений но в больших программах это могут быть достаточно серьезные комплексы действий
которые я получаю и могу использовать

при наследовании необходимо указать метод super который перекинет параметры в конструктор родительского класса

конструктор - это функция которая запускается при создании объекта когда я пишу new Alert
запускается всегда функция конструктор которая распихивает нужные параметры либо делает какие-то действия
по свойствам данного класса и объекта

Дополним new Alert 
допустим я хочу перезаписать метод вывода сообщения у меня уже есть данный метод

showAlert() {
        document.querySelector(this.out).innerHTML = `<p class='${this.cssClass}'>${this.message}</p>`
    }

могу вызвать showAlert потом с помощью super еще раз с ним поработать а могу
могу просто реализовать еще один метод

 showIconAlert() {
        
}
у меня появилось новое свойство иконки this.icon = icon 

я буду выводить сообщение в формате сообщения иконка потом текст



Наследование позволяет получить фишки предыдущего класса
сохранился метод showiconalert то есть я могу применить и то и то но я расширил
класс за счет своего метода и теперь у класса alert2 есть два метода вывода иконок
я могу тоже самое расширить еще
myAlert() {
    alert(this.message)
} 

то есть вдруг вам понадобится просто заалертить тогда вы можете вызвать и так
myAlert(this.message)
*/

function myAlert(variable_4, variable_6, variable_7) {
    let variable_5 = `<p class='${variable_6}'>${variable_4}</p>` // то есть интерполяция позволяет работать с html в js

    document.querySelector(variable_7).innerHTML = variable_5
} 
console.log('--------смотрим классы----------')
myAlert( 'Error', 'red', '.test')
myAlert( 'Hello', 'orange', '.test2')

// class Alert {
//     constructor(variable_4, variable_6, variable_7) {
//         this.message = variable_4
//         this.cssClass = variable_6
//         this.out = variable_7
//     }
// }

// let m = new Alert('My message', 'orange', '.test')
// console.log(m) // Alert {message: 'My message', cssClass: 'orange', out: '.test'}

class Alert {
    constructor(variable_4, variable_6, variable_7) {
        this.message = variable_4
        this.cssClass = variable_6
        this.out = variable_7
    }
    showAlert() {
        document.querySelector(this.out).innerHTML = `<p class='${this.cssClass}'>${this.message}</p>`
    }
}

class Alert2 extends Alert {
    constructor(variable_4, variable_6, variable_7, icon) {
        super(variable_4, variable_6, variable_7)
        this.icon = icon
    }
    showIconAlert() {
        document.querySelector(this.out).innerHTML = `<p class='${this.cssClass}'>${this.message}</p>`
    }
}

let m = new Alert('My message', 'red', '.test')
console.log(m) 
m.showAlert()

let m2 = new Alert2('My message', 'red', '.test')
// class Alert2 extends Alert {
//     constructor(variable_4, variable_6, variable_7, icon) {
//         super(variable_4, variable_6, variable_7)
//         this.icon = icon 
//     }
//     showIconAlert() {
//         document.querySelector(this.out).innerHTML = `<p class='${this.cssClass}'>${this.message}</p>`
//     }
//     myAlert() {
//         alert(this.message)
//     } 
// }

// let m2 = new Alert2()
// m2.showIconAlert()
// myAlert(this.message)

// __________________________________ Рекурсия ___________________________________________
// 90 % случаев без рекурсии можно обойтись
/*

Рекурсия это возможность функции вызвать саму себя

let a = 1;

function rec() {
    recursia++
}

что будет если я напишу вызов функции rec внутри функции

function rec() {
    recursia++
    rec()
}

js зайдет в функцию rec увеличит recursia на единицу вызовет функцию и таким образом снова зайдет в функцию 
прибавит единицу к переменной и т.д. то есть таким образом я получаю бесконечный цикл 

но он не такой уж и бесконечный и рано или поздно закончится то есть в какой-то момент времени у меня
переполнится стек вызовов в браузере и js остановит свою работу браузер подвиснет и придется перезапускать страницу

основная опасность рекурсии в том что можно легко переполнить стек вызовов
если над вызовом внутри функции достаточно объемный код то рекурсия этого очень сильно не любит

выход из такого бесконечного цикла - добавим условие  и return после return функция не читается дальше и бесконечный цикл
разрывается

function rec() {
    recursia++
    if ( recrsia > 10) {
    return recursia
    }
    rec()
}

rec() // -> 234567891011

произошло следующее

recursia = 1 в функции она увеличивается на 1 потом выводится поэтому первая цифра 2
потом когда recursia стала равна 11 выполнилось условие и итерация рекурсии разорвалась
то есть мы сделали из функции обычный цикл for 

то есть мы дошли сюда 
function rec() {
    recursia++
    console.log(recursia);
    if (recursia > 10) {
        return recursia
    }
    rec ()
вернулись обратно и пошли выполнять еще раз пока итерация не прервется за счет return

таким образом с помощью рекурсии можно просчитать повторяющиеся действия
можно частично заменить цикл

если нужно обходить дерево то есть объект с большими вложенными структурами и вы не знаете количество
повторений в каждой ветке то рекурсия здесь подходит

Часто рекурсию применяют для анимации

создал див test3 с помощью рекурсии я могу его двигать

для начала напишем функцию которая позволит его двигать просто без рекурсии


let offset = 0

function move () {
    document.querySelector('.test3').style.left = offset + 'px' - лучше вынести за пределы функции, чтобы каждый раз не дергать при рекурсии дом элементы
    offset = offset + 5
}

добавим кнопку по которой будем отдавать команду к перемещению

document.querySelector('.forTest3Button').onclick = move 

если поместим  offset = offset + 5 в начале функции то сдвиг будет после первого же клика

function move () {

    offset = offset + 5
    document.querySelector('.test3').style.left = offset + 'px' - лучше вынести за пределы функции, чтобы каждый раз не дергать при рекурсии дом элементы

}

сейчас этот свдиг порождается мной
как его породить если сделать с помощью рекурсии

с помощью рекурсии я могу сделать следующее
по нажатию на кнопку я могу запустить функцию move 1 раз
функция move должна сделать сдвиг и вызвать сама себя 

function move() {

    offset = offset + 5
    document.querySelector('.test-3').style.left = offset + 'px';
    move()

}


но так мы получим бесконечный цикл поэтому необходимо условие его ограничивающее


function move() {

    offset = offset + 5
    document.querySelector('.test-3').style.left = offset + 'px';

    if (offset > 200) {
        return true
    }
    move()

}

из за очень быстрой работы рекурсии создается ощущение мгновенного перемещения из начальной точки в конечную но это не так

как сделать работу более плавной
нам необходима какая-то интервальная задержка
то есть мне нужно вызвать эту функцию не сразу а через какой-то промежуток времени

setTimeout() - эта фукнция которая позволяет вызвать какое-то действие какую-то функцию или метод через задержку по времени
setTimeout(здесь пишу название функции, здесь пишу задержку по времени)
допустим я буду вызывать через 500 милисекунд а функция будет назваться move
для начала уберем рекурсию
function move() {
    offset = offset + 5
    document.querySelector('.test-3').style.left = offset + 'px';
    if (offset > 300) {
        return true
    }
    setTimeout(move,500)

}
document.querySelector('.forTest3Button').onclick = move

результат дивка двигается

можно присвоить setTimeout переменной потом его обнулять и запускать снова
offset за пределами функции потому что его нужно изменять
можно скатиться до статических переменных это тоже очень не плохой вывод в данной ситуации
для демонстрации подойдет

рекурсия это хорошо но всегда нужно думать о ее ограничении
если это не учитывать получим просто зависание программы и возможно аварийный выход из нее 
а так же переполнится стек вызовов

в некоторых случаях ее можно заменить циклом в некоторых нет

setinterval в отличие от settimeout не будет ждать преобразования функции
*/
let recursia = 1;
function rec() {
    recursia++
    console.log(recursia);
    if (recursia > 10) {
        return recursia
    }
    rec ()
}
rec() // -> 234567891011
let offset = 0
function move() {
    offset = offset + 5
    document.querySelector('.test-3').style.left = offset + 'px';
    if (offset > 300) {
        return true
    }
    setTimeout(move,500)

}
document.querySelector('.forTest3Button').onclick = move // -> функция без скобок

//_______________________________________ Замыкание _________________________________________

/*

Замыкание - это следствие работы функции в JS поэтому когда мы говорим о замыканиях мы говорим о функциях

function lock() {
    let close = 8 - эта переменная называется локальная
    return 8*12
}

вызовем данную функцию

console.log(lock()) -> 96

локальную переменную видно только внутри блока где она объявлена если я за пределами функции напишу
console.log(close) -> получу close is not defined
переменная close доступна только внутри функции
переменные объявленные внутри блока называются локальными они видны и доступны только внутри блока
глобально по отношению к блоку в котором они объявлены их не видно
но есть и глобальные переменные
это переменные которые объявлены за пределами блока по отношению к данному блоку всегда нужно говорить по отношению к чему

вынесем локальную переменную в глобальную область видимости

let close = 8

function lock() {
 
    return 8*12
}

console.log(lock()) // -> 96

итоговая цифра не изменилась, но если я теперь выведу console.log(close) то увижу в консоли 8
потому что теперь и переменная и ее вывод в консоль находятся в глобальной области видимости

то есть переменная let close = 8 глобальна по отношению к функции 
function lock() {
    return 8*12
}

если в функции используется переменная и внутри нее эта переменная не объявлена то функция ищет ее снаружи себя

При этом если одновременно с глобальной переменной close объявить такую же переменную close локально но с другим значением
то отработает в функции локальное значение то есть функция взяла бы локальную переменную

let close = 8

function lock() {
    let close = 5
    return close*12
}

console.log(lock()) // -> 60

сколько живет переменная
локальная переменная close задействуется только тогда когда задейсвтуется функция lock
переменные внутри функции живут в тот момент когда я использую функцию в своих вычислениях
как только функия lock превратила свое существование локальная переменная close исчезает к ней нельзя достучаться
чтобы получить локальную переменную нужно опять вызвать функцию lock будет снова создана переменная close 
внутри области видимости функции будет выполнен результат и опять она будет уничтожена

соответственно возникает вопрос который получил название как проблема счетчика
как сделать счетчик на странице
счетчик это наиболее яркий пример использования замыкания
на котором наиболее просто показать зачем нужны замыкания
можно обойтись и без замыкания
но в некоторых случаях замыкания более полезны чем остальные подходы
пусть у нас будет функия lock


let close = 8

function lock() {
    close = close + 1
    return close
}

console.log(lock()) -> 9
вызываю lock() переменная close внутри объявлена? - нет, значит выходим за пределы функции ищем там переменную close
находим подставляем значение close = 8 + 1 close = 9 возвращаем значение 9 выводим в консоль

Если я вызову lock несколько раз

console.log(lock()) -> 9
console.log(lock()) -> 10
console.log(lock()) -> 11


так как это счетчик значение close меняем на 0
мы можем сделать кнопку я каждый раз нажимая на нее будем увеличивать счетчик на 1

let close = 0          <----------------------------------------------------------------------- Рабочий счётчик
function lock() {
    close++
    console.log(close)

}

document.querySelector('.forLockButton').onclick = lock

проблема в том что объявление переменной оторвано от функции
если код находится за пределами области видимости его могут использовать 
переменную close могут переопределить close = 6

let close = 0
function lock() {
   
    close++
    return close

}

console.log(lock()) // -> 1
console.log(lock()) // -> 2
close = 6
console.log(lock()) // -> 7

поскольку данная переменная объявлена в глобальной области видимости к ней имеют доступ все функции на странице
все методы на странице и она ничем не защищена это является проблемой
в этом есть делема счетчика если кто-то будет изменять данную переменную она ничем не защищена
она оторвана от функции и это вызывает проблему то есть вы не можете гарантировать что данный код
выполнится корректно

Если мы решим для избежания этой проблемы поместить close внутрь локальной области видимости функции


function lock() {
    let close = 0
    close++
    return close

}
console.log(lock()) - 1 
console.log(lock()) - 1 
console.log(lock()) - 1 величина перестанет увеличиваться
потому что при каждом вызове функции, значение close - становится 0 и каждый раз к нему прибавляется 1
поэтому и вывод каждый раз 1

поэтому данный подход - не работает

переменная живет только тогда когда мы вызвали функцию
то есть в момент вызова создается переменная запоминается ее значение и она работает пока функция вызвана
когда функция прекращена return данная переменная исчезает мы не можем к ней обратиться

что если создать функцию внутри которой мы объявим перемнную и будем работать уже не с переменной 
а с функцией внутри которой находится переменная

создадим функцию внутри которой объявим переменную
то есть возьмем и обернем наш код в еще одну функцию

function t1 () {
    let close = 0
    function lock() {
   
    close++
    return close

    }
}

теперь когда я вызову функцию t1()

когда будет вызвана функия t1 javascript будет создана перемнная t1
это будет функция, когда она будет работать
у меня будет создана внутри этой функции 
close = 0
внутри будет создана функция lock
когда будет вызвана функция lock она будет искать переменную close внутри себя
а когда не найдет выйдет за пределы своей области видимости и найдет в прелах области видимости функции t1
функция lock может искать в пределах функции t1
и поэтому функция lock будет обращаться к переменной close
если я еще раз создам функцию t1 то у меня создастся еще одна область видимости тоже t1
внутри которого тоже будет объявлена close которая тоже будет равняться 0
и запуск функции lock нового блока будет обращаться к переменной close нового блока
таким образом мы получаем несколько экземпляров области видимости внутри которых существуют свои close

Теперь мне необходимо сделать так чтобы я мог обратиться к функции lock
Создам функцию t1 внутри нее я объявляю close = 0
и буду возвращать через return функцию lock в анонимном виде, здесь можно указать стрелочную

function t1 () {
    let close = 0
    function lock() {
        close++
        return close
    }
}

function t1 () {
    let close = 0
    return () => {
        close++
        return close
    }
} то есть когда я запущу t1
у меня объявится область видимости t1 
в нём внутри появится close = 0 и у меня появится стрелочная функция и она будет заложена в новую переменную

let vf = t1
объявится область видимости внутри нее будет объявлена переменная close которая будет доступна
анонимной стрелочной функции больше ее никто не видит за пределами области видимости t1
а внутрь vf попадет стрелочная функция

console.log(vf) ->
() => {
    close++
    return close
}

теперь если я напишу
console.log(vf()) функция находящаяся внутри этой переменной должна быть выполнена
то есть любая именованая функция это есть переменная внутри которой находится анонимная функция

console.log(vf()) // -> 1 и теперь если я вызову данную переменную несколько раз
console.log(vf()) // -> 2
console.log(vf()) // -> 3

let vf = t1(); - в момент вызова t1 в JS создается блок видимости в котором доступна => функция
и эта => функция видит внешнюю по отношению к себе переменную
но никто кроме этой функции доступа к этой переменной не имеет
то есть я создал переменную close которая прикреплена к => функии 
=> функция  может ее изменить а ни что другое не может

в чем изюм

теперь если я создам 

let vf = t1();

и 

let fv = t1();

для fv создастся свой блок видимости в котором тоже будет переменная close и внутри => функция будет иметь
доступ к этой close но никто другой иметь доступа туда не будет
и теперь я могу вызвать эту переменную fv()

console.log(fv()) // -> 1
console.log(fv()) // -> 2
console.log(fv()) // -> 3

из за того что каждый раз при создании функции t1 каждый раз создается новый блок видимости или область видимости
и никто другой туда не имеет доступа кроме => функции которая записана у нас в переменную vf fv
в такие моменты я могу делать миксы из вызовов

console.log(vf()) // -> 4
console.log(vf()) // -> 5
console.log(fv()) // -> 4 
console.log(vf()) // -> 6

Есть такое понятие как приватное свойство это свойство которое доступно только внутри объекта внутренним его методам

если я хочу создать такое свойство, чтобы никто их не мог изменить кроме какой-то определенной функции
то мы делаем Замыкание

function t1 () {     <----------------------------------------------------------Замыкание
    let close = 0
    return () => {
        close++
        return close
    }
}

let vf = t1();
let fv = t1();       <----------------------------------------------------------Замыкание

Замыкание Области Видимости функции на какой-то объем переменной!
в данном случае я вот эту область видимости

return () => {
        close++
        return close
    }

замкнул на вот эту переменную - let close = 0
у меня получился замкнутый объем внутри которого я могу функционировать
могу ли я менять, обращаться к внешним переменным? как и с обычными функциями это работает
но конкретно в данном случае обращение к переменной close будет сводиться к обращению к
этой let close = 0 переменной и никто другой кроме этой функции изменить ее не может

мы просто пишем свой код, объявляем переменные в которыми никто не должен пользоваться кроме нашей функции
и оборачиваем это в еще одну функцию а предыдущую функцию возвращаем с помощью return
затем общую функцию присваиваем переменной и вызываем нужное количество раз

таким образом мы создаем несколько экземпляров областей видимости с функциями которые имеют доступ только в пределах общей функции

теперь если я изменю переменную close в глобальной области видимости на код выше это никак не повлияет

когда я пишу close = 8

происходит поиск, есть ли в данной текущей области видимости данные переменные - нет потому что
внутренние переменные close в наших функциях - замкнуты каждая внутри своей области видимости

Замыкание Области Видимости функции на какой-то объем переменной!


Если мне нужны разные виды счетчиков то

То есть я получаю возможность делать переменные которые не доступные никому кроме моих функций которые я объявил

где правильно применять переменные

Если вам нужна переменная к которой никто больше не имеет доступа то вам нужно замыкание
вы делаете эту переменную объявляете эту функцию и работаете с ней
если вам нужны разного рода счетчики - замыкание подходит

Замыкания нашли еще применение в эмуляции ООП в JS
в ООП есть несколько видов свойств

1-е свойства доступные всем
2-е свойства доступные только объекту
3-е свойства доступные еще и наследникам

в остальных языках программирования это все реализуется надписями 

public
private
protected и т.д.

в JS такого нет и свойства которые мы не хотим чтобы было видно наружу при создании объекта и были доступны только внутренним методам
объявляют через замыкание

весь код помещаем в общую функцию

объявляем переменную которую мы хотим замкнуть в области видимости и объявляем функцию
которая к этим переменным обращается теперь она будет работать конкретно с этим экземпляром независимо ни от кого
затем общую функцию присваиваем переменной и вызываем переменную со ()
*/

function t1 () {
    let close = 0
    return () => {
        close++
        return close
    }
}

let vf = t1();
let fv = t1();


console.log(vf) /* 
() => {
    close++
    return close
}
*/
console.log(vf()) // -> 1
console.log(vf()) // -> 2
console.log(vf()) // -> 3

console.log(fv()) // -> 1
console.log(fv()) // -> 2
console.log(fv()) // -> 3

console.log(vf()) // -> 4
console.log(vf()) // -> 5
console.log(fv()) // -> 4 
console.log(vf()) // -> 6

//______________________________________ Массивы часть 2 ____________________________________

/* 

Если вы хотите сохранять информацию в JS вы можете делать это с помощью переменных

let a = 'ilia'
let b = 101
let c = 897

я описал пользователя с помощью трех переменных, только после этих слов становится понятна связь между переменными
если через месяц мне покажут переменную b и спросят что ей присвоено не будет понятно с чем эта переменная связана

Задача массивов логически связывать такие структуры данных
не просто набор перемнных а конкретно описывающую что-то структуру

Например опишем знак зодиака

let zodiak = ['scales', 9, 1, 30]

теперь становится понятно по какому принципу даные объединены

выведем знак в консоль

console.log(zodiak) - (4) ['scales', 9, 1, 30] Array(4)0: "scales"1: 92: 13: 30length: 4[[Prototype]]: Array(0)

[] - говорят о том что это массив и что он объявлен

данный массив имеет размерность, то есть длину 
length = 4 начинается с 1 элемента, так же это индекс последнего элемента + 1

в массиве есть значения, значения это 'scales' 9 1 30
для удобства работы эти значения нумеруются нумерация идёт с 0

0: "scales"
1: 9
2: 1
3: 30

0, 1, 2, 3 - называются индексом массива и начинаются с 0 а длина length с 1

создадим еще один массив и выведем в консоль

let man = ['ilia', 'male', 179, 67]

(4) ['ilia', 'male', 179, 67]
0: "ilia"
1: "male"
2: 179
3: 67
length: 4

мы можем вывести длину массива 

console.log(zodiak.length) // -> длина массива - 4
console.log(man.length) // -> длина массива - 5

как вывести любой элемент массива:

указываем имя массива и в [] указываем индекс нужного нам элемента
console.log(man[0]) 

как поменять элемент в массиве: 

нужно обратиться к элементу в массиве по индексу и присвоить новое значение например поменяем имя

man[0]= 'william'

console.log(man); // -> (5) ['william', 'male', 179, 67, 'ilyin']

как поменять местами элементы в массиве
меняем первый и последний элемент в массиве
для этого один из элементов выносим в отдельную переменную затем ставим последний элемент на место первого
и из отдельной переменной ставим значение на место последнего

let array_19 = [1,2,3,4,5]
console.log(array_19) // (5) [1, 2, 3, 4, 5]
let forArray_19 = array_19[0]
array_19[0] = array_19[4]
array_19[4] = forArray_19
console.log(array_19)// (5) [5, 2, 3, 4, 1]


если мы всегда сможем сказать что началом массива всегда будет array_19[0] то последний индекс массива мы будем знать далеко не всегда
поэтому мы используем :

последний индекс массива независимо от данных в массиве -> array_19[array_19.length - 1]

let array_19 = [1,2,3,4,5]
console.log(array_19) // (5) [1, 2, 3, 4, 5]
let forArray_19 = array_19[0]
array_19[0] = array_19[array_19.length - 1]
array_19[array_19.length - 1] = forArray_19
console.log(array_19) // (5) [5, 2, 3, 4, 1]

обращение к элементу массива которого не существует

console.log(array_19[7]) - undefined

выведем элемент на страницу

первый способ вывода массивов на страницу через циклы

for(let i = 0; i < array_19.length; i++) {
    document.querySelector('.arrayTrain_1').innerHTML += array_19[i] 52341
}

второй способ вывода массивов на страницу через объявление переменной которой присваиваем значение пустой строки

let varForArray_19 = ''

потом запускаем цикл и вместо document.querySelector('.arrayTrain_1').innerHTML
пишем varForArray_19 итого

let varForArray_19 = ''

for(let i = 0; i < array_19.length; i++) {
    varForArray_19 += array_19[i] // 52341
}

document.querySelector('.arrayTrain_1').innerHTML = varForArray_19

и уже после цикла вывести эту переменную на страницу 
те же яйца только в профиль но при большом количестве кода работать будет быстрее

а если укажем let varForArray_19 = 0 то получим сумму всех чисел между собой

чаще всего выводить все элементы массива не нужно 
поэтому вот этот вывод  varForArray_19 += array_19[i] + '_' нужно обернуть в какое-то условие
допустим мы хотим вывести только четные

let varForArray_19 = ''

for(let i = 0; i < array_19.length; i++) {

    if (array_19[i]%2 === 0) {
    varForArray_19 += array_19[i] + '_' // 52341
    }
}

document.querySelector('.arrayTrain_1').innerHTML = varForArray_19 // только четные 2_4_

второй навык после того как мы поменяли значения местами это вывод на страницу

Найти минимальный и максимальный элемент в массиве

let array_20 = [10,11,12,13]

let max = array_20[0]

for(let i = 0; i < array_20.length; i++) {
    if (array_20[i] > max) {
        max = array_20[i] 
    }
}
console.log(max) // 13

Найдем минимальный элемент в массиве

let array_21 = [23, 43, 65, 278]

let min = array_21[0]

for(let i = 0; i < array_21.length; i++) {
    if (array_21[i] < min) {
        min = array_21[i] 
    }
}
console.log(min) // 23

Найдем среднее значение в массиве

let array_22 = [23, 43, 65, 278]

let CA = 0

for(let i = 0; i < array_22.length; i++) {
    CA += array_22[i]
}
console.log(CA/2) // 204.5

Найти сумму всех чисел в массиве

let array_22 = [23, 43, 65, 278]

let summOfAllNumbersArray_22 = 0

for(let i = 0; i < array_22.length; i++) {
    summOfAllNumbersArray_22 += array_22[i]
}

console.log(summOfAllNumbersArray_22) // 409

*/


let zodiak = ['scales', 9, 1, 30]
let man = ['ilia', 'male', 179, 67, 'ilyin']

console.log(zodiak) // -> (4) ['scales', 9, 1, 30]
console.log(man) // -> (4) ['ilia', 'male', 179, 67]
console.log('длина массива man - ' + man.length) // -> длина массива - 5
console.log('длина массива zodiak - ' + zodiak.length) // -> длина массива - 4
console.log(man[0]) // -> ilia - строка выводится уже без кавычек

man[0]= 'william'

console.log(man); // -> (5) ['william', 'male', 179, 67, 'ilyin']

let array_19 = [1,2,3,4,5]
console.log(array_19) // (5) [1, 2, 3, 4, 5]
let forArray_19 = array_19[0]
array_19[0] = array_19[array_19.length - 1]
array_19[array_19.length - 1] = forArray_19

console.log(array_19) // (5) [5, 2, 3, 4, 1]
console.log(array_19[7]) // undefined

for(let i = 0; i < array_19.length; i++) {
    document.querySelector('.arrayTrain_1').innerHTML += array_19[i] + ' ' // 52341
}

let varForArray_19 = ''

for(let i = 0; i < array_19.length; i++) {

    if (array_19[i]%2 === 0) {
    varForArray_19 += array_19[i] + '_' // 52341
    }
}

document.querySelector('.arrayTrain_1').innerHTML = 'Только чётные из array_19 - ' + varForArray_19 // только четные 2_4_

let array_20 = [10,11,12,13]

let max = array_20[0]

for(let i = 0; i < array_20.length; i++) {
    if (array_20[i] > max) {
        max = array_20[i] 
    }
}
console.log('Максимальное из array_20 - ' + max) // 13

let array_21 = [23, 43, 65, 278]

let min = array_21[0]

for(let i = 0; i < array_21.length; i++) {
    if (array_21[i] < min) {
        min = array_21[i] 
    }
}
console.log('Минимальное из array_21 - ' + min) // 23

let array_22 = [23, 43, 65, 278]

let CAPrepair = 0

for(let i = 0; i < array_22.length; i++) {
    CAPrepair += array_22[i]
}

let CAReady = CAPrepair/2
console.log('Среднее значение массива array_22 - ' + CAReady) // 204.5

let summOfAllNumbersArray_22 = 0

for(let i = 0; i < array_22.length; i++) {
    summOfAllNumbersArray_22 += array_22[i]
}

console.log('Сумма всех чисел массива array_22 - ' + summOfAllNumbersArray_22) // 409


// _____________________________________ QA #1 ________________________________________

// ______________________________ ООП часть 2. Прототипы ______________________________

/*

let user = {
    username: 'ilia',
    password: 'qwerty'
}

let user2 = {
    username: 'ilia',
    password: 'qwerty'
}


console.log(user) // {username: 'ilia', password: 'qwerty'} [[Prototype]]: Object
console.log(user2) // {username: 'ilia', password: 'qwerty'} [[Prototype]]: Object

Два объекта которые имеют одинаковые поля и одинаковые значения
но с точки зрения JS это два разных объекта

у каждого объекта в консоли отображается свойство __proto__: Object
основная изначальная модель ООП была посвящена работе с прототипами

поэтому мы можем записать этот объект в свойство __proto__ зачем??
user 2 наследуется от user

let user2 = {
    username: 'ilia',
    password: 'qwerty'
}



let user2 = {}
user2.__proto__ = user

console.log(user2) 
{}[[Prototype]]: Objectpassword: "qwerty"username: "ilia"[[Prototype]]: Object





// user 2 наследуется от user

// console.log(user) // {username: 'ilia', password: 'qwerty'} [[Prototype]]: Object

// console.log(user2) // {}[[Prototype]]: Objectpassword: "qwerty"username: "ilia"[[Prototype]]: Object

// console.log(user2.username) // ilia

// user2.photo = 'ilia.jpeg'




user 2 наследуется от user
но наследование предполагает что я могу получать из объекта свойства
проверим
console.log(user2.username) - ilia

таким образом я могу создавать цепочку объектов которые наследуются
друг от друга

Допустим у меня есть форма в которую клиент может вводить логин пароль
я могу унаследовать объект user2 от объекта user и присвоить нужное ему свойство

user2.photo = 'ilia.jpeg'

теперь у меня два объекта

let user = {
    username: 'ilia',
    password: 'qwerty'
}

и

{}photo: "ilia.jpeg"[[Prototype]]: Object

первый объект описывает просто форму логина
где можно ввести username и password

а вот объект user2 я уже могу использовать в личном кабинете

user2 имеет другие свойства, но содержит в себе и свойства которые были в объекте user

user2 -{}
photo: "ilia.jpeg"
[[Prototype]]: Object
password: "qwerty"
username: "ilia"
[[Prototype]]: Object

То есть мне не нужно писать заново свойства из объекта user
Если у меня в объекте user будут какие-то свои методы
то эти методы будут мне доступны и внутри user2

Зачем нужен seter JS

у меня есть свойство password
когда пользователь заполнит данное свойство оно будет отправляться на сервер
но пароль может быть скопирован и внесен не в совсем правильном формате
не 'qwerty' а ' qwerty' с пробелом, тоже самое может быть с username
мы должны обрабатывать данные которые вводит пользователь
в этом случае мы должны сказать что свойство password у нас будет 
как бы приватное

let user = {
    username: 'ilia',
    _password: 'qwerty'
}

и для работы с ним мы будем использовать setter

let user = {
    username: 'ilia',
    _password: 'qwerty'

    set password(name) {
        this._password = pass.trim()
    } этот сеттер будет отвечать за заполнение пароля
}

сейчас установлен пароль qwerty но в будущем он может меняться

пользователь в форме вводит логин и пароль нажимает кнопку
и я делаю следующее

user.password = ' noe '

console.log(user)

{username: 'ilia', password: ' noe '}
password: " noe "
username: "ilia"
set _password: ƒ _password(name)
[[Prototype]]: Object

{username: 'ilia', _password: 'noe'} теперь нет пробелов сработал метод trim()
username: "ilia"
_password: "noe"
set password: 
ƒ password(pass)
[[Prototype]]: Object

т.о. свойству password присвоилось слово hello без пробелов

когда я пишу set и обращаюсь к user.password идет проверка есть ли в объекте user метод set с именем password
' noe ' попадает в параметр set password(' noe ') обрабатывается методом trim() и выполняется  this._password 
то есть я т.о. присваиваю свойству password уже обрезанное от пробелов значение

Как теперь получить password

для этого существует get

Синтаксис get связывает свойство объекта с функцией, которая будет вызываться при обращении к этому свойству.

const obj = {
  log: ['a', 'b', 'c'],
  get latest() {
    return this.log[this.log.length - 1];
  }
};

console.log(obj.latest);
// expected output: "c"

let user = {
    username: 'ilia',
    _password: '', // qwerty
    set password(pass) {
        this._password = pass.trim()
    }
    get password () {
        return this._password
    }
}

Если пользователь теперь захочет получить пароль то напишет сл образом

console.log(user.password)

console.log(user.password.length) // длина - 3

как это работает, если я введу c пробелами

console.log('                    noe '.length) // 24

let user = {
    username: 'ilia',
    _password: '', // qwerty
    set password(pass) {
        this._password = pass.trim()
    },
    get password () {
        return this._password
    }
}

изначальная длина 24 она залетает в password но поскольку есть set
попадает в переменную pass обрезается методом trim() и заносится в свойство _password

Если я пишу обращение без присваивания

console.log(user.password)


то js проверяет есть ли get password () то обращается к этому методу 
который возвращает значение this._password - {return this._password}

теперь мы можем повторно использовать
у меня в лк пользователь может получать пароль и менять его
значит мне не нужно писать еще раз новый объект user

я наследуюсь от user и пишу

создать объект user2

let user2 = {}

user2.__proto__ = user - наследование - прототипизация

и прототипом этого объекта будет являться объект user

теперь я знаю что user2 по умолчанию имеет все необходимые свойства которые прописаны в user

проверим, введем пароль для user2 с пробелами

user2.password = '123 456' я специально ввел пароль который явно ошибочен он содержит пробел посередине
trim() такой пробел не удаляет

console.log(user2) {_password: '123 456'}

{_password: '123 456'}
_password: 
"123 456"
password: (...)
[[Prototype]]: Object
password: (...)
username: "ilia"
_password: "noe"
get passwor: 
ƒ password()
set password: 
ƒ password(pass)
[[Prototype]]: Object

JS знает что объект user2 наследуется от user
в user есть свойство password идет проверка - у прототипа есть такое свойство?
да есть и оно содержит get set теперь я попадаю в обратно set password(pass)
обрезаю пароли password: (...) и присваиваю 123 456 без пробелов
теперь не нужно заново писать такие же методы

у меня уже есть хорошо написанный объект user и я просто использую его мощности
то есть user2.password = ' 123 456  ' вызвал 
    set password(pass) {
        this._password = pass.trim()
    }

    записался в this._password
    и получить я его могу точно так же 
    хотя в user 2 я никаких get set не писал

console.log(user2.password) - 123 456

когда я обращаюсь к console.log(user2.password) 
проверяется есть ли свойство или метод внутри объекта password: (...)
внутри объекта user2 - нет
но user2 наследуется от свойства где есть get set
мы идем в user смотрим есть ли get он срабатывает get возвращат this._password
this в данном случае ссылка на текущий объект
текущим объектом является user2 поэтому вывелся пароль 123 456 а не noe
то есть тот пароль который мы установили тот и вывелся

т.о. я могу создать цепочку объектов
могу создать третий объект user3 в котором прототипом (прародителем) будет выступать user2
и тогда если я в user2 добавлю ссылку на картинку 
то в user3 тоже будет свойство картинка

c другой стороны допустим я в user хочу прописать дополнительный метод либо 
дополнительное свойство email: '@sdfkjg'
то внесение изменения в сам прототип повлечет за собой появление этого свойства
во всех остальных объектах которые наследуются от него

let user = {
    username: 'ilia',
    _password: '', // qwerty
    email: '@sdfkjg',
    set password(pass) {
        this._password = pass.trim()
    },
    get password () {
        return this._password
    }
}

и теперь если я выведу user2.email хотя я его напрямую не присваивал то получу 
console.log(user2.email); // @sdfkjg

конечно нужно вводить проверки
но введя проверки наследуясь дальше
я буду легко получать работоспособность в объектах которые наследуются

на основе __proto__ мы выстраиваем цепочку наследования

user2.__proto__ = user - я сейчас напрямую присвоил прототип
можно сделать по другому

Object.setPrototypeOf(obj, prototype)
Object.setPrototypeOf(user2, объект от которого вы наследуетесь)
но есть предупреждение что скорость данного метода не оптимизирована
поэтому есть рекомендация осторожно его использовать там где не нужна быстрая работоспособность


то есть добавляя новые значения свойств в потомков мы изменяем их и в родителе


перезатираем свойство username в user через user2
user2.username = 'Privet'

console.log(user2) {username: 'Privet', _password: '123 456'}

свойство username появилось явно хотя оно было у родителя
то есть я через потомка перезаписал значение свойства родителя

можно ли обращаться к свойству родителя
берем наше свойство username оно есть 
и у прототипа (прародителя) username: 'ilia' и у потомка (user2.username = 'Privet')
при этом user2 и user имеют разные значения данного свойства
но мы через потомка обратимся к значению свойства прототипа(прародителя)

console.log(user2.__proto__.username) // ilia  - обращение к прародителю
console.log(user2.username)          // Privet - обращение к потомку
*/

let user = {
    username: 'ilia',
    _password: '', // qwerty
    email: '@sdfkjg',
    set password(pass) {
        this._password = pass.trim()
    },
    get password () {
        return this._password
    }
}

user.password = ' noe '
console.log(user)
console.log(user.password) // noe (благодаря get password ) пароль получен без пробелов
console.log(user.password.length) // длина - 3
console.log('                    noe '.length) // 24

let user2 = {}

user2.__proto__ = user 
user2.username = 'Privet' // {username: 'Privet', _password: '123 456'}
user2.password = ' 123 456  '
console.log(user2) // {_password: '123 456'}
console.log(user2.password) // 123 456
console.log(user2.email); // @sdfkjg
console.log(user2.username)         // Privet
console.log(user2.__proto__.username) // ilia

// _____________________________________ Массивы _______________________________________

// Задача. есть массив умножьте его на 2 и выведите в out вывод через пробел по нажатию кнопки b1

let mmm = [7, 3, 21]

function t11 () {

let mm = []

    // операции с массивами которые подразумевают под собой изменение значений изменение структуры
    // количества элементов
    for(let i = 0; i < mmm.length; i++) {
        mm[i] = mmm[i]*2
    }

    // вывод массива

console.log(mm) // (3) [14, 6, 42]

    let output = ''
    for (let i = 0; i < mmm.length; i++) {
        output += `${mm[i] + ' '}` // здесь можно добавить любой знак разделитель
    }

console.log(output) // 14 6 42  - ушли запятые добавился пробел вывод в формате строки а не массива

return output

}

document.querySelector('.outMulti').onclick = () => {
    document.querySelector('.outMulti2').innerHTML = t11()
} // PROFIT

// вначале операция - потом вывод

// ______________________________ TRY CATCH _____________________________

// отлов ошибок и исключений в JS

/* Специальный синтаксис который говорит попробовать что-то выполнить

try {
 document.querySelector('suadfh').innerHTML = aa
}
    
помещаю внутрь ту часть кода которая подсвечена как ошибочная

try { // это просто попытка выполнить блок кода он может либо выполниться либо нет
    document.querySelector('suadfh').innerHTML = aa
}

после try у нас идёт catch
catch(здесь переменная куда помещается значение введенное в try - ошибка) {

}

у меня есть блок кода обернутый в try который будет пытаться выполниться
если блок try выполнится то блок catch будет пропущен

если же внутри блока try возникает ошибка
то программа перейдет в блок catch и будет выполнять его

остановки не произойдет то есть программа продолжит работать

let aa = 5;
aa = aa*2;

try { 
    document.querySelector('suadfh').innerHTML = aa
} - здесь возникла ошибка, программа перешла в catch и выполняет положенный внутри catch
catch(err) { 
    для себя могу сделать вывод ошибки
    console.log(err)
    console.log('1')
} 

console.log(aa)

t12()

function t12 () {
    console.log('ilia')
}


в try catch можно обернуть весь код, можно делать вложенный try catch

добавим искомый див в html и уберем ошибку

в таком случае catch будет проигнорирован и перейдет дальше

достаточно полезная опция которая делает программу более защищенной

в сactch можно добавить alert чтобы ошибка была более наглядной
catch(err) { 
    для себя могу сделать вывод ошибки
    console.log(err)
    console.log('1')
    alert("Mistake")
} 

помимо try и catch

нужно чтобы гарантировано выполнился какой-то блок
возможно будут ошибки возможно ошибок не будет но
нужна гарантия что после всего этого выполнится еще один блок
в не зависимости от того была ошибка или нет
для этого используется блок finally

finally {
    console.log(finall)
} // - этот блок выполнится в любом случае

*/

// программа после ошибки не работает, но!


let aa = 5;
aa = aa*2;
let finall = 'f'
try { // это просто попытка выполнить блок кода он может либо выполниться либо нет
    document.querySelector('.suadfh').innerHTML = aa
}// после try у нас идёт catch
catch(err) {
    console.log(err) // TypeError: Cannot set properties of null (setting 'innerHTML') at JS_L.js:7164:48 Но ошибки - нет! программа работает дальше
    console.log('1')
    alert("Mistake")
} //  ошибки нет программа работает дальше
finally {
    console.log(finall)
} // - этот блок выполнится в любом случае
console.log(aa)

t12()

function t12 () {
    console.log('ilia')
}

// ______________________________________ 9 способов клонировать массив ______________________________________

/* 

Есть массив 

let array_23 = [1,2,3]

идет присваивание массива другой переменной

let array_24 = array_23

массивы присваиваются по ссылке

выведем в лог оба

console.log(array_23) // (3) [1, 2, 3]
console.log(array_24) // (3) [1, 2, 3]

на самом деле это две ссылки на один и тот же массив

Если после присваивания я запушу информацю в массив array_23 
то получу тот же элемент и в массиве array_24

array_23.push('4')

это происходит потому что обе переменные всего лишь ссылки к одной и той же камере хранения

как получить клоны не зависящие друг от друга

для этого подойдет опертор спред [...array_23]

let array_25 = [...array_23]

array_23.push(4)

console.log(array_25) (3) [1, 2, 3]

то есть если использовать опертор спред то мы получим два разных массива
но если использовать не одномерный массив а двумерный, то

let array_26 = [1,2,3[4,5,6]] 

выполняем те же действия

let array_26 = [1,2,3,[5,6],]

let array_27 = [...array_26]

array_26.push(4)

console.log(array_26) //(5) [1, 2, 3, Array(2), 4]        
console.log(array_27) // (4) [1, 2, 3, Array(2)]

но есть нюанс вложенный массив находится под индексом 3

если мы запушим на место индекса 3 какое-то значение оно будет добавлено во вложенный массив причем даже туда где 
присвоено значение с помощью спред

array_26[3].push(34)

let array_26 = [1,2,3,[5,6],]

let array_27 = [...array_26]

array_26.push(4)

console.log(array_26) //(5) [1, 2, 3, Array(2), 4]        
console.log(array_27) // (4) [1, 2, 3, Array(2)]

array_26[3].push(34)

console.log(array_26) 


(5) [1, 2, 3, Array(3), 4]
0: 1
1: 2
2: 3
3: (3) [5, 6, 34]
4: 4
length: 5[[Prototype]]: Array(0)
   
console.log(array_27)

(4) [1, 2, 3, Array(3)]
0: 1
1: 2
2: 3
3: (3) [5, 6, 34]
length: 4
[[Prototype]]: Array(0)

потому что в данном случае оператор спред сработал только по элементам массива родителя
а вложенные массивы остались скопированными по ссылке то есть все равно являются одним массивом

попытаемся решить эту проблему

применяем цикл

вместо спред

let array_28 = [1,2,3,[5,6],]

let array_29 = []
for(let i = 0; i < array_28.length; i++) {
    array_29[i] = array_28[i] // можно применить пуш
}

console.log(array_29) // (4) [1, 2, 3, Array(2)]

никаких отличий от спред - нет

и остаются такие же проблемы с вложенными массивами которые остаются присвоенными по ссылке
но для одномерных массивов цикл применять можно

применим map

let array_30 = [1,2,3,[5,6],]

let array_31 = array_30.map(x => x)

то есть я буду зеркалить один массив в другой

все равно добавляет во вложенный массив

пробуем filter
*/

let array_23 = [1,2,3]
let array_24 = array_23;

console.log(array_23) // (3) [1, 2, 3]
console.log(array_24) // (3) [1, 2, 3]

let array_25 = [...array_23]

array_23.push(4)

console.log(array_23) // (4) [1, 2, 3, 4]
console.log(array_24) // (4) [1, 2, 3, 4]
console.log(array_25) // (3) [1, 2, 3]

let array_26 = [1,2,3,[5,6],]

let array_27 = [...array_26]

array_26.push(4)

console.log(array_26) //(5) [1, 2, 3, Array(2), 4]        
console.log(array_27) // (4) [1, 2, 3, Array(2)]

array_26[3].push(34)

console.log(array_26) 
/* 

(5) [1, 2, 3, Array(3), 4]
0: 1
1: 2
2: 3
3: (3) [5, 6, 34]
4: 4
length: 5[[Prototype]]: Array(0)

*/     
console.log(array_27)
/* 

(4) [1, 2, 3, Array(3)]
0: 1
1: 2
2: 3
3: (3) [5, 6, 34]
length: 4
[[Prototype]]: Array(0)


копируем массив с помощью того что сработает 

let array_39 = [1,2,3,[5,6],]

let array_40 = JSON.parse(JSON.stringify(array_39))

array_39[3].push(77) этот пуш произошел только в массив array_39 и вложенные массивы остались неизменными

console.log(array_39) // (4) [1, 2, 3, Array(3)]
console.log(array_40) // (4) [1, 2, 3, Array(2)]

я вначале массив array_39 превращаю в json строку потом ее парсю и помещаю в массив array_40

но есть нюанс
эта операция достаточно накладна по операциям ресурсов то есть она требует достаточно высоких ресурсов
то есть если у вас большое количество вложенных массивов то это достаточно медленная операция

JSON stringify и JSON parse - ломают объекты вложенные внутрь вашего массива
если у вас будет объект date то проведя эту операция придется заново его инициализировать
поскольку эта операция его превратит на выходе в строку
и если у вас массив с вложенными структурами объектами то применять эту операцию нужно очень осмотрительно

хорош для простых массивов без большой вложенности с простыми типами данных

пробуем интересную фигню

let array_41 = [1,2,3,[5,6],]

let array_42 = array_41.concat([])
*/   

// копируем массив с помощью цикла

let array_28 = [1,2,3,[5,6],]

let array_29 = []
for(let i = 0; i < array_28.length; i++) {
    array_29[i] = array_28[i] // можно применить пуш
}

array_28[3].push(454)

console.log(array_28) // (4) [1, 2, 3, Array(3)]
console.log(array_29) // (4) [1, 2, 3, Array(3)]

// копируем массив с помощью map

let array_30 = [1,2,3,[5,6],]

let array_31 = array_30.map(x => x)

array_30[3].push(55)

console.log(array_30) // (4) [1, 2, 3, Array(3)]
console.log(array_31) // (4) [1, 2, 3, Array(3)]

// все равно доступ к вложенному массиву по ссылке

// копируем массив с помощью filter

let array_32 = [1,2,3,[5,6],]

let array_33 = array_30.filter(() => true)

array_32[3].push(66)

console.log(array_32) // (4) [1, 2, 3, Array(3)]
console.log(array_33) // (4) [1, 2, 3, Array(3)]

// все равно доступ к вложенному массиву по ссылке

// копируем массив с помощью reduce

let array_34 = [1,2,3,[5,6],]

let array_35 = array_34.reduce((array_36, elem) => {
    array_36.push(elem)
    return array_36
}, [])

array_34[3].push(66)

console.log(array_34) // (4) [1, 2, 3, Array(3)]
console.log(array_35) // (4) [1, 2, 3, Array(3)]

// все равно доступ к вложенному массиву по ссылке

// копируем массив с помощью slice

let array_37 = [1,2,3,[5,6],]

let array_38 = array_37.slice()

array_37[3].push(77)

console.log(array_37) // (4) [1, 2, 3, Array(3)]
console.log(array_38) // (4) [1, 2, 3, Array(3)]

// the same

let array_41 = [1,2,3,[5,6],]

let array_42 = array_41.concat([])

array_41[3].push(77)

console.log(array_41) // (4) [1, 2, 3, Array(3)]
console.log(array_42) // (4) [1, 2, 3, Array(3)]

// еще можно 

let array_43 = [1,2,3,[5,6],]

let array_44 = Array.from(array_43)

array_43[3].push(77)

console.log(array_43) // (4) [1, 2, 3, Array(3)]
console.log(array_44) // (4) [1, 2, 3, Array(3)]

// копируем массив с помощью того что сработает 
// < -------------------------------------------------------- Копирование массива если массив имеет вложенный массив
let array_39 = [1,2,3,[5,6],]

let array_40 = JSON.parse(JSON.stringify(array_39))

array_39[3].push(77)

console.log(array_39) // (4) [1, 2, 3, Array(3)]
console.log(array_40) // (4) [1, 2, 3, Array(2)]

// < -------------------------------------------------------- Копирование массива если массив имеет вложенный массив

// подобные задачи так же можно решить с помощью рекурсии
