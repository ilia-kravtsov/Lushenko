/*
// _______________________________________№1 Подключаем JS файл___________________________________________

// тег <script src="..."></script> подключает файл js к файлу html
//     его можно располагать и в head и в body, если расположить в хед то
// <!DOCTYPE html>
// <html lang="ru">
// <head>
//     <meta charset="UTF-8">
//     <link rel="stylesheet" href="./CSS_L.css">
//     <title>Lushenko</title>
//         <script>
//         alert('hello');
//         </script>
// </head>
// <body>
//     <h1>Lushenko_course.</h1>
//     <p>let's get started</p>
// </body>
// </html>


// код выше значит что к моменту выполнения JS будет выполнена только часть кода ниже

// <!DOCTYPE html>
// <html lang="ru">
// <head>
//     <meta charset="UTF-8">
//     <link rel="stylesheet" href="./CSS_L.css">
//     <title>Lushenko</title>
//         <script>
//         alert('hello');
//         </script>

// Ни нажатие кнопок и вывод информации на страницу - не возможно.

//             Поправочка (при изменении браузера изменяется внешний вид всплывающего окна)
//                        ( alert это вспомогательная системная функция ее не применяют для веб разработки)
//                        (нужна для отладки)

// Если подключить sript внутри body, то

// <!DOCTYPE html>
// <html lang="ru">
// <head>
//     <meta charset="UTF-8">
//     <link rel="stylesheet" href="./CSS_L.css">
//     <title>Lushenko</title>
// </head>
// <body>
//     <h1>Lushenko_course.</h1>
//     <p>let's get started</p>
//     <script>
//         alert('hello');
//     </script>
// </body>
// </html>

// в данном случае к моменту выполнения alert будет доступен вот этот участок кода

// <!DOCTYPE html>
// <html lang="ru">
// <head>
//     <meta charset="UTF-8">
//     <link rel="stylesheet" href="./CSS_L.css">
//     <title>Lushenko</title>
// </head>
// <body>
//     <h1>Lushenko_course.</h1>
//     <p>let's get started</p>
//     <script>
//         alert('hello');
//     </script>

// тегами h1 и p тоже можно манипулировать
// но такое подключение не практикуется
// для правильного подключения создаётся новый js файл

// Рекомендуется подключать js файл в самом низу документа перед закрывающимся тегом body
// в теге script в качестве атрибута указывается src и место расположения файла

// <!DOCTYPE html>
// <html lang="ru">
// <head>
//     <meta charset="UTF-8">
//     <link rel="stylesheet" href="./CSS_L.css">
//     <title>Lushenko</title>
// </head>
// <body>
//     <h1>Lushenko_course.</h1>
//     <p>let's get started</p>
//     <script src="JS_L.js"></script>
// </body>
// </html>

// alert('hello'); -- в консоли видим всплывающее окно hello
// Если alert не заработал, ищем ошибку в написании тега <script> либо атрибута src
// либо самого называния js файла в html документе

// Всё что будет в html документе выше тега <script> будет доступно для манипуляции

// На практике будет много js файлов

// если мы добавим несколько script тегов то к каждому js файлу нужно указывать источник src

// выглядит вот так

// <!DOCTYPE html>
// <html lang="ru">
// <head>
//     <meta charset="UTF-8">
//     <link rel="stylesheet" href="./CSS_L.css">
//     <title>Lushenko</title>
// </head>
// <body>
//     <h1>Lushenko_course.</h1>
//     <p>let's get started</p>
//     <script src="JS_L.js"></script>
//     <script src="JS_L2.js></script>
// </body>
// </html>   -- в консоли в начале отработает JS_L а потом JS_L2
// То есть js файл отрабатывает первым, если файл подключен первым, как js_l то
// он отработает в консоль первым
// Если файл подключен вторым он отрабатывает вторым

// Для проекта чаще всего практикуется создание отдельной папки для js файлов
// в этом случае нужно указать данный факт в пути src тега script

// Относительно html файл находится внутри папки js то есть
// в пути тега script src нужно указать

// <script src="js/JS_L.js"></script>

// Если не указать путь через папку в консоли увидим ошибку

// Так же Важный атрибут для script в html это defer иногда он пишется

// <script defer></script>

// Иногда в полном виде

// <script defer="defer"></script>

// defer - откладывает выполнение script до тех пор пока вся страница не будет загружена полностью

// то есть применение данного атрибута позволяет обезопасить себя от
// того что какая-то часть страницы не загрузится
// не успеет подгрузиться а мы попытаемся в ней работать js

// Используя defer тег script можно писать в любов месте html файла
// Иногда его применяют подключаяя sript внутри head

// Но чаще всего его не используют и применяют написание Javascript перед закрывающимся тегом body


// Атрибут async - асинхронный. поддерживается всеми браузерами кроме IE9
// Скрипт выполняется полностью асинхронно
// То есть при обнаружении <script async src=""> браузер не останавлиает обработку страницы
// А работает дальше. Когда скрипт будет загружен он выполнится

// то есть JS находит первый скрипт и начинает его выполнять
//     <script src="JS_L.js"></script>
// после его выполнения переходит на следующий скрипт
// Как только браузер видит async
// Он начинает выполнять следующий скрипт сразу же
//     <script src="JS_L2.js></script>
// Не дожидаясь окончания выполнения первого скрипта

// То есть будут выполняться два скрипта одновременно
// Это увеличивает скорость запуска
// Это позволяет делать множественные различные действия параллельно
// Это важно для игр и интерактивных объектов

// Но с другой стороны, если второй скрипт (который ниже в коде)
//     <script src="JS_L2.js></script>
// Требует результатов работы первого скрипта
//     <script src="JS_L.js"></script>
// Может случиться ошибка

// Далее переходим в JS_L.js
// */

// /*
// _______________________________________№2 Правила именования___________________________________________

// Идентификатор - это специальное слово которое позволяет нам обратиться к области памяти
//                 либо выполнить какие-то действия. Обратиться либо к переменной
//                 либо к функции
// В JS считается что именем переменной или именем фукнции необходимо правильно писать и исользовать
// такие имена.

// Под переменной мы скрываем какую-то число строку или значение true/false
// Такие обращения к таким областям памяти к значениям называются переменными.

// в JS для того чтобы обозначить переменную используют несколько способов

// Можно писать
// Первая буква должна быть либо $ либо _ либо латинская буква всё остальное -- Ошибка --
// 1 Латинские буквы
// 2 с маленькой буквы
// 3 Если переменая должна состоять из двух значений(слов) тогда нужно писать в стиле camelCase
// где каждое последующее слово начинается с заглавной буквы getElementById
// 4 Цифры - можно использовать (но не в начале переменной)
// customer1 - можно использовать customer_1 - можно использовать  1customer - нельзя использовать.
// 5 _ $ можно использовать
// 6 Помнить про чувствительность к регистру camelCase не то же самое что CamelCase


// Нельзя использовать
// 1 Первый символ не должен быть цифрой 1customer -- Ошибка -- как и название классов в CSS
// 2 ключевые слова: new name etc
// 3 русские буквы между английскими
// если заменим о русскую на o латинскую программа выдаст ошибку которую будет сложно выявить
// 4 пробелы
// 5 дефисы (в целом можно но на практике не стоит)

// Комментарий может быть

// однострочным //  закоментировать строку Ctrl + /
// многострочным /* ... */ // в некоторых случаях * ставят на каждой строчке, зачем?
// // Данные строки не будут восприниматься js

// /*
// В конце каждой строки необходимо ставить ; наличие пробелов перед ; роли не играет.
// Если необходимо создать переменную содержащую данные пользователя, то
// a = 'ivanov'; - плохой пример, название переменной не отражает сути переменной
// Транслитерации
// Polzovatel = 'ivanov'; - плохой пример, название переменной может смутить иностранных программистов

// Имена должны быть:
// 1 Максимально короткими
// 2 Максимально понятными

// Например для покупателя хорошим примером будет:
// customer
// Если нужно будет указать более конкретно, например имя покупателя, то
// customerName = 'ivan';
// Либо
// customer_Name = 'ivan';

// Через дефис не писать!

// Можно писать вот так:

// $customer_name

// Либо

// _customerName

// Для того чтобы вычислить что-то локально и пойти дальше подойдут

// temp temp1 etc

// В таком случае можно оставить комментарий temp - временная переменная
// Комментарии принято оставлять на английском языке

// Ширина прямоугольника

// rectWidth rectangularWidth rect_width rect_w

// Узнавать в каком стиле принято писать в кампании и использовать этот стиль

// ________________________________________№3 Типы переменных_________________________________________________

// Если я хочу вывести в консоль результат каких-либо операций, то */
// console.log(4/6); //  в консоли увидим 0.(6)
// /* Однако работать с переменными удобнее, так как изменив значение переменной не нужно будет менять
// каждое число отдельно, что ускоряет работу.
// */
// // var x;
// // x = 5 + 7;       не рекомендуется к использованию
// // console.log(x);  в консоли увидим 12

// // ------------------------------Объявление переменной и присваивание значения (var)
// /* Переменную перед её использованием нужно объявить! (инициализировать)
// Для этого в JS ввели такое понятие как "инициализация переменной"

// Инициализация переменной - это команда которая объявляет переменную (а создай здесь вот эту переменную)
// Пример:
// var = x; - значит начиная с 281-й строки я хочу использовать переменную x и дальше я могу с ней работать

// var x;             объявляю переменную х
// x = 5 + 7;         внутрь х кладу какое-либо значение
// console.log(x);    Когда обращаюсь к х я обращаюсь к этому значению - x = 5 + 7; в консоли увидим 12
// */
// // Добавим еще одну переменную y
// // если теперь вместо 7 поставить y то вместо 7 подставится 3, а в консоль выведется результат 5 + 3
// // var x;
// // var y;
// // y = 3;
// // x = 5 + y;
// // console.log(x);  в консоли видим 8

// // в качестве значения переменной может быть не только число но еще и строка
// x = 'Hello'; // - т.о. перезаписал значение переменной (обновил) что можно только с let и var
// // то есть до 297 строки х был равен 8, но на 297 строке я выкинул это значение 8
// // и записал в х значение Hello
// // то есть переменная - как ящик, в неё можно что-то положить, а что-то выкинуть и положить что-то ещё
// // иногда мы можем достать переменную произвести манипуляцию и положить обратно
// console.log(x); // в консоли видим(вкв) Hello
// // так же внутри переменной может быть true или false
// // обновим значение переменной ещё раз
// x = 6; // все предыдущие манипуляции с x выполняются но на 306 строке они полностью игнорируются
// // из x выкидывается всё и кладётся новое значение 6
// console.log(x); // вкв 6
// // обновим значение переменной ещё раз
// x = x + 4;
// // выражение выше значит: всегда сначала вычисляется та часть которая находится справа от =
// // до строки 310 x был равен 6 поэтому будет производиться вычисление
// // 6 + 4 = 10 и эта 10 кладётся внутрь x
// console.log(x); // вкв 10
// // запись x = x + 4; эквивалентна записи x += 4;
// x += 4;
// console.log(x); // вкв - 14 потому что на строке 310 x был равен 10, 10 + 4 = 14

// // в ES5 можно было выполнять такой манёвр даже после всего выше
// var x; // объявляю новую переменную x взамен той х которая была
// // это значило что с 10 строки x полностью становилась новой переменной
// // при этом все предыдущие вычисления так же производятся
// console.log(x);
// // но так как этой переменной не присвоено никакое значение то вкв - undefined
// // если я положу что-то в х то он будет равен этому значению, пример
// x = 7;
// console.log(x); // вкв 7
// /* Запись var x;
//        x = 7;  эквивалентна записи (Э) до var x = 7;
// В старом стандарте ES5 мы могли создавать заново одну и ту же переменную сколько угодно раз
// то есть запись
// var x = 7;
// var x = 8; с точки зрения ES5 - корректна вкв 8

// -------------------------------Всплытие переменной (hoisting)

// Более того имело место "всплытие переменной" hoisting
// то есть можно было объявить переменную внизу а начать пользовать ей вверху
// в результате чего переменная воспринимала операции выше и производила все указанные с ней манипуляции
// Грубо говоря, программа находила строку var x; и переносился её вверх, то есть первоначальная запись

// x = 6;
// x = x + 4;
// x += 4;
// var x;
// console.log(x);

// JS-ом читалась как

// var x;
// x = 6;
// x = x + 4;
// x += 4;
// console.log(x);

// И в итоге обе записи в консоли имели бы одинаковое значение

// Поэтому подход к переменной в ES6 был реорганизован

// ------------------------------ Типы переменных let и const (отличия)

// 1 в ES6 - отказались от ключевого слова var для того чтобы обозначить новые переменные
// 2 в ES6 - переменную объявляют (инициализируют) сокращением let
// let имеет похожие свойства с var за некоторыми исключениями */
// // let y;
// // y = 12;
// // console.log(y);  вкв 12
// /*
// Если мы продублируем это действие, то
// let y;
// y = 12;
// console.log(y);
// let y;
// y = 13;
// console.log(y); вкв - ошибка y - has already been declared

// то есть с let - объявить переменную дважды уже не получится это вызывает ошибку

// Отличие let от var и const

// let от var отличается тем что при let переменную нельзя объявлять дважды
// во вторых такое явление как "всплытие переменной" hoisting с let - вызывает ошибку
// вкв is not defined
// поэтому нельзя использовать переменную d ES6 не объявляя её
// все остальные операции манипуляции можно производить как и с предыдущим var
// (насколько знаю есть еще одно отличие в разнице действия области видимости переменной с var и let
// у переменных объявленных с помощью var область видимости ограничена функцией
// а у переменных объявленных с помощью let - блоком)
// let = y;
// y = 13; э let y = 13;

// Таким образом переменные объявляемые с помощью let должны быть объявлены в начале программы
// в начале функции в начале цикла или if

// второе серьёзное отличие let от var - область видимости */
// // var y = 5;
// // console.log(y);  вкв 5
// //  добавим условный оператор
// // if (1) {  если единица это правда всегда то будет выполняться console.log(y);
// //     console.log(y); /вкв - 5
// // }

// /*То есть в ES5 переменная var y была видна в глобальной области видимости (вне блоков)
// и была доступна везде либо если мы ее объявили так же внутри функции var y = 5; она была видна везде
// внутри функции(не блока)
// Другой пример */
// var y = 5;
//  // добавим условный оператор
// if (1) {  // если единица это правда всегда то будет выполняться console.log(y);
//     var y = 7;
//     console.log(y); // вкв - 7
// }
// console.log(y); // вкв - 7

// /* То есть если переменная объявлена с помощью var то она будет видна как в блоке так и вне его пределов
// и выполнятся будет по стандартному свойству наследования, какое значение ниже в коде, то и является
// последним если из --

// var y = 5;
// if (1) {
//     var y = 7;   -- убрать ключевое слово var, и останется только y = 7; резльтат будет такой же
//     console.log(y); вкв - 7
// }
// console.log(y); вкв - 7

// ---------------------------------- Замыкание 77

// Если тоже самое написать с let */
// let z = 5;
// if (1) {
//     let z = 7; // но если здесь убрать let смотри ниже 77 (замыкание)
//     console.log(z); // вкв 7
// }
// console.log(z); // вкв 5

// /* то есть let имеет область видимости ограниченную блоком и такая переменная не существует
// вне блока внутри которого она объявлена

// 77 (Замыкание) - в этом случае оба console.log(z); выдадут 7

// Если внутри блока js не находит объявление переменной z и
// после этого выходит за пределы блока и ищет объявление переменной z с помощью ключевого слова вне блока,
// если находит let z = 5; то js перезаписывает значение которое было в коде ниже,
// то есть z = 7; в let z = 7; и т.о. в обоих console.log(z); мы видим 7 если переменная
// не была объявлена внутри блока с помощью ключевого слова let, - это и есть замыкание

// ---------------------------------- Далее опять раздел отличия let var const

// а если переменная была объявлена внутри блока с помощью ключевого слова let,
// то оба console.log действуют в пределах своих областей видимости
// первый в пределах своего блока
// второй в пределах глобальной области видимости

// если вместо z = 7; внутри блока указать var z = 7; вкв has already been declared
// потому что область видимости var выйдет за пределы этого блока и встретится там с
// let z = 5;
// Поэтому если убрать какое-либо ключевое слово, то ошибки не будет и будет 2 значения 7
// Если подставить var то будет ошибка в связи со столкновением областей переменных
// А если и там и там подставить let то первый лог загрузит 7 а второй 5
// таким образом каждая область видимости будет действовать в своих пределах

// Область видимости let - блок любой степени вложенности
// Область видимости var - функция(не блок)

// Если объявить переменную let вне блоков она будет считаться глобальной переменной и будет видна
// вне любых блоков, если объявить переменную let внутри блока она будет видна только внутри этого блока
// и всем, вложнным внутрь этого блока, блокам.

// Итак главное отличие let от var в том что области видимости let z = 7; заключены внутри блока
// в котором данный let z = 7; - объявлен, если let z = 7; не объявлен с помощью let.
// а просто указано z = 7; то внутри блока js не находит объявление переменной z и
// после этого выходит за пределы блока и ищет объявление переменной z с помощью ключевого слова вне блока
// если находит let z = 5; то js перезаписывает значение которое было в коде ниже, то есть z = 7;
// в let z = 7; и таком образом в обоих console.log(z); мы видим 7 если переменная не была объявлена
// внутри блока с помощью ключевого слова let, а если переменная была объявлена внутри блока с помощью
// ключевого слова let, то оба console.log действуют в пределах своих областей видимости
// первый в пределах своего блока
// второй в пределах глобальной области видимости

// Так же внутри ES6 стали использовать новый тип переменной - константу const

// Константа const - это тип переменной при котором переменная не изменяет своего значения. */

// const a = 9;
// // a = 88; после const a = 9; - запрещено (в отличие от let)
// //     при константе переменная не изменяет своего значения
// //     такая попытка в консоли выведет Assignment to constant variable at такой то строке
// // a = a + 5; или a += 5; после const a = 9;
// //     вызовет ту же ошибку в консоли Assignment to constant variable at такой то строке
// // const a = 10; после const a = 9;
// //     так же вызовет ошибку indentifier 'a' has already been declared
// console.log(a); // вкв 9
// // но мы можем использовать значение переменной объявленной с помощью const с другими переменными
// // пример
// let n = 3 + a;
// console.log(n); // вкв - 12

// // Часто константы объявляют большой буквой const A = 7;
// const A = 10;
// /*Константа const не меняет своего значения, но const может изменять свойства
// Если у вас есть массив или объект вы можете менять его свойства,
// хотя массив и объект может оставаться константой */

// // var - не используем, но понимаем как работает.

// //____________________________________№4 Undefined & Undeclared_________________________________________
// /*
// Не объявленная & не идентифицированная переменная*/
// let u = 5;
// let p = 7;
// console.log(u*p); // вкв 35
// // Если мы введём переменную t которой у нас нет, то
// // console.log(u*p*t); // вкв t is not defined э undeclared
// // t не определено поскольку система не могла найти переменную с таким идентификатором
// // комментируем консоль лог выше и объявляем переменную t
// let t; // но не присваиваем ей значение
// // в этом случае
// console.log(u*p*t); // вкв NaN (Not a Number)
// /*То есть попытка обратиться к переменной которая была объявлена, но ей не присвоено значение,
// привела к тому что в консоли появилось значение Not a Number
// u есть p есть t не определено, умножение на неопределённость дало NaN

// Если напищем в консоль лог просто вывести t*/
// console.log(t); // вкв undefined посколько в переменную t не положено значение
// /*Если let t; законментировать и после этого вызвать console.log(t);
// консоль покажет t is not defined э undeclared
// То есть ошибки происходят в принципе по логике одинаковые, но вызывают разные варианты ошибок
// Выводы
// Если видим is not defined значит - переменная не была объявлена
// Но если мы её (переменную) объявили (let = t;)
// Но не присвоили ей значение то она по умолчанию равна undefined

// Undefined - переменная в которую ничего не положили (пустая коробка)
// is not defined - переменная не объявлена

// Если перед t убрать ключевое слово let, то в консоли увидим is not defined
// то есть мы получаем ту же самую ошибку когда переменная не была объявлена

// ----------------------Use strict
// Строка "use strict" ставится в начале скрипта, она необходимо для того чтобы сказать браузеру
// что мы жестко придерживаемся стандарта ECMA SCRIPT 6 и мы будем работать конкретно в нём
// потому что современные стандарты позволяют идентифицировать такие вещи как необъявленные переменные
// с меньшими потерями. всё что делали в предыдущем разделе итак было по use strict, но если использовать
// use strict с var, то всё будет точно так же :)
// Если мы перед объявлением всех переменных добавим use strict то*/
// "use strict"
// var r = 2;
// var f = 1;
// var q;
// console.log(q); // undefined просто q - is not defined,
// // is not defined э undeclared

// //___________________________________№5 Hoisting (всплытие, поднятие переменной)__________________________________
// /*Если мы выведем не существующую переменную в лог, то получим undefined,
// Если мы выведем в лог переменную которая будет только объявлена, то получим is not defined

// А если мы сначала вызовем ранее не объявленную переменную в лог, а потом её объявим
// то в консоли увидим undefined, пример: */
// //            ---|
// console.log(L);//|
// var L; // ---|       лог undefined такой же если бы var L; было бы выше console.log(L);

// /*Данное явление и называется Hoisting или всплытие, поднятие переменной

// Когда JS разбирает код и в каком-то блоке находит команды для работы с переменными типа
// console.log(L); JS продолжает смотреть есть ли переменные в данном блоке (в том числе и ниже лога)
// если переменные есть, то фактически происходит следующее
// JS находит лог затем начинает искать объявление переменной и когда находит это объявление ниже в коде
// начинает его поднимать выше лога в результате:

// console.log(L);            var L;
//         var L;      э      console.log(L);

// Hoisting - процесс в работе JS при котором, переносится
// именно объявленная переменная вверх логического блока

// Минус Hoisting
// Если используем значение которое мы вообще не использовали ранее
// в этом случае переменная вместо того чтобы выдать ошибку is not declared (undeclared)
// выдаст ошибку undefined и программист будет думать что напутал с вычислениями ранее,
// но используется переменную которой ещё нет в принципе потому что где-то ниже
// переменная где-то была объявлена и использована.

// поэтому сначала переменная объявляется и только потом с ней производятся какие-либо действия

// Если мы присвоим L значение 5
// */
// console.log(L);
// var L = 5; // лог undefined процесс всплытия hoisting поднятия переменной
// // относится только лишь к объявлению переменной
// //  и в этом случае наверх JS поднял только var L; а дальнейшую часть не прочёл
// // поскольку она нарушает логику программы

// // Если
// //                                          ES5
// console.log(b);
// var b = 7;
// console.log(b);
// b = 5;
// console.log(b); // лог undefined 7 5

// // в первом логе переменная хотя и была не объявлена из-за всплытия объявилась
// // но ей значение не присвоилось и она равна undefined в логе
// // во втором логе мы присвоили значение переменной 7 и b стала равна 7
// // и в третьем логе присвоили значение переменной 5 и она стала равна 5

// // то есть всплытие работает только лишь на объявление переменных (var b)
// // всплытие работает внутри блока, если вы внутри функции объявляете переменные
// // они всплывут к началу функции, но присвоится значение им уже позже когда
// // вы явно его присвоите b = 5;
// // код выше относится к ES5

// //                                          ES6

// // let m = 99;
// // console.log(m); // лог покажет 99
// // теперь если мы укажем let m = 99; ниже console.log(m); то
// // let m = 99; в логе будет is not defined
// // то есть всплытие в ES6 сразу вызывает ошибку
// // то есть в ES6 всплытие переменной не происходит это приводит к ошибке
// /* в ES6 попытка применить всплытие в ECMASCRIPT 6 приводит к ошибке
// в ES6 объявление переменных и соответственно заполнение происходит в том месте
// где вы его сделали всплытие не происходит, то есть этот факт
// исключает ошибку
// когда после того как переменную мы используем а она undefined мы не можем сказать в ES5
// мы ее где-то не правильно вычислили не присвоили значение или мы её не объявили
// в эта ошибка была убрана поэтому
// Где объявили после этого и используйте */

// //___________________________№6 Типы данных в JS Variables and Types_____________________________________________
// /* в ES6 Типов данных ещё нет но в Angular 2 они есть
//    в любом случае при выполнении операций JS присваивает переменной определённый тип
//    и в зависимости от типа результат операции может значительно отличаться

// -----------------------------Основные типы данных в JS
// 1 Число, числовой тип
// */
// let aa = 8;
// console.log(aa);
// // Для того чтобы узнать тип данных существует специальная функция typeof
// console.log(typeof aa); // лог number
// let bb = 8.3;
// console.log(typeof bb); // лог number
// // Если заменить 8.3 на 8,3 то
// // let bbb = 8,3;
// // console.log(typeof bbb); // лог unexpected number
// // потому что дроби в js пишутся через точку
// // итак не важно дробь это или число тип данных всё равно number
// // 8 - целое число
// // 8.3 - число с плаващющей запятой (а почему с запятой если в js дроби с точкой)

// // Следующий тип данных это строка
// let cc = 'Helloy'; // так как это строка её нужно взять в кавычки
// console.log(typeof cc); // лог string

// let d;
// let e;
// console.log(typeof d*e); // Лог NaN not a number
// // NaN выводится когда одному из элементов выражения не присвоено значение
// // NaN не является типом данных, это просто результат выполнения арифметической операции
// // к элементам которые не являются числами

// // Если
// console.log(typeof d); // лог undefined
// // можно спорить является ли d типом данных или нет, но можно сказать что это специальное значение
// // Специальный результат JS в том случае когда переменную мы объявили но не присвоили ей значение

// // Ещё один тип данных - null
// // Если я попытаюсь сослаться на пустой объект я должен взять указатель на этот объект
// // Если указателя нет - мы получим null

// let ff = true; // boolean значение принимает всего два вида true / false
// console.log(typeof ff); // лог boolean
// // если убрать в команде console.log(typeof ff); typeof то
// console.log(ff); // лог true
// // если мы обновим переменную на false то
// ff = false;
// console.log(ff); // лог false, при этом тип данных не изменится и останется boolean
// // изменится только значение с true на false

// // Есть такое явление как массивы
// let g = [2, 3, 4];
// // Если мы попытаемся вывести тип данных массива, то
// console.log(typeof g); // лог object
// // то есть все массивы в js это - объект,
// // соответственно над ним можно выполнять операции как над объектом

// //________________________________№7 Базовые операции JS____________________________________________

// //                        Базовые операции над типами данных в JS

// // Допустим у нас есть несколько переменных
// let aaaa = 5;
// let bbbb = 2;
// // выведем в консоль результаты операций

// // Сложение aaaa + bbbb
// console.log(aaaa + bbbb); // лог 7
// // в JS знак + используется как для сложения двух чисел так и для сложения двух строк (конкатенации)

// // Вычитание aaaa - bbbb
// console.log(aaaa - bbbb); // лог 3

// // Умножение aaaa * bbbb
// console.log(aaaa * bbbb); // лог 10

// // Деление aaaa / bbbb
// console.log(aaaa / bbbb); // Лог 2.5

// // Остаток от деления remainder
// console.log(aaaa % bbbb); // Лог 1
// // То есть сколько раз можно использовать двойку внутри пятёрки
// // 2 * 2 = 4; 5 - 4 = 1; 1 - remainder

// /* Операнд – то, к чему применяется оператор.
// Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2.
// Иногда их называют «аргументами» вместо «операндов».

// Знаки между 5 и 2 называются операторами ( + - * / )*/

// // Если
// console.log(aaaa > bbbb); // то Лог True
// // данный оператора называется оператором сравнения
// // он возвращает true если операция верна (а куда возвращает?)
// // операторы сравнения могут быть > <
// console.log(aaaa < bbbb); // Лог false
// // может быть >=
// console.log(aaaa >= bbbb); // Лог true
// // <=
// console.log(aaaa <= bbbb); // Лог false

// // в некоторых случаях нам нужно узнать Не равно, пишется !=
// console.log(aaaa != bbbb); // Лог true

// // проверка на равенство, а равно ли ==
// console.log(aaaa == bbbb); // Лог false

// // Итого проверка на равенство == проверка на неравенство !=
// // Больше равно >= Меньше равно <=
// // Один знак равно = означает Присваивание

// // Со строками
// let ccc = 'Helloy';
// // что будет если умножить Helloy на aaaa
// console.log(ccc*aaaa); // Лог NaN not a number
// // То есть попытка умножить строку на число приведет к значению Not a number
// // Потому что число и строка не могут быть умножены друг на друга

// // Если поделим
// console.log(ccc/aaaa); // Лог NaN

// // Если вычтем
// console.log(ccc-aaaa); // Лог NaN

// // Так происходит потому что над строками не предполагается математических операций
// // умножение деление вычитание, но над строками разрешена операция сложения
// // Данная операция сложения применительно к строкам называется конкатенация

// // Если сложим
// console.log(ccc+aaaa); // Лог Helloy5
// // Если поменяем местами слагаемые
// console.log(aaaa+ccc); // Лог 5Helloy

// // Если есть строка которая визуально выглядит как число
// let dd = '8';
// // Если выполним операцию сложение, то
// console.log(dd+aaaa); // Лог 58 но в результате мы получаем не число 58 итоговый тип 58 - string
// // при добавлении в команду атрибута typeof 5 - number 8 - 8
// /* off course
// console.log(typeof dd + aaaa); сработает как
// console.log((typeof dd) + aaaa);
// Если я хочу узнать тип итоговой операции после dd + aaaa то
// console.log(typeof (dd + aaaa);*/
// console.log(typeof (dd + aaaa)); // Лог string

// /* чтобы такого не происходило нужно при сложении научиться перегонять
// вот такого вида строки '8' в числа
// затем чтобы когда мы вычитываем число из элемента input в html(поле ввода)
// То Js получит доступ к этому элементу в виде строки
// то есть если в поле ввода в html ввести 7, то 7 придёт ввиде строки
// и это проблема так как мы не можем строки складывать чтобы в итоге получить число

// ---------------------------Преобразование строк в числа Prompt(Незамедлительный)

// Учимся получать числа в простом виде на практике не используем, но понимаем

// Метод Prompt - выводит окно с кнопками ок и cancel, если нажать cancel всё закрывается и
// ничего не происходит, если я нажимаю ок, то возвращается то что я ввёл внутри данного окна*/
// //  let ee = prompt ('Enter a number', '');
// //  console.log(ee); // лог всплывающее поле ввода с кнопками ок и отмена,
// // где заголовок поля Enter a number, а пустое значение '' - поле ввода
// // вводим 9 нажимаем ок, тогда в логе вижу 9
// // то есть мы с помощью prompt организовали ввод чисел
// // Если получить тип переменной ee, то
// //  console.log(typeof ee); // лог string
// // то есть введя в поле ввода число на выходе я получаю тип данных строка
// // и теперь если понадобится вывести результат
// // console.log(ee + 24); // лог если в этот момент во всплывающее поле ввода ввести 5, то
// // в логе мы получим 524 а не 29 и соотв. тип данных у 524 будет string
// // JS возвращает из всех подобных окон как input prompt etc - тип данных строка
// // а для строк знак + обозначает конкатенацию которая и происходит

// // поэтому всегда когда мы получаем что-либо из элемента ввода мы обязаны
// // преобразовать эти данные в соответствующий тип например число
// // некоторые операции производят это автоматически, если поставить / или умножить
// // а со строками таких операций в принципе нет то
// // console.log(ee * 24); // лог 72, (в поле вводил 3)
// // то есть значение 3 из поля ввода правильно было умножено на 24,
// // так же будет и с делением если вписать в поле ввода 48 в логе будет 2
// // так же будет и с вычитанием если вписать в поле воода 25 в логе будет 1

// // но если попытаться сделать то же самое со сложением то будет включаться механизм конкатенации

// // -------------- Как преобразовать тип данных строка в число при конкатенации или сложении
// /* Вариант 1 вводим +ee и проверяем*/
// // console.log(ee + 24);
// // +ee; // лог 324 при вводе 3, то есть всё равно остался тип данных - строка
// // потому что результат был слеплен, попробуем написать +ee в операции
// // console.log(+ee + 24); //лог 27 при вводе 3, РАБОТАЕТ!
// // ПРИМЕЧАНИЕ этот метод работает и с 3.5 в отличие от parseInt
// // но этот метод на работает если ввести в поле 3.5a в этом случае лог - NaN
// // а в parseFloat - 27.5
// // Итак 1 вариант преобразовать строку из поля ввода в число это написать в операции +varibale
// // то есть поставить + перед той переменной которая выводит значение которое вводится в поле ввода
// // это не всегда удобно поэтому существуют другие способы:

// // Способ №2 Чётко преобразовать строку к числу, для этого сущ-ет след-щая операция
// // parseInt(ee)
// // console.log(parseInt(ee) + 24); // лог 25 при вводе 1 РАБОТАЕТ!
// // parseInt это специальная конструкция, специальная функция которая получает
// // переменную ввиде строки и пытается её преобразовать в число
// // в отличие от первого способа(прибавления +) parseInt будет работать даже на сложных числах т.е.
// // 4а будет преобразовано к 4, 45ds будет преобразовано к 45
// // но а2 уже не будет преобразовано и выведет соответственно Not a Number
// // проверим введя в поле 3a лог 27 3-ку смогло считать

// // проблема в том что parseInt не сможет считать 3.5, проверим
// // в логе видим 27 то есть JS дочитал до 3 а .5 отбросил
// // потому что . тоже считается строкой и значение отбрасывается

// // Способ №3 Если необходимо преобразовать десятичное число то существует оператор parseFLoat
// // который позволяет считывать дроби
// // console.log(parseFloat(ee) + 24); // лог 27.6 РАБОТАЕТ и при десятичном числе и одновременно
// // при 3.6a лог так же будет 27.6

// // как же понять что ввёл пользователь какой именно тип данных
// // для этого в JS существует конструкция isNaN
// // console.log( isNaN(3)); // лог true
// // NaN это Not a number не число
// // is значит если hello не число то вывести в консоль true
// // то есть если мы введём в команду число то в логе увидим false независимо от того что введем в поле
// // то есть isNaN это функция которая проверяет что введенное значение не является числом
// // тогда она даёт true

// //_________________________________№8 Условные операторы____________________________________________

// /*Операторы ветвления в JS
// Операторы ветвления нужны если необходимо выполнить какое- либо действие по определенному условию
// Существуют два основных направления операторов ветвления

// Первый оператор - if */
// // let zz = 1; // если zz будет равно 9 я хочу выводить допустим всплывающее окнок alert
// // // с каким-либо текстом, если нет - не выводить
// // // оператор if имеет вид
// // /* if (условие верно) то тогда выполнять действие заключённое в фигурных скобках {
// //     таких действий может быть несколько, если действие одно можно обойтись без фигурных {}
// // }

// // Пример ниже:
// // --------I if Работает простро реагированием на какое-то значение либо не реагируем вообще
// // Если а, если я хочу проверить на равенство я должен поставить == (а равно ли?)
// // if (a == 9) {}; - если переменная а равна 9, то {действие}*/
// // if (zz == 9) {
// //     alert('Yes'); // лог вижу всплывающее окно yes //// когда только одно действие можно писть не через {}
// // }
// // если поменяем zz = 1 то alert не выскочит, то есть if работает как переключатель
// // а именно если условие верно мы выполняем то что в скобочках
// // оператор if позволяет просто проверить условие и либо выполнить действие либо
// // не делать ничего
// // будут встречаться два варианта событий,
// // Если условие верно и если условие не верно, то есть как реагировать на поступившие условия
// // Для этого существует следующий синтаксис
// // if (условие верно) то тогда выполнять действие заключённое в фигурных скобках {
// //    таких действий может быть несколько, если действие одно можно обойтись без фигурных {}
// // }

// /*------II if else обязательно реагирует либо одним либо другим
// Но если наша задача представляет из себя развилку (вилку) где в любом случае должно
// что- то сработать пишется оператор else и далее просто пишется действие {действия}
// которые будут выполнены если условия не верны*/
// // let xx = 5;
// // // если xx = 5 то alert ('xx = 5');
// // if (xx == 5) {
// //     alert ('xx = 5');  // когда только одно действие можно писть не через {}
// // }
// // // в противном случае else выведи окно алерт b не равно 5
// // else {
// //     alert ('xx != 5'); // когда только одно действие можно писть не через {}
// // }
// /* Программа работает сл образом
// Присваиваем переменной xx значение 5
// Если условие xx = 5 верно, то будет выполняться действие alert ('xx = 5');
// то есть будет выполняться только часть программы if а else выполняться не будет
// Если условие xx = 5 не верно, то будет выполняться действие alert ('xx != 5');
// то есть будет выполняться только часть программы else а if выполняться не будет

// Таким образом если задача поддаётся решению (в виде развилки) либо то либо то жёстко задано
// Когда мы пишем оператор if else в любом случае какой-то из них будет выполнено третьего не дано

// -------III Сравнение двух чисел

// Два числа могут быть
// 1-е > 2- го
// 2-e > 1-го
// 1-e === 2-му     */
// // let vv = 4;
// // let nn = 4;
// /* в завивимости от того какое число больше либо меньше либо равно я должен отреагировать
// для этого существует расширенный список if else
// Так как одно действие пишем в одну строчку без {} но если несколько команд то {} обязательны */
// // if (vv>nn) alert('vv больше'); else alert('nn больше');
// /* если после этого написать else (в противном случае, то есть в любом если условие не выполнилось)
// в данном примере условие не совсем верно сформулировано, если написать значение переменной vv = 4
// то выполнится часть программы после else потому что else выполняется в любом случае
// из этого нужно выходить более расширенным синтаксисом if else если задача предусматривает вилку не
// двух путей а 3-х 4-х 8-ми мы можем воспользоваться синтаксисом else if который позволяет
// описать значительно больше условий в одном блоке

// if (vv>nn) то else if(nn>vv) alert('nn больше'); и третий вариант  else alert('числа равны') */
// // if (vv>nn) alert('vv больше'); else if (nn>vv) alert('nn больше'); else alert('числа равны');
// /* РАБОТАЕТ!!!
// else if может быть несколько
// if (vv>nn) alert('vv больше');
// else if (nn>vv) alert('nn больше');
// else if (nn>vv) alert('nn больше');
// else if (nn>vv) alert('nn больше');
// else if (nn>vv) alert('nn больше');
// else alert('числа равны');

// Если мы дошли до этого условия соответственно осуществляем выход из оператора else if
// Когда мы пишем этот оператор в любов случае что-то из этого блока
// if else if else - обязательно сработает

// ЕСЛИ ЕСТЬ ELSE ЗНАЧИТ ЧТО-ТО ОБЯЗАТЕЛЬНО СРАБОТАЕТ
// Даже если все предыдущие условия не верны выполнится последний else
// Но можно обходиться и без последнего else в этом случае если ни одно из условий не будет
// выполнено в конце просто ничего не сработает, и это не критично поскольку ничего делаться не будет

// -------- IV Тернарный оператор

// Тернарный оператор это упрощённая конструкция if else
// Тернарный оператор позволяет нам записать код ниже в другом виде

// let xx = 5;

// if (xx == 5) {
//         alert ('xx = 5');
// }
// else {
//         alert ('xx != 5');
// }

// Пусть у нас будет такая конструкция мне нужно проверить какое-либо условие
// Если оно верно выполнить его, если оно не верно выполнить что-то другое*/
// // let xx = 15;
// // // условие ? то yes     : else no    ;
// // xx == 15 ? alert('yes') : alert('no');
// // условие? команда при положительном результате выполнения условия : к п отриц вып условия ;
// /*Только в том случае если внутри if всего лишь одна команда или одно действие (либо то либо это)
// и есть конструкция if else то мы можем воспользоваться тернарным оператором

// условие в тернарном операторе берется в скобки затем знак вопроса
// всё что до вопроса считается условием, часть до двоеточего выполнится если условие верно
// после двоеточего если условие ошибочно

// Ограничение использования тернарного оператора, тернарный оператор ограничен в одном случае, в том
// если у вас несколько команд то внутрь тернарного оператора их не поместить это будет не работающая
// конструкция */

// // Задача 1

// // Пользователь вводит два числа, найти и вывести максимальное из двух чисел.

// // let rr = 4;
// // let tt = 4;

// // if (rr>tt) {
// //     console.log(rr);
// // }
// // else if (tt>rr) {
// //     console.log(tt);
// // }
// // else {
// //     console.log('числа равны');
// // }

// // // Задача 2

// // // В первом подъезде квартиры с 1 по 20
// // // во втором                 с 21 по 48
// // // в третьем                с  49 по 90
// // // пользователь вводит номер квартиры.
// // // программа должна указать в каком подъезде находится данная квартира
// // // программа должна учитывать вариант ввода чисел за пределами диапазона 1 - 90

// // let apartNumber = prompt ('Enter an apartNumber', '');

// // if (apartNumber < 21) {
// //     console.log('1 подъезд');
// // }
// // else if (apartNumber>21 && apartNumber<48) {
// //     console.log('2 подъезд');
// // }
// // else if (apartNumber>49 && apartNumber<90) {
// //     console.log('3 подъезд');
// // }
// // else {
// //     console.log('Не существующий номер квартиры');
// // }

// // РАБОТАЕТ!!!!!!!!!!!!!!!!!!!!!

// // Задача 3

// /* Пользователь вводил логин и пароль.
// Если логин и пароль совпадают с указанными ниже,
// то выводится "Добро пожаловать". Если не совпадают, то "Ошибка входа"

// Данные для задачи:

// логин    ivan     alex    petr
// пароль   334455   777     b5678 */

// let ivan = '334455';
// let alex = '777';
// let petr = 'b5678';

// if (ivan == '334455') {
//     console.log('Добро Пожаловать');
// }
// else {
//     console.log('Ошибка входа');
// }

// if (alex == '777') {
//     console.log('Добро Пожаловать');
// }
// else {
//     console.log('Ошибка входа');
// }

// if (petr == 'b5678') {
//     console.log('Добро Пожаловать');
// }
// else {
//     console.log('Ошибка входа');
// }

// // РАБОТАЕТ!!!!!!!!!!!!!!!!!!!!!

// // Задача 4

// /* Пользователь вводит год рождения. Программа показывает количество лет и если лет больше
// или равно 16, то пишет - "добро пожаловать", если нет "вход воспрещён"*/

// // let yearOfBirth = prompt ('Enter an yearOfBirth', '');
// // console.log(2022-yearOfBirth);
// // let sixteen = 2022-yearOfBirth;
// // if (sixteen>=16) {
// //     console.log('Добро пожаловать');
// // }
// // else {
// //     console.log('Вход воспрещён');
// // }

// // РАБОТАЕТ!!!!!!!!!!!!!!!!!!!!!

// //__________________________№9 Дебагер Javascript_______________________________________________________

// let ha;
// let hb = 9;
// let hc;
// hc = ha+hb;
// if (hc = hb) {
//     alert ('равно');
// }
// alert(hc);


// /* В консоли вкладка Sources
// там можем открыть текущий js файл и работать с ним

// Программа представлена в виде строк, строки пронумерованы

// Напротив строки которую я хочу посмотреть я могу поставить точку остановки Break point
// он ставится кликом на строке, так же и убирается

// Как только я поставил Break Point браузер будет при выполнении останавливаться
// и ждать моих дальнейших указаний на счёт программы, то есть после запуска программы
// при наличии break point программы выполнится только до Break point и остановится

// Об этом сообщает Paused in debugger посередине экрана

// При наведении на переменную если она довольно сложная мы можем получить
// если нам это необходимо, подсказку о том, что эта переменная содержит*/


// let v = 9;
// let III = 10;
// let rec = 10;

// // отработал, метод фиксирования печатанием считаю не эффективным, нужно делать через повторение


//_____________________________________________Цикл For while_________________________________________________________

// let out = document.getElementById('out');
// let temp = '';

// цикл с заданным количеством повторений, самый быстрый цикл JS - for

// for (start;/* условие; затем условие работы, работаем пока условие верно*/ if-true; /* шаг изменения*/ step ){
//     /*Здесь пишем что мы будем повторять */

// }
// /*до тех пор пока i<15 цикл будет работать, дальше указываем как будет изменяться i, i будет изменяться с шагом 1*/
// for (let i = 0; i<20; i = i + 1 ) {
//     if (i == 5) continue; // continue прерывает не весь цикл а его текущий круг
//     console.log(i);
// }

/*до тех пор пока i<15 цикл будет работать, дальше указываем как будет изменяться i, i будет изменяться с шагом 1*/
// for (let i = 0; i<20; i = i + 1 ) {
//     console.log(i);
//     if (i == 5) break; // break - прерывает цикл, то есть как только она выполняется цикл останавливается и мы из него выходим
// }

// мы можем убрать start и поставить его перед циклом
// let i = 0
// for (; i<20; i = i + 1) {
//     console.log(i);
// } // в логе от 1 до 19-и

// можем вынести и step результат будет тем же

// let i = 0
// for (; i<20;) {
//     console.log(i);
//     i = i + 1;
// }

// while (// условие) { // если условие верно нас пускают в цикл

// }
// let i = 0;
// while (i < 8) {
//     i++;
//     console.log(i);
// }

//__________________________________________# 11 Массивы Javasrcipt_________________________________________________
//
// let a = [];
// let b = [12, 13, 66, 999];
// console.log(b.length)
//
// let c = [3, 'Hello', true];
// console.log(c)
// c[2] = 999;
// c[5] = 777;
// delete c[5];
// console.log(c)
//
// let out = document.getElementById('out');
// let str = '';
// for (let i = 0; i<c.length; i++) {
//     if(c[i] !== undefined)
//     str += i + ' - ' + c[i] + '<br>';
// }
// out.innerHTML = str;

//____________________________________________# 12 Методы массивов_____________________________________________________
//.push() добавляет элементы в конец массива
// let a = [2,7];
// a.push('hello')
// a.push(65)
// console.log(a)
//
// //.pop() позволяет удалить последний элемент массива
// let b = a.pop();
// a.shift();
// a.unshift('world');
// console.log(a);
//
// let f ="Hi, my, name, Ivan";
// let d = f.split(',');//trim - позволяет избавиться от пробелов
// let j = d.slice(1,3);
// console.log(d);
// console.log(d.join(''));
// console.log(j);

// let a = [92,7, 8, 33, 'hello'];
// let [b, c] = a;
// console.log(b,c)

// let p = document.getElementsByTagName('p');
// console.log(p);
// for (let i = 0; i<p.length; i++) {
//     p[i].style.color= 'red';
// }
//
// let p1 = document.getElementsByClassName('ttt')
// console.log(p1);
//
// let p2 = document.querySelectorAll('.ttt');
// for (j=0; j<p2.length; j++){
//     p2[j].onclick = function() {
//         alert('work')
//     }
// }
// console.log(p2);

// let a = 30
// let b = 30
//  a > b ? console.log('a - больше'): b > a ? console.log('b - больше'): console.log('числа равны');

// for (let i = 0; i < 20; i++ ) {
//     if (i == 5) continue; // прерывает не весь цикл а только его итерацию
//
//     console.log(i)
// }
//
// for (i=0; i<20; i++) {
//     console.log(i)
//     if (i == 5) break; // прерывает весь цикл
// }
// i = 0
// while (i<8) { //условие если верно пускает в цикл) {}
//     i++
//     continue
//     console.log(i)
//
// }

// for (let i = 1; i <= 9; i++) {
//     let b = i*7;
//     console.log('7 * ' + i + ' = ' + b);
// } // таблица умножения 7

// let a = [];
// let b = [13, 14, 56, 73];
// console.log(b.length);
// let c = [3, 'hello', true];
// console.log(c);
// c[1] = 896
// console.log(c)
// c[5] = 928
// console.log(c);
// delete c[5];
// console.log(c);
//
// let t = document.getElementById('out')
// let str = ''
// for (let i = 0; i < c.length; i++) {
//     if (c[i] !== undefined) {
//         str = str + i + ' - ' + c[i] + '<br>'
//     }
// }
// out.innerHTML = str;
//
// let y = [13, 35];
// y.push('hello')
// y.push(124);
// console.log(y)
// let r = y.pop()
// console.log(r)
//
// y.shift()
// console.log(y)
// y.unshift('world')
//
// let as = 'My, name, is, ivan';
// let sa = as.split(',');
// console.log(sa); // => ['My', ' name', ' is', ' ivan']
//
// console.log(sa.join())
//
// let sj = sa.slice(1,3);
// console.log(sj)
//
// let rty = [0, 1, 2, 3, 4, 5, 6, 7, 8]
// let ax = rty.slice(4,8);
// let [az, bz, zc] = ax
// console.log(az, bz, zc);
// let p = document.getElementsByTagName('p')
// console.log(p);
// for(i = 0; i<p.length; i++){
//     p[i].style.color = 'red';
// }
//
// let o = document.getElementsByClassName(('ttt'))
//
// for (let joj = 0; joj<o.length; joj++) {
//     o[joj].onclick = function() {
//         alert('хватит нажимать')
//     }
// }
//
//
// let r = [-4, -3, -2, -1, 0, 1, 2, 3, 4]
// let zero = 0;
// for (let k = 0; k < r.length; k++) {
//     zero = zero + r[k]
// }
// console.log(zero / r.length);
// console.log(Math.max.apply(null, r))
//______________________________________________________________Зашло_________________________________________________
// let temp2 = [
//         [3, 6, 3],
//         [4, -5, 6],
//         [7, 8, -9]
// ];
// console.log("-----")
// for (let u = 0; u < temp2.length; u++) {
//     Sred = 0;
//     for (let jo = 0; jo < temp2[u].length; jo++) {
//         Sred = Sred + temp2[u][jo];
//     }
//     console.log(Sred / temp2[u].length);
//     console.log('t min'+Math.min.apply(null, temp2[u]))
//     console.log('t max'+Math.max.apply(null, temp2[u]))
// }
//_____________________________________________Map________________________________________________________________
// let ter = [10, 20, 30];
// ter[5] = 40;
// delete ter[5];
// let newter = [];
// for (let i = 0; i<ter.length; i++) {
//     newter[i] = ter[i]*2;
// }
// console.log(ter);
// console.log(newter);
// console.log('_______________')
// let c = ter.map(function(x, y,z){
//     return x*2
// })
// console.log(c)
// let a = [12, -5, 30, 56, -34, 78, -9]
// let b = []
//
// for (i=0; i<a.length; i++) {
//     if (a[i]>0) b.push(a[i])
// }
// console.log(a)
// console.log(b)
// let a = [12, -5, 30, 56, -34, 78, -9]

// let b = a.filter(function (x,y){
//     return x%2===1;
// })
// console.log(b);


//     for (let i = 1; i <= 10; i++) {
//          let b = i*5;
//          console.log(i + ' * 5' + ' = ' + b);
//   }

//   1 * 5 = 5
//  2 * 5 = 10
//  3 * 5 = 15
//  4 * 5 = 20
//  5 * 5 = 25
//  6 * 5 = 30
//  7 * 5 = 35
//  8 * 5 = 40
//  9 * 5 = 45
//  10 * 5 = 50

// function multiTable(number) {
//     return `1 * ${number} = ${1*number}
//     2 * ${number} = ${2*number}
//     3 * ${number} = ${3*number}
//     4 * ${number} = ${4*number}
//     5 * ${number} = ${5*number}
//     6 * ${number} = ${6*number}
//     7 * ${number} = ${7*number}
//     8 * ${number} = ${8*number}
//     9 * ${number} = ${9*number}
//     10 * ${number} = ${10*number}`
//     }
// переворот слов
// function reverseWords(str){
//     return str.split(' ').reverse().join(' ');
//   }

// let a = 'hi my name ilia'
// console.log(a)           // => hi my name ilia
// let b = a.split(' ')
// console.log(b)           // => 6 ['hi', 'my', 'name', 'ilia']
// let c = b.join(' ')
// console.log(c)           // => hi my name ilia

// let v = [5, 4, 3, 2]
// let f = v.slice(1,3)
// console.log(f)           // => 4,3

// let a =  [0, 1, 2, 3, 4, 5, 6, 7]
// let [ b, c, e, t, y, u, i ]= a
// console.log(b, c, e, t, y, u, i ) // => 0 1 2 3 4 5 6

// let p = document.getElementsByTagName('p')
// console.log(p)
// for (let i = 0; i<p.length ; i++) {
//     p[i].style.color='red'
// }

// let b = document.getElementsByClassName('ttt')
// console.log(b)

// for (let j = 0; j<b.length; j++) {
//     p[j].onclick= () => {
//         alert('work')
//     }
// }

// let q =[-4, -3, -2, -1, 0, 1, 2, 3, 4]
// let CA = 0;
// for (let k = 0; k<q.length; k++) {
//     CA += q[k]
// }
// console.log('++++++')
// console.log(CA/q.length) // => 0
// console.log(Math.max.apply(null, q)) // => 4
// console.log(Math.min.apply(null, q)) // => -4

// let w = [
//     [1, 2, 3],
//     [4, 5, 6],
//     [7, 8, 9],
// ]

// for (e = 0; e<w.length; e++) {
//     CA = 0
//     for (let r = 0; r<w[e].length; r++) {
//         CA += w[e][r]
//     }

//     console.log('-----------')
//     console.log('t middle = '+CA/ w[e].length)
//     console.log('t max = '+Math.max.apply(null, w[e]))
//     console.log('t min = '+Math.min.apply(null, w[e]))
// }

/* => -----------
JS_L.js:1447 t middle = 2
JS_L.js:1448 t max = 3
JS_L.js:1449 t min = 1
JS_L.js:1446 -----------
JS_L.js:1447 t middle = 5
JS_L.js:1448 t max = 6
JS_L.js:1449 t min = 4
JS_L.js:1446 -----------
JS_L.js:1447 t middle = 8
JS_L.js:1448 t max = 9
JS_L.js:1449 t min = 7
 */
// let i = 0
// for ( ; ; ) {
//     i<15
//     i++
//     if (i === 5) break;
//     console.log(i);

// }

// let i = 0;
// while (i<8){
//     continue
//     console.log(i);
//     i++;
// }


// // => вывести числа от 4 до 400 на экран
// for (let i = 4; i<= 400; i++) {
//     console.log(i)
// }

// // => вывести числа от 4 до 13 с шагом 3 на экран
// for (let i = 4; i <=13; i += 3) {
//     console.log(i);
// }

// => вывести числа 654 653 652 - до нуля
// for (let i = 654; i>=0; i-- ) {
//     console.log(i);
// }

// //=> вывести все годы с 1983 до 2017
// for (let i = 1983; i<=2017; i++) {
//     console.log(`${i} год`)
// }

// // => вывести все числа от -4 -2 до 100
// for (let i = -4; i<=100; i+= 2) {
//     console.log(i);
// }

// => таблица умножения на 7 от 1 до 9

// for (let i = 1; i<=9; i++) console.log(`${i} * 7 = ${i*7}`)

// ->
// 1 * 7 = 7
// 2 * 7 = 14
// 3 * 7 = 21
// 4 * 7 = 28
// 5 * 7 = 35
// 6 * 7 = 42
// 7 * 7 = 49
// 8 * 7 = 56
// 9 * 7 = 63

// let a = [];
// a = [10, 11, 12, 13, 14, 15];
// a[7] = 17;
// console.log(a);
/* ->
(8) [10, 11, 12, 13, 14, 15, empty, 17]
0: 10
1: 11
2: 12
3: 13
4: 14
5: 15
7: 17
length: 8
[[Prototype]]: Array(0)
 */
// let c = [3, 'ilia', true];
// c[5]=17;
// console.log(c)
// delete c[5];
// console.log(c);
// let c = [3, 'ilia', true]
// c[5] = 17;
// delete c[5];
// let out = document.getElementById('out');
// let str = '';
// for (let i = 0; i < c.length; i++) {
//     if(c[i] !== undefined) str += i + ' - ' + c[i] + '<br>'; // -> мы просто отображаем все элементы массива с пробелами с обоих сторон
// }
// out.innerHTML = str;
// // -> на странице - 3 ilia true undefined undefined undefined

// let a = [2, 7];
// a.push('hello');
// a.push(65);
// console.log(a);
// a.pop();
// a.pop();
// a.pop();
// a.pop();
// a.pop();
// console.log(a);

// let a = [2, 7, 4];
// a.shift();
// a.unshift(2);
// console.log(a);
// // -> [2, 7, 4];

// let a = 'Однажды в студёную зимнюю пору я из лесу вышел';
// let b = a.split(',');
// console.log(b)

// const array1 = ['a', 'b', 'c'];

// array1.forEach(element => console.log(element));
// a b c

// const elements = ['Fire', 'Air', 'Water'];

// console.log(elements.join());
// // expected output: "Fire,Air,Water"

// console.log(elements.join(''));
// // expected output: "FireAirWater"

// console.log(elements.join('-'));
// // expected output: "Fire-Air-Water"

// console.log(elements.join(' '))

// let p = document.getElementsByTagName('p');
// console.log(p);
// for (let i = 0; i<p.length; i++) {
//     p[i].onclick = () => alert('work');
// }

// let temp = [-4,-3,-2,-1,0,1,2,3,4]
// let middle = 0;
// for(let i = 0; i<temp.length; i++) {
//     middle += temp[i]
// }
// console.log(middle/temp.length);
// // -> 0
// console.log(Math.max.apply(null, temp))
// console.log(Math.min.apply(null, temp))

// let temp = [
//     [-4, 0, 3, 13],
//     [-5, -1, 8, 12],
//     [0, 3, 6, 11],
//     [0, 3, 6, 11],
// ]

// for (let i = 0; i<temp.length; i++) {
//     let middle = 0;
//     for (let k = 0; k<temp[i].length; k++) {
//         middle += temp[i][k]
//     }
//     console.log('t middle = ' + middle/temp[i].length);
//     console.log('t min = ' + Math.min.apply(null, temp[i]))
//     console.log('t max = ' + Math.max.apply(null, temp[i]))
// }

// let str = '12345';
// let reversed = Array.prototype.map.call(str,(x)=>x).reverse().join('');
// console.log(reversed);


// function sum(x, y, z) {
//     return x + y + z;
//   }

//   const numbers = [1, 2, 3];

//   console.log(sum(...numbers));
// let a = [3,4,5]
// let c = a.map((x)=>x*2)
// console.log(c);
// let a = [3, -12, 0, 4, 5, -8];
// // let b = [];
// // for (let i = 0; i<a.length; i++) {
// //     if (a[i]>=0) b.push(a[i])
// // }
// // console.log(a);
// // console.log(b);
// // let c = a.filter((x)=>x>0)
// // console.log(c);
// // console.log(a);

// // let c = a.filter((x, i)=>i%2===0)
// // console.log(c);

// let c = a.filter((x)=> x%2===0)
// console.log(c)
// let a = 0;
// b()
// function b () {
//     console.log(a)
//     let c = 9;
// }
// console.log(c)
// function summ (a=0, b=5) {
//      console.log(a+b)
// }

// summ()
// function er () {
//     return summ()
// }
// er()

// function show (t) {
//     if (t>0) return '>0'
//     else if (t<0) return '<0'
//     else return '=0'
// }

// function sum (a,b) {
//     let t = 0
//     console.log(a+b)
//     console.log(show(t))
// }

// console.log('----')
// console.log(show(1))
// console.log(sum(2,2))

// let a = {};
// a.hi = 'test';
// console.log(a);
// console.log(a.hi);
// console.log(a['hi']);

// let b = {
//     hi: 'ilia',
//     yet: 'of course'
// }

// let y = 'hi' in b;
// console.log(y); // -> true поиск ключа в массиве через переменную.
// console.log(b);
// delete b.yet;
// console.log(b);
// b.nowway = 'oh yeap'
// console.log(b.yet);
// console.log(b); // -> {hi: 'ilia', nowway: 'oh yeap'}

// let a = {
//     one: 'Hello',
//     name: 23
// }

// let b = a;
// b.five = 5;
// console.log(a); // -> {one: 'Hello', name: 23, five: 5}
// console.log(b); // -> {one: 'Hello', name: 23, five: 5}

// let a = {
//     one: 'Hello',
//     two: 'world'
// }

// let b={};

// for (let key in a) {
//     b[key] = a[key];
// }
// console.log(a);
// console.log(b);
// b.three = 'ok'
// a.three = 'allright'
// console.log(a); // -> {one: 'Hello', two: 'world', three: 'ok'}
// console.log(b); // -> {one: 'Hello', two: 'world', three: 'allright'}

// function f1() {
//     let div = document.querySelector('#yeap');
//     div.innerHTML += ' Hello'
// }

// f1();

// function f2() {
//     let div = document.querySelector('#yes');
//     div.innerHTML += ' Hello'
// }

// f2();


// function f3() {
//     c.innerHTML += ' Hello'
// }

// let c = document.querySelector('#seven');
// f3();
// c = document.querySelector('#eight');
// f3();

// // ------------------------------

// function f4(z){
//     let d = document.querySelector('#'+z)
//     d.innerHTML+=' it\'s work '
// }
// f4('seven')
// f4('eight')

// let one = document.querySelector('#one');

// console.log(one);

// function myClick(event) {
//     console.log('click');
//     console.log(event.target);
// }

// one.onclick = myClick;

// const c = {
//     t: 0
// }
// c.a = 8;
// console.log(c.a);
// console.log(c);
// c.t = 2;
// console.log(c);
// /*Log 6 8
// JS_L.js:1787 {t: 0, a: 8}
// JS_L.js:1789 {t: 2, a: 8}*/

// const b = ['ilia', 'ivan']
// b.push = 'oleg';
// console.log(b); // -> ['ilia', 'ivan', push: 'oleg']

// console.log('hello');
// console.log('world');
// console.log('Hello' + 'world');
// console.log('Hello' + ' ' + 'world');
// console.info('hello')
// console.table('hello')

// document.getElementById('one').innerHTML = 'Alone'
// document.getElementById('one').innerHTML = 1
// document.getElementById('one').innerHTML = '<b>1</b>' // js интерпретирует и сделает 1 жирным

// document.getElementsByClassName('header').innerHTML = 'some' // странно

// document.querySelector('.header').innerHTML = 'Plactice'
// document.querySelector('.header').innerHTML = 'Practice'

// let a = document.querySelector('.header');
// a.innerHTML = 'Plactice'
// console.log('09');
// console.log('Добро ' + 'пожаловать ' + 'на курс');
// a.innerHTML = 'Pratcice'


//___________________________________JavaScript 2.0_________________________

//___________Task 1

console.log('ilia');

//___________Task 2

console.log('09');

//___________Task 3

console.log(`Добро пожаловать на курс`);

//_______________________Основа ввода данных работа с input____________________
let inputIn = document.querySelector('.input_in');
let buttGo = document.querySelector('.butGo');
let divOnPage = document.querySelector('.onPage');

buttGo.onclick = function () {
    console.log('button work'); // -> button work
    // console.log(inputIn.value); // value то что введено в input
    let braiton = +inputIn.value
    console.log(b + 7); // -> 37 если ввели в input 3
    divOnPage.innerHTML = braiton
    inputIn.value = '';
} // -> т.о. мы можем читать значение из input
// математические манипуляции между числом и строкой возможны только при сложении
// деление на 0 - Infinity
// сложение и конкатенация пишутся одинаково, поэтому при вводе в input 3
// и прибавлении 7 в логе получится не 10 а 37
// из input JS получает любые введенные данные в виде строки
/* console.log(b + 7) -> '3' + 7 = '37' произошла конкатенация
+inputIn.value - преобразует тип данных в number
console.log(b + 7) -> 3 + 7 = 10

Если в html у input поставить в type не text а number то в input можно
будет вводить только числа, но из input все равно будет приходить тип данных строка
и это не спасет ситуацию, зато +inputIn.value - да
+ перед элементом, переводит элемент в тип данных - число

чтобы очистить поле input надо input.value = '' присвоить пустую строку*/


//_____Ветвление_____________Условные операторы If else switch case__________

/* 
Всё что внутри {} выполнится если условие выдаст true 
{} - блок действий
Если Действие одно {} не нужны

Одиночный if либо работает если условие выдаёт true, либо ничего не происходит
*/
// let a = 6;
// if (a > 9) {
//     // true
//     console.log('Yes'); // -> Yes
// }
/*
Если требуется выполнить жёстко либо то, либо это, и никаких других вариантов, то
добавляется else (без условий)
в любом случае одно из двух действий сработает

Если мы пишем if (){} а затем else{} то в любом случае должно сработать одно из двух

!= - не равно
*/
// else {
//     console.log('else');
// }

/*
Пользователю необходимо ввести возраст и если он больше 16 - welcome
если меньше - доступ запрещен

Если нужно добавить еще условие добавляем else if () {}
их может быть сколько угодно

ageUser >= 16 && ageUser < 100 - диапазон

&& - И - срабатывает и выдает true только если оба условия верны
|| - ИЛИ - срабатывает и выдает true если одно из условий верно
*/

//_____________Task 1

let a = 7;
let b = 9;
console.log(a * b);

//_____________Task 2

let c = 7;
let d = 9;
console.log(c / d);

//_____________Task 3

let e = 3;
let f = 5;
console.log(e + f);

//____________________________Тест возраста if else_______________________________

const ageUserTry = document.querySelector('.age');
let buttonUserTry = document.querySelector('.ageTry');
let divUOP = document.querySelector('.ageOnPage');

buttonUserTry.onclick = () => {

    let ageUser = +ageUserTry.value;

    if (ageUser >= 16 && ageUser < 100) {
        divUOP.innerHTML = 'Welcome';
    }
    else if (ageUser >= 100) {
        divUOP.innerHTML = 'Do you really need to go in?'
    }
    else {
        divUOP.innerHTML = 'Access Denied';
    }

    switch (ageUser) {
        case 15:
            console.log('Eщё годик потерпи!');
            break;
        case 16:
            console.log('Топи!');
            break;
        default:
            console.log('ok');
    }

}
// если выполняется первый if дальше выполнение - не идёт

// ________________Task 1

let button1 = document.querySelector('.firstBut');
let input1 = document.querySelector('.firstInp');
let output1 = document.querySelector('.firstDiv')

button1.onclick = () => {
    let num1 = +input1.value;

    if (num1 == 4) {
        console.log(true);
        output1.innerHTML = 'true'
    }
    else {
        console.log(false);
        output1.innerHTML = 'false'
    }
}

// _______________Task 2

let button2 = document.querySelector('.secondBut');
let input2 = document.querySelector('.secondInp');
let input22 = document.querySelector('.secondInp2');
let output2 = document.querySelector('.secondDiv')

button2.onclick = () => {

    let a21 = +input2.value
    let a22 = +input22.value

    if (a21 > a22) {
        output2.innerHTML = a21
    }
    else if (a22 > a21) {
        output2.innerHTML = a22
    }
    else {
        output2.innerHTML = `${a21} = ${a22}`
    }

}

//________________Task 3

let button3 = document.querySelector('.thirdBut');
let inp3 = document.querySelector('.thirdInp');
let inp33 = document.querySelector('.thirdInp2');
let output3 = document.querySelector('.thirdDiv');

button3.onclick = () => {

    let a31 = +inp3.value
    let a32 = +inp33.value

    if (a31 > a32) {
        output3.innerHTML = a31
    }
    else if (a32 > a31) {
        output3.innerHTML = a32
    }
    else {
        output3.innerHTML = `${a31} = ${a32}`
    }

}

//____________________Работаем с формами___________________________


// Type input 'password'

document.querySelector('.buttPasswordClass').onclick = () => {
    console.log(document.querySelector('#inpPasswordId').value);
}

// Type input 'color'
// присваиваем значение для переменных сокращая код

let buttonColor = document.querySelector('.buttColorClass');
let inputColor = document.querySelector('#inpColorId');

buttonColor.onclick = () => {
    console.log(inputColor.value);
    // Задаём стили для кнопки и присваеваем фону кнопки выбранный в палитре цвет
    buttonColor.style.backgroundColor = inputColor.value
}

// Type input 'date'

document.querySelector('.buttDateClass').onclick = () => {
    console.log(document.querySelector('#inpDateId').value); // -> 2022-10-28
}

// Type input 'range'
// хотим двигать ползунок и смотреть как меняются события для этого есть событие oninput
// oninput срабатывает каждый раз когда меняется состояние элемента

document.querySelector('#inpRangeId').oninput = () => {
    // console.log(document.querySelector('#inpRangeId').value); // для вывода в консоль
    document.querySelector('#divOutValueInput').innerHTML = document.querySelector('#inpRangeId').value;
}

document.querySelector('.buttRangeClass').onclick = () => {
    console.log(document.querySelector('#inpRangeId').value)
}
 
// Type input checkbox

let checkboxValue = document.querySelector('#checkbox_1');
document.querySelector('.buttCheckClass').onclick = () => {
    if (checkboxValue.checked) {
        document.querySelector('#divOutCheck').innerHTML = true
    }
    else {
        document.querySelector('#divOutCheck').innerHTML = false
    }
}

// _____ Textarea

document.querySelector('#buttTextAreaId_1').onclick = () => {
    document.querySelector('#divOutTextarea_1').innerHTML = document.querySelector('#textareaId_1').value;
    document.querySelector('#textareaId_1').value = '';
}

// _____ Form

document.querySelector('#buttTextAreaId_2').onclick = (event) => {
    event.preventDefault();

    let arrayForm = [
    [document.querySelector('#textareaId_2').value],
    [document.querySelector('#inpForm_2').value]
    ]

    document.querySelector('#divOutTextarea_2').innerHTML = arrayForm;

    let form = document.querySelector('form')
    console.log(form);
    console.log(form[0].value);
    console.log(form[1].value);
    document.querySelector('#textareaId_2').value = '';
    document.querySelector('#inpForm_2').value = '';
}

// итого form можно пользоваться как массивом.

// Task 1 

    document.querySelector('#buttTask_1').onclick = () => {
        document.querySelector('#divOutTask_1').innerHTML = 1;
    }

// Task 2

    document.querySelector('#inpTask_2').onclick = () => {
        document.querySelector('#divOutTask_2').innerHTML = 2;
    }

// Task 3

    document.querySelector('#pTask_3').onclick = () => {
        document.querySelector('#divOutTask_3').innerHTML = 3;
    }

// Task with round braces 
// Если количество ( совпадает с ) выдать true если нет false 

let taskBraces = '()(()()())';

let countBraces = 0;

for (let i = 0; i<taskBraces.length; i++) {

    if (taskBraces[i] === '(') {
        countBraces++;
    }
    if (taskBraces[i] === ')') {
        countBraces--;
    }
    if (countBraces < 0) {
        break;
    }
   
}

console.log('--------');
if (countBraces !== 0) {
    console.log(false);
}
else {
    console.log(true)
}

// ________________________Циклы в JS_______________________________________

// for

/* for (условия на основании которых цикл либо выполняется либо не выполняется) {
    блок команд которые будут повторяться,
    все что я здесь напишу будет многократно повторяться при работе цикла если 
    условия в скобках ранее - верны    
 }

for (1-е start; 2-е работаем пока верно, по сути финиш, верхняя граница; 3-е как изменяется счётчик) {
    блок команд которые будут повторяться,
    все что я здесь напишу будет многократно повторяться при работе цикла если 
    условия в скобках ранее - верны   
}

если условие изначально не верно цикл не выполнится ни разу
*/

// простой цикл

// for (let i = 0; i<5; i++) {
//     console.log(i);
// }

/* 
   бесконечный цикл

   цикл работает пока верно условие, а в данное случае условие будет верно всегда

for (let i = 0; i>0; i++) {
    console.log(i)
}


из цикла можно выйти заранее if i == 4 break;
break - прерывание цикла
*/
console.log('-------')

for (let i = 0; i<5; i++) {
    if (i == 4) {
        break;
    }
    console.log(i);
}

let divCircles = document.querySelectorAll('.circles'); // получает 1 элемент подходящий под параметры и прекращает свою работу
// querySelectorAll - создаст коллекцию (массив) nodelist из элементов подходящих под условия
// divCircles.style.background = 'red'

for (let i = 0; i<divCircles.length; i++) {
    console.log(divCircles[i]);
    divCircles[i].style.background = 'red'
    divCircles[i].onclick = strangeFunc
}

function strangeFunc() {
    console.log('work');
}

let getEls = document.getElementsByClassName('circles'); // создает коллекцию элементов

console.log(getEls);

for (let i = 0; i<getEls.length; i++) {
    getEls[i].style.border = '2px solid lightgray'
}

// Radio buttons

document.querySelector('#buttRadioId_1').onclick = () => {

    let radioAttempt = document.querySelectorAll('input[type="radio"]')

    console.log(radioAttempt);
    
    for (let i = 0; i<radioAttempt.length; i++) {
        if (radioAttempt[i].checked) {
            console.log(radioAttempt[i].value);
        }
    }
}

// let i = 0 - видна в пределах области видимости своего блока

// continue - прерываение одной итерации цикла

let someVar = ''

for(let i = 0; i<10; i++) {
    if (i === 6) continue;
    someVar = someVar + i + ' '
}
document.querySelector('#continueId').innerHTML = someVar

// Task 1

document.querySelector('#buttCirclesId_1').onclick = () => {

    let varTask1 = ''

    for (let i = 0; i<17; i++) {
        varTask1 = varTask1 + i + '_'
    }
    document.querySelector('#divCirclesId_1').innerHTML = varTask1
}

// Task 2

document.querySelector('#buttCirclesId_2').onclick = () => {

    let varTask2 = ''

    for (let i = 12; i<39; i = i + 2) {
        varTask2 = varTask2 + i + '_'
    }
    document.querySelector('#divCirclesId_2').innerHTML = varTask2
}

// Task 3

document.querySelector('#buttCirclesId_3').onclick = () => {

    let varTask3 = ''

    for (let i = 25; i>6; i--) {
        varTask3 = varTask3 + i + '_'
    }
    document.querySelector('#divCirclesId_3').innerHTML = varTask3
}

// _________________________________Вложенные циклы___________________________________________

let doec = document.querySelector('#divOutEnteredCircles')

for (let i = 0; i < 6; i++) {
    // i = 0
    for(let k = 0; k < 10; k++) {
    // k = 0    
    doec.innerHTML += k
    }
    doec.innerHTML += ' ' // здесь можно указать тег <br> вместо пробела, тогда вывод будет в столбик
}

for (let i = 0; i < 10; i++) {
    doec.innerHTML += '7*' + i + '=' + (i*7) + '<br>'
}

// Интерполяция

for (let i = 0; i < 10; i++) {
    doec.innerHTML += `7*${i}=${i*7}<br>` // таблица умножения на 7
}

// Полная таблица умножения

let MultiTable = document.querySelector('#divOuMultiplyTable')

for (let i = 0; i < 10; i++) {

    for(let k = 0; k < 10; k++) {
        MultiTable.innerHTML += `${i}*${k}=${k*i}<br>`
    }

    MultiTable.innerHTML += `<hr>`
}

// Task 1 

let doft_1 = document.querySelector('#divOutForTask_1')

for (let i = 0; i < 3; i++) {

    for(let k = 0; k < 3; k++) {
        doft_1.innerHTML += '*'
    }
    doft_1.innerHTML += '_'
}

// Task 2

let doft_2 = document.querySelector('#divOutForTask_2')

for (let i = 0; i < 3; i++) {

    doft_2.innerHTML += `${i}<br>`

    for(let k = 0; k < 3; k++) {
        doft_2.innerHTML += '*_'
    }
    doft_2.innerHTML += '<br>'
}

// Task 3

let doft_3 = document.querySelector('#divOutForTask_3')

for (let i = 0; i < 3; i++) {

    for(let k = 0; k < 3; k++) {
        doft_3.innerHTML += '*_'
    }
    doft_3.innerHTML += '<br>'
}

// Task 4

let doft_4 = document.querySelector('#divOutForTask_4')

for (let i = 0; i < 3; i++) {

    for(let k = 0; k < 3; k++) {
        doft_4.innerHTML += '10'
    }
    doft_4.innerHTML += '<br>'
}

//__________________________________________Функции_________________________________________

function first() {
    console.log('firstFunctionWork');
}

/* После первого прочтения файла JS видит функцию и ее имя, но внутрь функции не заходит
и соответственно при первом чтении внутренние ошибки внутри функции не видит,
чтобы функция сработала нужно вызвать функцию, только тогда JS обратится к внутреннему содержимому функции

чтобы вызвать функцию нужно написать one(); */ 

first(); // -> firstFunctionWork

// так же можно повесить вызов содержимого функции на кнопку

let buttForFirstFunction = document.querySelector('#buttForFirstFunction'); // получил кнопку

// присваиваю кнопке функцию по клику

buttForFirstFunction.onclick = first; // - здесь пишем вызов функции без скобок

/* если я напишу выше first() то данная функция просто отработает и результат ее работы запишется 
в свойство слева от знака присвоения
{тело функции} 
{console.log('firstFunctionWork');} - функция просто выполняет набор действий в других языках такие функции называются процедуры
в данном случае функция просто вводит firstFunctionWork в консоль, внутри могут быть и циклы и функии if else и т.д.

Но функция может не только выполнять какие-либо действия (процедуры) но и возвращать значение

Если функци просто выполняет какой-то набор действий, то результатом ее выполнения привызове

console.log(first()); -> станет undefined то есть данная функция ничего не возврщает назад программе, 
каких-либо данных которые мы могли бы использовать дальше

return - делает так чтобы функция возвращала свое последнее значение полученное в результате операций
в коде функции выше return

return - метка функции прекратить свою работу и если функция выполняется в каком-то выражении,
то вместо имени функции подставить то, что стоит в одной строке с return

по сути функция это такая же переменная значение которой присваивается не через знак = а после слова return*/

function second() {
    console.log('secondFunction');
    return 'secondFunctionReturn'
}

second(); // -> secondFunction 2 раза потому что в функции  console.log('secondFunction');
second(); // -> secondFunction 3 раза потому что в функции  console.log('secondFunction'); и до этого вызывали 1 раз

console.log('really ' + second()); // -> really secondFunctionReturn

function second2() {
    console.log('secondFunction2');
    return 2
}

console.log(2 * second2); // NaN
console.log(2 * second2()); // 4 - если результат операций поставить в return то так могу использовать функцию внутри математических действий
// 

let cc; 

function multi() {
    let a = 9;
    let b = 8;
    console.log(a*b);
    cc = (a*b)+1 
}

multi(); // -> 72 как теперь можно использовать 72 дальше? - никак пока нет return 
// либо можно добавить переменную с за пределами функции описать ее действие внутри функции и использовать дальше

console.log(cc); // 73 таким образом можем вытянуть из области видимости функции нужно нам значение
// но это же действие и выполняет слово return

// что происходит если я вместо сс запишу return

let aa = 10;
let bb = 9;

function multiply() {
    console.log(aa*bb);
    return aa*bb
}

// теперь я могу пользоваться именем фукнции для использования результата ее деятельности записанного после return
// теперь я могу объявить любую переменную и присвоить ей результат выполнения функции


let v = multiply();
console.log(v/2); // -> 45 то есть я использую в дальнейшем функцию и её значение просто как переменную

/* В ES6 переменные имеют блочную область видимости
Если в области видимости конкретной функции используется переменная которая в пределах этой области видимости {}
Не обоъявлена, то JS выходит за пределы области видимости {} и ищет используемую переменную 
в глобальной области видимости, если находит - использует ее в пределах области видимости функции


multiply()
() - это специальное место для параметров, аргументов функции
с параметрами, аргументами функция будет иметь такой синтаксис*/
console.log('------');

function multiply_2(x, y) {
    // манипуляция параметрами осуществляется внутри функции
    return x*y
}

/* multiply_2() -> undefined потому что при указании параметров, аргументов при написании функции 
я должен поставить значения на место параметров и аргументов при вызове функции иначе undefined,
так как в функции у нас только return то при вызове функции добавим console.log иначе undefined.

Потому что по умолчанию в ES6 можно использовать параметры по умолчанию
то есть:
function multiply_2(x = 20, y = 5) {...} если при вызове функции задаются значения для x и y
multiply_2(21,6) то данные из вызова заменят значения из параметров по умолчанию и станет:
function multiply_2(x = 21, y = 6) {...}
но если будет указан только один параметр или ни одного то, тогда внутрь функции будут приняты 
недостающие значения аргументов из параметров по умолчанию в порядке очереди
 */

console.log(multiply_2(2,3)) // -> 6 функция выполнила своё действие
console.log(multiply_2(20,5)); // -> 100
// таким образом значения указанные при вызове функции попадают на вход на место аргументов функции (параметров)
// function multiply_2(x = 20, y = 5) {return 20*5}
// будет работать в том числе если в качестве параметра подставить переменную aa из глобальной области видимости
console.log(multiply_2(aa,7)); // -> 70

//__Функций это способ решения основной проблемы программирования - дублирования кода
// написал код 1 раз использовал infinity раз

// все что написано в коде после return выполняться не будет 

//___ Анонимные функции
/*
function (){
    console.log('ilia');
}

Анонимная функция это способ организации кода в некий блок

Такие функции принято использовать там где функции вызываются всего лишь 1 раз
Именованые функции можно использовать любое количество раз используя имя

Синтаксис анонимных функций в ES6 был дополнен стрелочными функциями

Стрелочная функция это один из способов написания анонимных функций

let arrowFunction = () => {

}

это аналог анонимной функции
() => {}    
function (){} - the same

Напишем несколько функций и переведем их в анонимные
*/
document.querySelector('#anonimusFunction_1').onclick = function (){
    console.log('+++++++')
}

/*
document.querySelector('#anonimusFunction_1').onclick = () => {
    console.log('+++++++');
}

Если я сделаю вторую такую операцию одному и тому же элементу присвою дважды свойство onclick 
будет работать только последнее предыдущее будет проигнорировано */

document.querySelector('#anonimusFunction_2').onclick = () => {
    console.log('---');
}

// Сокращения стрелочной функции

(a,b) => {

}

// Если у нас только один параметр в функции

a => {
    return 'ilia'
}

a =>'ilia' // a возвращает строку ilia

/* Итог:
    Функция это способ организации кода 
    Функция может просто делать какие-то действия
    Либо возвращать своё значение
    Когда говорят функция возвращает своё значение 
    Понимается что её можно присвоить переменной 
    И внутрь переменной после выполнения функций попадёт результат ее выполнения
    
    Возвращение значения функции означает что ее можно поставить в какое-то
    математическое выражение либо в конкатенацию и получить осмысленный результат
    
    Функции бывают двух видов - именованые - их можно использовать многократно
    И анонимные - без имени - используются один раз для удобного написания кода
    
    В функцию можно передавать параметры, они передаются через запятую и указываются при создании функции
    Параметром в ES6 можно присвоить значения по умолчанию через запятую, затем их можно подставить и использовать
    
    Стрелочные функции по разному работают с this
    Работа в обычных анонимных функциях и в стрелочных функциях - разная*/

// _____ Task 1

let a1 = 11;

document.querySelector('#buttonForFunctionTask_1').onclick = () => {
    document.querySelector('#divOutForFunctionTask_1').innerHTML = a1;
}

// _____ Task 2

let a2 = 12

function alarm2() {
    return document.querySelector('#divOutForFunctionTask_2').innerHTML = a2;
}

alarm2()

// ____ Task 3

function alarm3(x, y) {
    return x*y
}

document.querySelector('#buttonForFunctionTask_3').onclick = () => {
document.querySelector('#divOutForFunctionTask_3').innerHTML = alarm3(2,3)
}

// _____________________Text content || innerHTML___________________________

let primer = document.querySelector('.primer');
console.log(primer);
console.log(primer.innerHTML); // -> текст вывелся в лог со всеми html тегами в нем
console.log(primer.textContent); // -> текст вывелся в лог сработал br и span не сработал <b> <i>
// работа textContent схожа с innerText

// добавляем второй текст сразу на страницу без лога
// document.querySelector('#divOutLorem_1').innerHTML = primer.innerHTML 
console.log(primer.innerText); // -> текст вывелся в лог без некоторых html тегов отработал br span
// проигнорированы <b> <i>

document.querySelector('#divOutLorem_1').innerText = primer.innerText // -> текст вывелся на страницу без влияния на него тегов html

// textContent пробуем вывести внутрь блока

document.querySelector('#divOutLorem_1').innerHTML = primer.textContent // теги проигнорированы

document.querySelector('#divOutLorem_1').textContent = primer.textContent // теги проигнорированы

// textContent выше скорость обработки чем у innerHTML


// Вывод если нам нужны HTML теги используем innerHTML если нам нужен просто вывод используем textContent


//____________________________________Циклы Do and Do While___________________________________________________

for (let i = 0; i < 6; i++) {
    console.log(i); // -> от 0 до 5
}

/* while - это ключевое слово которое запускает тело цикла, тело цикла работает до тех пор пока в скобочках будет true

пока k будет меньше 5 то что в скобочках будет выполняться*/

let k = 0;
// while (k < 5) {
//     k++ // -> k: от 1 до 5
//     console.log('k:' + k);
// }
// -> k: от 1 до 5

// while (k<5) {
//     console.log('k:' + k);
//     k++ // -> k: от 0 до 4
// }
// -> k: от 0 до 4

while (k<5) {
    k++
    console.log('k:' + k);
    if (k == 3) continue; // - continue никак не повлияло на вывод
    // k++ если поставить k здесь - будет бесконечный цикл
}

// с помощью цикла while найдем сумму чисел от 0 до 10

let sum = 0;
let p = 0;
// while (p<=10) {
//     p++
//     sum = sum + p
   
//     console.log(sum); // 0 = 0 + 1; 1 наверх в условие, возвращается через 1++; 1 = 1 + 2; 3 = 3 + 3; 6 = 6 + 4; 10 = 10 + 5; 15 = 15 + 6; 21 = 21 + 7; 28 = 28 + 8; 36 = 36 + 9; 45 = 45 + 10; 55 
// }
// console.log('sum = '+ sum);

while (p <= 10) {
    sum = sum + p
    p++
    console.log(sum); // 0 = 0 + 0; sum = 0 p = 1; 0 = 0 + 1; sum = 1 p = 2; 1 = 1 + 2; sum = 3 p = 3; 3 = 3 + 3: sum = 6 p = 4; 6 = 6 + 4; sum = 10 p = 5; 10 = 10 + 5; sum = 15 p = 6; 15 = 15 + 6; 21 7; 21 = 21 + 7; 28 8; 28 = 28 + 8; 36 9 = 36 + 9 = 45; 45 10; 45 = 45 + 10 = 55 
}
console.log('sum =' + sum);

// произведение чисел решается так же

// рисуем квадрат *
let square = document.querySelector('#divOutLorem_1')
let squareStar = ''

p = 0;
let flag = 3;

while (p < 4) {
    let p1 = 0
    while (p1 < 4) {
        if (p1 < flag) {
            squareStar = squareStar + '&nbsp' // - неразрывный пробел для понимания можно заменить 0 - ком
        }
        else {
            squareStar = squareStar + '*' // '' = '' + '*'; '*' = '*' + '*'; '**' = '**' + '*'; '***' = '***' + '*'; '****' 
        }
     
    p1++
    }
    flag--
    squareStar = squareStar + '<br>'
    p++
}
square.innerHTML = squareStar // -> ****

/* while (p(4) < 4) {
    let p1 = 0
    while (p1(4) < 4) {
        if (p1(4) < flag(0)) {
            squareStar'' = squareStar'' + '&nbsp' 
        }
        else {
            squareStar'' = squareStar'' + '*'       squareStar''''*<br> squareStar'''**<br> squareStar''***<br> squareStar****<br>
                                                    
    p1++(4)
    }
    flag--(-1)
    squareStar = squareStar + '<br>'
    p++(4)
}
square.innerHTML = squareStar */

// самостоятельная усложнённая версия while

let whileTrain = document.querySelector('#WhileTrain');
let whileVoidString = '';
let i = 0;
let iflag = 4;

while (i < 5) {
    let ii = 0;
    while (ii < 5) {
        if (ii < iflag) {
            whileVoidString += '&nbsp'
        }
        else {
            whileVoidString += '&'
        }
    ii++    
    }
    iflag--
    whileVoidString += '<br>'
    i++
}
whileTrain.innerHTML = whileVoidString

/* Как работает цикл

let whileTrain = document.querySelector('#WhileTrain');
let whileVoidString = '';
let i = 0;
let iflag = 4;

while (i(5) < 5) {
    let ii = 0;
    while (ii(5) < 5) {
        if (ii(4) < iflag(0)) {
            whileVoidString += '&nbsp'
        }
        else {
            whileVoidString += '&'
        }
    ii++(5)    
    }
    iflag--(-1)
    whileVoidString += '<br>'
    i++(5)
}

whileVoidString = '''''&<br>
whileVoidString = ''''&&<br>
whileVoidString = '''&&&<br>
whileVoidString = ''&&&&<br>
whileVoidString = &&&&&<br>

whileTrain.innerHTML = whileVoidString
*/

// ______________________________Работа с DOM, создание элементов, работа с CSS________________________________

const p1 = document.querySelector('.p_1');

// присваиваем элементу стиль, в отличие от CSS здесь вместо дефиса у свойства пишется camelCase
// и все что мы присваиваем является строками

p1.style.width = '150px'; // если закоментирую это свойство ширина будет 100% всей страницы - по родитльскому элементу
p1.style.paddingBottom = '40px'
p1.style.textAlign = 'center'

// console.log(p1.style);

// присваиваем новый класс из CSS методом add с именем класса

p1.classList.add('p_2') // добавление через JS любых CSS классов 

/* в Elements после этого добавилось свойство p_2:
<p class="p_1 p_2" style="width: 150px; padding-bottom: 40px; text-align: center;">Text</p>
*/

// так мы можем добавлять в том числе и несуществующие классы а потом дописать их в CSS

p1.classList.add('p_3')

// удаление CSS класса с помощью JS
// p1.classList.remove('p_3')

// теперь мы можем из JS изменять состояния html элементов

const toggle = document.querySelector('.toggle');

// this это элемент на котором происходит событие

toggle.onclick = function() {
    this.classList.toggle('p_3') // по щелчку к кнопке toogle применяется свойство из CSS
}

// для того чтобы хранить данные либо состояния или свойства в html объектах не предусмотренные программистами
// которые создавали html и CSS был специально разработан такой инструмент как атрибуты

// Атрибуты

// мы можем манипулировать атрибутами так как хотим
// Для того чтобы в html 5 мы создавали корректные атрибуты перед ними должна быть приставка data в виде атрибута
// <p data='privet'></p>
// как получить атрибут data
console.log(p1.getAttribute('data')) // дальше есть 2 возможности первая создавать атрибуты вторая 
// читать атрибуты (getAttribute('')) и указать имя атрибута

// мы можем создать и перезаписать любой атрибут
// сначала пишем имя атрибута, в html 5 рекомендуют писать имя атрибута с приставки data 
// вторым может идти значение: строка или число

p1.setAttribute('data-num', 6) 
/* <p class="p_1 p_2 p_3" data="privet" data-num="6" style="width: 150px; padding-bottom: 40px; text-align: center;">Text</p>*/

//___Task 1
/* При нажатии любой из кнопок запускаем функцию
в начале получим сами кнопки */

let gas = document.querySelectorAll('.gas') // это массив, а раз это массив то мы должны его перебрать
// вешаем событие
for (let i = 0; i < gas.length; i++) {
    gas[i].onclick = function() {
        let gallons = document.querySelector('.gallons').value
        let amount = this.getAttribute('data') // this это кнопка по которой нажали 
        console.log(gallons*amount)
    }
}

// -> при введении 10 получаем 12 16 19
// мы научились с помощью атрибутов сохранять данные в html
/* в интернет магазине как узнать какой товар выбрал пользователь самое простое просто на кнопку повесить id товара
когда пользователь кликает по кнопке считать этот дата атрибут и мы будем знать по какому товару он кликнул

Если у нас есть массив кнопок мы сможем легко понять какой товар выбран а если не сможем отправим на серевер и там 
разберемся*/

/* Нам не нужен html чтобы создавать элементы
Создание элемента */
let firstCreateElementJS = document.createElement('div')

console.log(firstCreateElementJS);

/* Когда я получаю элемент со страницы я получаю элемент с помощью querySelector
я получаю элемент который уже был создан кем-то
а с помощью createElement я заново создаю элемент

Добавляем текст в firstCreateElementJS*/
firstCreateElementJS.innerHTML = 'ilia'

// добавляем класс
firstCreateElementJS.classList.add('d_1')

// Разница с элементом полученным со страницы html в том, что мой элемент,
// ещё не существует на странице, я могу его туда вставить,
// для начала нам понадобится id или class элемента, в который мы будем его добавлять
document.querySelector('#addCreateElementJS').appendChild(firstCreateElementJS); // -> элемент создан

// можем добавить событие на вновь созданные элемент или удалять элемент из DOM при клике
firstCreateElementJS.onclick = function() {
    console.log('ilia first')
}

// ____________________________________Методы push pop splice_______________________________________________

const array_1 = [1,2,3,4,5,6,7,8,9]
const array_2 = ['a', 'b', 'c', 'd', 'e', 'f']

// ___ Push - добавляет элементы в конец массива
// возвращает новое свойство длины объекта length, новый массив не создает, работает со старым.
console.log(array_1.length); // -> 9 length считается с 1 index считается с 0

array_1.push(10)

console.log(array_1) // -> (10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// добавим несколько чисел

array_1.push(11, 12, 13, 14, 15)

console.log(array_1); // -> (15) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

// повторяем операцию с массивом строк

array_2.push('j', 'h', 'i')

console.log(array_2); // -> (9) ['a', 'b', 'c', 'd', 'e', 'f', 'j', 'h', 'i']

// ___ Pop - удаляет элементы с конца массива, последний элемент массива или undefined, если массив пуст.
// Метод pop удаляет последний элемент из массива и возвращает удалённое значение.
// если просто вызвать pop() без значения удалится 1 последний элемент массива
// если вызвать pop() несколько раз подряд произойдет удаление нескольких элементов массива
// у метода pop нет параметров это просто метод со ()

console.log(array_2); // -> (9) ['a', 'b', 'c', 'd', 'e', 'f', 'j', 'h', 'i']

console.log(array_2.pop()); // -> i

console.log(array_2); // -> (8) ['a', 'b', 'c', 'd', 'e', 'f', 'j', 'h']

// ___ Работа с элементами внутри массива
// ___ Удаление элемента внутри массива

delete array_2[7];

console.log(array_2); // -> (8) ['a', 'b', 'c', 'd', 'e', 'f', 'j', empty]

// 7 индекс - пропадает при этом длина массива - не меняется
// после delete в массиве остаются пустые empty
// операции удаления из массива чаще всего являются медленными 
// поэтому лучше будет создать новый массив с нужными элементами
// принцип immutable

// если хочу вырезать элемент из массива без оствашегося empty так чтобы все индексы после этого шли по порядку

// ___ Splice

// array.splice() 
// Метод splice() изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.

// start - индекс, по которому начинает изменять массив. 
// если start больше длины массива, реальный индекс будет установлен на длину массива. 
// если отрицателен, указывает индекс элемента с конца.

/* deleteCount целое число, показывающее количество старых удаляемых из массива элементов.
если deleteCount равен 0, элементы не удаляются. 
В этом случае вы должны указать как минимум один новый элемент. 
Если deleteCount больше количества элементов, оставшихся в массиве, начиная с индекса start, 
то будут удалены все элементы до конца массива.

Возвращаемое значение
Массив, содержащий удалённые элементы. 
Если будет удалён только один элемент, вернётся массив из одного элемента.
Если никакие элементы не будут удалены, вернётся пустой массив.

Если количество указанных вставляемых элементов будет отличным от количества удаляемых элементов,
массив изменит длину после вызова.

Удаляет 0 элементов по индексу 2 и вставляет "drum"
var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(2, 0, 'drum');

myFish равен ["angel", "clown", "drum", "mandarin", "sturgeon"]
removed равен [], ничего не удалено

Удаляет 1 элемент по индексу 3
var myFish = ['angel', 'clown', 'drum', 'mandarin', 'sturgeon'];
var removed = myFish.splice(3, 1);

removed равен ["mandarin"]
myFish равен ["angel", "clown", "drum", "sturgeon"]

Удаляет 1 элемент по индексу 2 и вставляет "trumpet"
var myFish = ['angel', 'clown', 'drum', 'sturgeon'];
var removed = myFish.splice(2, 1, 'trumpet');

myFish равен ["angel", "clown", "trumpet", "sturgeon"]
removed равен ["drum"]

Удаляет 2 элемента начиная с индекса 0 и вставляет "parrot", "anemone" и "blue"
var myFish = ['angel', 'clown', 'trumpet', 'sturgeon'];
var removed = myFish.splice(0, 2, 'parrot', 'anemone', 'blue');

myFish равен ["parrot", "anemone", "blue", "trumpet", "sturgeon"]
removed равен ["angel", "clown"]

Удаляет 2 элемента начиная с индекса 2
var myFish = ['parrot', 'anemone', 'blue', 'trumpet', 'sturgeon'];
var removed = myFish.splice(myFish.length - 3, 2);

// myFish равен ["parrot", "anemone", "sturgeon"]
// removed равен ["blue", "trumpet"]

?
Удаляет 1 элемент по индексу -2
var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(-2, 1);

// myFish равен ["angel", "clown", "sturgeon"]
// removed равен s ["mandarin"]

Удаляет все элементы после индекса 2 (включительно)
var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(2);

// myFish равен ["angel", "clown"]
// removed равен ["mandarin", "sturgeon"]

с помозью splice удаляем наш empty*/

array_2.splice(6, 2); // -> (8) ['a', 'b', 'c', 'd', 'e', 'f', 'j', empty]
console.log(array_2); // -> (6) ['a', 'b', 'c', 'd', 'e', 'f']

// удаляем из середины

array_2.splice(1, 2);
console.log(array_2) /* -> (4) ['a', 'd', 'e', 'f']
0: "a"
1: "d"
2: "e"
3: "f"
length: 4 

нужные элементы удалены индекс сместились

В методе splice после 2-х обязательных параметров указываются элементы которые буду добавлены в массив 
начиная с индекс который указан в качестве параметра start

Плюс в том что мы получаем новый массив с порядковыми индексами по возрастанию без пропусков

Минус если вы завязаны на какие - то элементы массива если в какой-то операции получаете a[4]
то в результате splice индексы будут смещены и под a[4] окажется не то что было нужно.*/

// __ shift unshift аналоги pop и push

/* Позволяют удалять и добавлять элементы в начало массива

shift() удаляет первый элемент из массива и возвращает его значение. Этот метод изменяет длину массива.

Пример: удаление элемента из массива
Следующий код показывает массив myFish до и после удаления его первого элемента. Также он показывает удалённый элемент:

var myFish = ['ангел', 'клоун', 'мандарин', 'хирург'];

console.log('myFish до: ' + myFish);
//myFish до: ангел,клоун,мандарин,хирург

var shifted = myFish.shift();

console.log('myFish после: ' + myFish);
//myFish после: клоун,мандарин,хирург

console.log('Удалён этот элемент: ' + shifted);
//Удалён этот элемент: ангел
Вывод этого примера будет следующим:

myFish до: ангел,клоун,мандарин,хирург
myFish после: клоун,мандарин,хирург
Удалён этот элемент: ангел


unshift() добавляет один или более элементов в начало массива и возвращает новую длину массива.

Возвращаемое значение
Новое свойство length объекта, над которым был вызван метод unshift.

Примеры
var arr = [1, 2];

arr.unshift(0);
результат вызова равен 3, новой длине массива
arr равен [0, 1, 2]

arr.unshift(-2, -1);
= 5
arr равен [-2, -1, 0, 1, 2]

arr.unshift([-3]);
arr равен[[-3], -2, -1, 0, 1, 2]

Добавление элементов в начало массива тоже переводи к пересчету всех индексов*/













